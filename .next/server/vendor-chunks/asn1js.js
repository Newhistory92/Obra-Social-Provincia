"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/asn1js";
exports.ids = ["vendor-chunks/asn1js"];
exports.modules = {

/***/ "(ssr)/./node_modules/asn1js/build/index.js":
/*!********************************************!*\
  !*** ./node_modules/asn1js/build/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * Copyright (c) 2014, GMO GlobalSign\n * Copyright (c) 2015-2022, Peculiar Ventures\n * All rights reserved.\n * \n * Author 2014-2019, Yury Strozhevsky\n * \n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n * \n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n * \n * * Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n * \n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nvar pvutils = __webpack_require__(/*! pvutils */ \"(ssr)/./node_modules/pvutils/build/utils.js\");\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar pvtsutils__namespace = /*#__PURE__*/_interopNamespace(pvtsutils);\nvar pvutils__namespace = /*#__PURE__*/_interopNamespace(pvutils);\n\nfunction assertBigInt() {\r\n    if (typeof BigInt === \"undefined\") {\r\n        throw new Error(\"BigInt is not defined. Your environment doesn't implement BigInt.\");\r\n    }\r\n}\r\nfunction concat(buffers) {\r\n    let outputLength = 0;\r\n    let prevLength = 0;\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        outputLength += buffer.byteLength;\r\n    }\r\n    const retView = new Uint8Array(outputLength);\r\n    for (let i = 0; i < buffers.length; i++) {\r\n        const buffer = buffers[i];\r\n        retView.set(new Uint8Array(buffer), prevLength);\r\n        prevLength += buffer.byteLength;\r\n    }\r\n    return retView.buffer;\r\n}\r\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\r\n    if (!(inputBuffer instanceof Uint8Array)) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer must be 'Uint8Array'\";\r\n        return false;\r\n    }\r\n    if (!inputBuffer.byteLength) {\r\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\r\n        return false;\r\n    }\r\n    if (inputOffset < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\r\n        return false;\r\n    }\r\n    if (inputLength < 0) {\r\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\r\n        return false;\r\n    }\r\n    if ((inputBuffer.byteLength - inputOffset - inputLength) < 0) {\r\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n        return false;\r\n    }\r\n    return true;\r\n}\n\nclass ViewWriter {\r\n    constructor() {\r\n        this.items = [];\r\n    }\r\n    write(buf) {\r\n        this.items.push(buf);\r\n    }\r\n    final() {\r\n        return concat(this.items);\r\n    }\r\n}\n\nconst powers2 = [new Uint8Array([1])];\r\nconst digitsString = \"0123456789\";\r\nconst NAME = \"name\";\r\nconst VALUE_HEX_VIEW = \"valueHexView\";\r\nconst IS_HEX_ONLY = \"isHexOnly\";\r\nconst ID_BLOCK = \"idBlock\";\r\nconst TAG_CLASS = \"tagClass\";\r\nconst TAG_NUMBER = \"tagNumber\";\r\nconst IS_CONSTRUCTED = \"isConstructed\";\r\nconst FROM_BER = \"fromBER\";\r\nconst TO_BER = \"toBER\";\r\nconst LOCAL = \"local\";\r\nconst EMPTY_STRING = \"\";\r\nconst EMPTY_BUFFER = new ArrayBuffer(0);\r\nconst EMPTY_VIEW = new Uint8Array(0);\r\nconst END_OF_CONTENT_NAME = \"EndOfContent\";\r\nconst OCTET_STRING_NAME = \"OCTET STRING\";\r\nconst BIT_STRING_NAME = \"BIT STRING\";\n\nfunction HexBlock(BaseClass) {\r\n    var _a;\r\n    return _a = class Some extends BaseClass {\r\n            constructor(...args) {\r\n                var _a;\r\n                super(...args);\r\n                const params = args[0] || {};\r\n                this.isHexOnly = (_a = params.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n                this.valueHexView = params.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\r\n            }\r\n            get valueHex() {\r\n                return this.valueHexView.slice().buffer;\r\n            }\r\n            set valueHex(value) {\r\n                this.valueHexView = new Uint8Array(value);\r\n            }\r\n            fromBER(inputBuffer, inputOffset, inputLength) {\r\n                const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n                if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n                    return -1;\r\n                }\r\n                const endLength = inputOffset + inputLength;\r\n                this.valueHexView = view.subarray(inputOffset, endLength);\r\n                if (!this.valueHexView.length) {\r\n                    this.warnings.push(\"Zero buffer length\");\r\n                    return inputOffset;\r\n                }\r\n                this.blockLength = inputLength;\r\n                return endLength;\r\n            }\r\n            toBER(sizeOnly = false) {\r\n                if (!this.isHexOnly) {\r\n                    this.error = \"Flag 'isHexOnly' is not set, abort\";\r\n                    return EMPTY_BUFFER;\r\n                }\r\n                if (sizeOnly) {\r\n                    return new ArrayBuffer(this.valueHexView.byteLength);\r\n                }\r\n                return (this.valueHexView.byteLength === this.valueHexView.buffer.byteLength)\r\n                    ? this.valueHexView.buffer\r\n                    : this.valueHexView.slice().buffer;\r\n            }\r\n            toJSON() {\r\n                return {\r\n                    ...super.toJSON(),\r\n                    isHexOnly: this.isHexOnly,\r\n                    valueHex: pvtsutils__namespace.Convert.ToHex(this.valueHexView),\r\n                };\r\n            }\r\n        },\r\n        _a.NAME = \"hexBlock\",\r\n        _a;\r\n}\n\nclass LocalBaseBlock {\r\n    constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW, } = {}) {\r\n        this.blockLength = blockLength;\r\n        this.error = error;\r\n        this.warnings = warnings;\r\n        this.valueBeforeDecodeView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(valueBeforeDecode);\r\n    }\r\n    static blockName() {\r\n        return this.NAME;\r\n    }\r\n    get valueBeforeDecode() {\r\n        return this.valueBeforeDecodeView.slice().buffer;\r\n    }\r\n    set valueBeforeDecode(value) {\r\n        this.valueBeforeDecodeView = new Uint8Array(value);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            blockName: this.constructor.NAME,\r\n            blockLength: this.blockLength,\r\n            error: this.error,\r\n            warnings: this.warnings,\r\n            valueBeforeDecode: pvtsutils__namespace.Convert.ToHex(this.valueBeforeDecodeView),\r\n        };\r\n    }\r\n}\r\nLocalBaseBlock.NAME = \"baseBlock\";\n\nclass ValueBlock extends LocalBaseBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        throw TypeError(\"User need to make a specific function in a class which extends 'ValueBlock'\");\r\n    }\r\n}\r\nValueBlock.NAME = \"valueBlock\";\n\nclass LocalIdentificationBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ idBlock = {}, } = {}) {\r\n        var _a, _b, _c, _d;\r\n        super();\r\n        if (idBlock) {\r\n            this.isHexOnly = (_a = idBlock.isHexOnly) !== null && _a !== void 0 ? _a : false;\r\n            this.valueHexView = idBlock.valueHex ? pvtsutils__namespace.BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\r\n            this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\r\n            this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\r\n            this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\r\n        }\r\n        else {\r\n            this.tagClass = -1;\r\n            this.tagNumber = -1;\r\n            this.isConstructed = false;\r\n        }\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let firstOctet = 0;\r\n        switch (this.tagClass) {\r\n            case 1:\r\n                firstOctet |= 0x00;\r\n                break;\r\n            case 2:\r\n                firstOctet |= 0x40;\r\n                break;\r\n            case 3:\r\n                firstOctet |= 0x80;\r\n                break;\r\n            case 4:\r\n                firstOctet |= 0xC0;\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return EMPTY_BUFFER;\r\n        }\r\n        if (this.isConstructed)\r\n            firstOctet |= 0x20;\r\n        if (this.tagNumber < 31 && !this.isHexOnly) {\r\n            const retView = new Uint8Array(1);\r\n            if (!sizeOnly) {\r\n                let number = this.tagNumber;\r\n                number &= 0x1F;\r\n                firstOctet |= number;\r\n                retView[0] = firstOctet;\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        if (!this.isHexOnly) {\r\n            const encodedBuf = pvutils__namespace.utilToBase(this.tagNumber, 7);\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const size = encodedBuf.byteLength;\r\n            const retView = new Uint8Array(size + 1);\r\n            retView[0] = (firstOctet | 0x1F);\r\n            if (!sizeOnly) {\r\n                for (let i = 0; i < (size - 1); i++)\r\n                    retView[i + 1] = encodedView[i] | 0x80;\r\n                retView[size] = encodedView[size - 1];\r\n            }\r\n            return retView.buffer;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.byteLength + 1);\r\n        retView[0] = (firstOctet | 0x1F);\r\n        if (!sizeOnly) {\r\n            const curView = this.valueHexView;\r\n            for (let i = 0; i < (curView.length - 1); i++)\r\n                retView[i + 1] = curView[i] | 0x80;\r\n            retView[this.valueHexView.byteLength] = curView[curView.length - 1];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        const tagClassMask = intBuffer[0] & 0xC0;\r\n        switch (tagClassMask) {\r\n            case 0x00:\r\n                this.tagClass = (1);\r\n                break;\r\n            case 0x40:\r\n                this.tagClass = (2);\r\n                break;\r\n            case 0x80:\r\n                this.tagClass = (3);\r\n                break;\r\n            case 0xC0:\r\n                this.tagClass = (4);\r\n                break;\r\n            default:\r\n                this.error = \"Unknown tag class\";\r\n                return -1;\r\n        }\r\n        this.isConstructed = (intBuffer[0] & 0x20) === 0x20;\r\n        this.isHexOnly = false;\r\n        const tagNumberMask = intBuffer[0] & 0x1F;\r\n        if (tagNumberMask !== 0x1F) {\r\n            this.tagNumber = (tagNumberMask);\r\n            this.blockLength = 1;\r\n        }\r\n        else {\r\n            let count = 1;\r\n            let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\r\n            let tagNumberBufferMaxLength = 255;\r\n            while (intBuffer[count] & 0x80) {\r\n                intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n                count++;\r\n                if (count >= intBuffer.length) {\r\n                    this.error = \"End of input reached before message was fully decoded\";\r\n                    return -1;\r\n                }\r\n                if (count === tagNumberBufferMaxLength) {\r\n                    tagNumberBufferMaxLength += 255;\r\n                    const tempBufferView = new Uint8Array(tagNumberBufferMaxLength);\r\n                    for (let i = 0; i < intTagNumberBuffer.length; i++)\r\n                        tempBufferView[i] = intTagNumberBuffer[i];\r\n                    intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\r\n                }\r\n            }\r\n            this.blockLength = (count + 1);\r\n            intTagNumberBuffer[count - 1] = intBuffer[count] & 0x7F;\r\n            const tempBufferView = new Uint8Array(count);\r\n            for (let i = 0; i < count; i++)\r\n                tempBufferView[i] = intTagNumberBuffer[i];\r\n            intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\r\n            intTagNumberBuffer.set(tempBufferView);\r\n            if (this.blockLength <= 9)\r\n                this.tagNumber = pvutils__namespace.utilFromBase(intTagNumberBuffer, 7);\r\n            else {\r\n                this.isHexOnly = true;\r\n                this.warnings.push(\"Tag too long, represented as hex-coded\");\r\n            }\r\n        }\r\n        if (((this.tagClass === 1)) &&\r\n            (this.isConstructed)) {\r\n            switch (this.tagNumber) {\r\n                case 1:\r\n                case 2:\r\n                case 5:\r\n                case 6:\r\n                case 9:\r\n                case 13:\r\n                case 14:\r\n                case 23:\r\n                case 24:\r\n                case 31:\r\n                case 32:\r\n                case 33:\r\n                case 34:\r\n                    this.error = \"Constructed encoding used for primitive type\";\r\n                    return -1;\r\n            }\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            tagClass: this.tagClass,\r\n            tagNumber: this.tagNumber,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalIdentificationBlock.NAME = \"identificationBlock\";\n\nclass LocalLengthBlock extends LocalBaseBlock {\r\n    constructor({ lenBlock = {}, } = {}) {\r\n        var _a, _b, _c;\r\n        super();\r\n        this.isIndefiniteForm = (_a = lenBlock.isIndefiniteForm) !== null && _a !== void 0 ? _a : false;\r\n        this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\r\n        this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (intBuffer.length === 0) {\r\n            this.error = \"Zero buffer length\";\r\n            return -1;\r\n        }\r\n        if (intBuffer[0] === 0xFF) {\r\n            this.error = \"Length block 0xFF is reserved by standard\";\r\n            return -1;\r\n        }\r\n        this.isIndefiniteForm = intBuffer[0] === 0x80;\r\n        if (this.isIndefiniteForm) {\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        this.longFormUsed = !!(intBuffer[0] & 0x80);\r\n        if (this.longFormUsed === false) {\r\n            this.length = (intBuffer[0]);\r\n            this.blockLength = 1;\r\n            return (inputOffset + this.blockLength);\r\n        }\r\n        const count = intBuffer[0] & 0x7F;\r\n        if (count > 8) {\r\n            this.error = \"Too big integer\";\r\n            return -1;\r\n        }\r\n        if ((count + 1) > intBuffer.length) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        const lenOffset = inputOffset + 1;\r\n        const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\r\n        if (lengthBufferView[count - 1] === 0x00)\r\n            this.warnings.push(\"Needlessly long encoded length\");\r\n        this.length = pvutils__namespace.utilFromBase(lengthBufferView, 8);\r\n        if (this.longFormUsed && (this.length <= 127))\r\n            this.warnings.push(\"Unnecessary usage of long length form\");\r\n        this.blockLength = count + 1;\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly = false) {\r\n        let retBuf;\r\n        let retView;\r\n        if (this.length > 127)\r\n            this.longFormUsed = true;\r\n        if (this.isIndefiniteForm) {\r\n            retBuf = new ArrayBuffer(1);\r\n            if (sizeOnly === false) {\r\n                retView = new Uint8Array(retBuf);\r\n                retView[0] = 0x80;\r\n            }\r\n            return retBuf;\r\n        }\r\n        if (this.longFormUsed) {\r\n            const encodedBuf = pvutils__namespace.utilToBase(this.length, 8);\r\n            if (encodedBuf.byteLength > 127) {\r\n                this.error = \"Too big length\";\r\n                return (EMPTY_BUFFER);\r\n            }\r\n            retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\r\n            if (sizeOnly)\r\n                return retBuf;\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = encodedBuf.byteLength | 0x80;\r\n            for (let i = 0; i < encodedBuf.byteLength; i++)\r\n                retView[i + 1] = encodedView[i];\r\n            return retBuf;\r\n        }\r\n        retBuf = new ArrayBuffer(1);\r\n        if (sizeOnly === false) {\r\n            retView = new Uint8Array(retBuf);\r\n            retView[0] = this.length;\r\n        }\r\n        return retBuf;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            longFormUsed: this.longFormUsed,\r\n            length: this.length,\r\n        };\r\n    }\r\n}\r\nLocalLengthBlock.NAME = \"lengthBlock\";\n\nconst typeStore = {};\n\nclass BaseBlock extends LocalBaseBlock {\r\n    constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\r\n        super(parameters);\r\n        this.name = name;\r\n        this.optional = optional;\r\n        if (primitiveSchema) {\r\n            this.primitiveSchema = primitiveSchema;\r\n        }\r\n        this.idBlock = new LocalIdentificationBlock(parameters);\r\n        this.lenBlock = new LocalLengthBlock(parameters);\r\n        this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        if (!writer) {\r\n            prepareIndefiniteForm(this);\r\n        }\r\n        const idBlockBuf = this.idBlock.toBER(sizeOnly);\r\n        _writer.write(idBlockBuf);\r\n        if (this.lenBlock.isIndefiniteForm) {\r\n            _writer.write(new Uint8Array([0x80]).buffer);\r\n            this.valueBlock.toBER(sizeOnly, _writer);\r\n            _writer.write(new ArrayBuffer(2));\r\n        }\r\n        else {\r\n            const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\r\n            this.lenBlock.length = valueBlockBuf.byteLength;\r\n            const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\r\n            _writer.write(lenBlockBuf);\r\n            _writer.write(valueBlockBuf);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            idBlock: this.idBlock.toJSON(),\r\n            lenBlock: this.lenBlock.toJSON(),\r\n            valueBlock: this.valueBlock.toJSON(),\r\n            name: this.name,\r\n            optional: this.optional,\r\n        };\r\n        if (this.primitiveSchema)\r\n            object.primitiveSchema = this.primitiveSchema.toJSON();\r\n        return object;\r\n    }\r\n    toString(encoding = \"ascii\") {\r\n        if (encoding === \"ascii\") {\r\n            return this.onAsciiEncoding();\r\n        }\r\n        return pvtsutils__namespace.Convert.ToHex(this.toBER());\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\r\n    }\r\n    isEqual(other) {\r\n        if (this === other) {\r\n            return true;\r\n        }\r\n        if (!(other instanceof this.constructor)) {\r\n            return false;\r\n        }\r\n        const thisRaw = this.toBER();\r\n        const otherRaw = other.toBER();\r\n        return pvutils__namespace.isEqualBuffer(thisRaw, otherRaw);\r\n    }\r\n}\r\nBaseBlock.NAME = \"BaseBlock\";\r\nfunction prepareIndefiniteForm(baseBlock) {\r\n    if (baseBlock instanceof typeStore.Constructed) {\r\n        for (const value of baseBlock.valueBlock.value) {\r\n            if (prepareIndefiniteForm(value)) {\r\n                baseBlock.lenBlock.isIndefiniteForm = true;\r\n            }\r\n        }\r\n    }\r\n    return !!baseBlock.lenBlock.isIndefiniteForm;\r\n}\n\nclass BaseStringBlock extends BaseBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\r\n        super(parameters, stringValueBlockType);\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        this.fromBuffer(this.valueBlock.valueHexView);\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : '${this.valueBlock.value}'`;\r\n    }\r\n}\r\nBaseStringBlock.NAME = \"BaseStringBlock\";\n\nclass LocalPrimitiveValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ isHexOnly = true, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = isHexOnly;\r\n    }\r\n}\r\nLocalPrimitiveValueBlock.NAME = \"PrimitiveValueBlock\";\n\nvar _a$w;\r\nclass Primitive extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalPrimitiveValueBlock);\r\n        this.idBlock.isConstructed = false;\r\n    }\r\n}\r\n_a$w = Primitive;\r\n(() => {\r\n    typeStore.Primitive = _a$w;\r\n})();\r\nPrimitive.NAME = \"PRIMITIVE\";\n\nfunction localChangeType(inputObject, newType) {\r\n    if (inputObject instanceof newType) {\r\n        return inputObject;\r\n    }\r\n    const newObject = new newType();\r\n    newObject.idBlock = inputObject.idBlock;\r\n    newObject.lenBlock = inputObject.lenBlock;\r\n    newObject.warnings = inputObject.warnings;\r\n    newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\r\n    return newObject;\r\n}\r\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\r\n    const incomingOffset = inputOffset;\r\n    let returnObject = new BaseBlock({}, ValueBlock);\r\n    const baseBlock = new LocalBaseBlock();\r\n    if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\r\n        returnObject.error = baseBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\r\n    if (!intBuffer.length) {\r\n        returnObject.error = \"Zero buffer length\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.idBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.idBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.idBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.idBlock.blockLength;\r\n    resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\r\n    if (returnObject.lenBlock.warnings.length) {\r\n        returnObject.warnings.concat(returnObject.lenBlock.warnings);\r\n    }\r\n    if (resultOffset === -1) {\r\n        returnObject.error = returnObject.lenBlock.error;\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    inputOffset = resultOffset;\r\n    inputLength -= returnObject.lenBlock.blockLength;\r\n    if (!returnObject.idBlock.isConstructed &&\r\n        returnObject.lenBlock.isIndefiniteForm) {\r\n        returnObject.error = \"Indefinite length form used for primitive encoding form\";\r\n        return {\r\n            offset: -1,\r\n            result: returnObject\r\n        };\r\n    }\r\n    let newASN1Type = BaseBlock;\r\n    switch (returnObject.idBlock.tagClass) {\r\n        case 1:\r\n            if ((returnObject.idBlock.tagNumber >= 37) &&\r\n                (returnObject.idBlock.isHexOnly === false)) {\r\n                returnObject.error = \"UNIVERSAL 37 and upper tags are reserved by ASN.1 standard\";\r\n                return {\r\n                    offset: -1,\r\n                    result: returnObject\r\n                };\r\n            }\r\n            switch (returnObject.idBlock.tagNumber) {\r\n                case 0:\r\n                    if ((returnObject.idBlock.isConstructed) &&\r\n                        (returnObject.lenBlock.length > 0)) {\r\n                        returnObject.error = \"Type [UNIVERSAL 0] is reserved\";\r\n                        return {\r\n                            offset: -1,\r\n                            result: returnObject\r\n                        };\r\n                    }\r\n                    newASN1Type = typeStore.EndOfContent;\r\n                    break;\r\n                case 1:\r\n                    newASN1Type = typeStore.Boolean;\r\n                    break;\r\n                case 2:\r\n                    newASN1Type = typeStore.Integer;\r\n                    break;\r\n                case 3:\r\n                    newASN1Type = typeStore.BitString;\r\n                    break;\r\n                case 4:\r\n                    newASN1Type = typeStore.OctetString;\r\n                    break;\r\n                case 5:\r\n                    newASN1Type = typeStore.Null;\r\n                    break;\r\n                case 6:\r\n                    newASN1Type = typeStore.ObjectIdentifier;\r\n                    break;\r\n                case 10:\r\n                    newASN1Type = typeStore.Enumerated;\r\n                    break;\r\n                case 12:\r\n                    newASN1Type = typeStore.Utf8String;\r\n                    break;\r\n                case 13:\r\n                    newASN1Type = typeStore.RelativeObjectIdentifier;\r\n                    break;\r\n                case 14:\r\n                    newASN1Type = typeStore.TIME;\r\n                    break;\r\n                case 15:\r\n                    returnObject.error = \"[UNIVERSAL 15] is reserved by ASN.1 standard\";\r\n                    return {\r\n                        offset: -1,\r\n                        result: returnObject\r\n                    };\r\n                case 16:\r\n                    newASN1Type = typeStore.Sequence;\r\n                    break;\r\n                case 17:\r\n                    newASN1Type = typeStore.Set;\r\n                    break;\r\n                case 18:\r\n                    newASN1Type = typeStore.NumericString;\r\n                    break;\r\n                case 19:\r\n                    newASN1Type = typeStore.PrintableString;\r\n                    break;\r\n                case 20:\r\n                    newASN1Type = typeStore.TeletexString;\r\n                    break;\r\n                case 21:\r\n                    newASN1Type = typeStore.VideotexString;\r\n                    break;\r\n                case 22:\r\n                    newASN1Type = typeStore.IA5String;\r\n                    break;\r\n                case 23:\r\n                    newASN1Type = typeStore.UTCTime;\r\n                    break;\r\n                case 24:\r\n                    newASN1Type = typeStore.GeneralizedTime;\r\n                    break;\r\n                case 25:\r\n                    newASN1Type = typeStore.GraphicString;\r\n                    break;\r\n                case 26:\r\n                    newASN1Type = typeStore.VisibleString;\r\n                    break;\r\n                case 27:\r\n                    newASN1Type = typeStore.GeneralString;\r\n                    break;\r\n                case 28:\r\n                    newASN1Type = typeStore.UniversalString;\r\n                    break;\r\n                case 29:\r\n                    newASN1Type = typeStore.CharacterString;\r\n                    break;\r\n                case 30:\r\n                    newASN1Type = typeStore.BmpString;\r\n                    break;\r\n                case 31:\r\n                    newASN1Type = typeStore.DATE;\r\n                    break;\r\n                case 32:\r\n                    newASN1Type = typeStore.TimeOfDay;\r\n                    break;\r\n                case 33:\r\n                    newASN1Type = typeStore.DateTime;\r\n                    break;\r\n                case 34:\r\n                    newASN1Type = typeStore.Duration;\r\n                    break;\r\n                default: {\r\n                    const newObject = returnObject.idBlock.isConstructed\r\n                        ? new typeStore.Constructed()\r\n                        : new typeStore.Primitive();\r\n                    newObject.idBlock = returnObject.idBlock;\r\n                    newObject.lenBlock = returnObject.lenBlock;\r\n                    newObject.warnings = returnObject.warnings;\r\n                    returnObject = newObject;\r\n                }\r\n            }\r\n            break;\r\n        case 2:\r\n        case 3:\r\n        case 4:\r\n        default: {\r\n            newASN1Type = returnObject.idBlock.isConstructed\r\n                ? typeStore.Constructed\r\n                : typeStore.Primitive;\r\n        }\r\n    }\r\n    returnObject = localChangeType(returnObject, newASN1Type);\r\n    resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\r\n    returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\r\n    return {\r\n        offset: resultOffset,\r\n        result: returnObject\r\n    };\r\n}\r\nfunction fromBER(inputBuffer) {\r\n    if (!inputBuffer.byteLength) {\r\n        const result = new BaseBlock({}, ValueBlock);\r\n        result.error = \"Input buffer has zero length\";\r\n        return {\r\n            offset: -1,\r\n            result\r\n        };\r\n    }\r\n    return localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\r\n}\n\nfunction checkLen(indefiniteLength, length) {\r\n    if (indefiniteLength) {\r\n        return 1;\r\n    }\r\n    return length;\r\n}\r\nclass LocalConstructedValueBlock extends ValueBlock {\r\n    constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.isIndefiniteForm = isIndefiniteForm;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const view = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, view, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\r\n        if (this.valueBeforeDecodeView.length === 0) {\r\n            this.warnings.push(\"Zero buffer length\");\r\n            return inputOffset;\r\n        }\r\n        let currentOffset = inputOffset;\r\n        while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\r\n            const returnObject = localFromBER(view, currentOffset, inputLength);\r\n            if (returnObject.offset === -1) {\r\n                this.error = returnObject.result.error;\r\n                this.warnings.concat(returnObject.result.warnings);\r\n                return -1;\r\n            }\r\n            currentOffset = returnObject.offset;\r\n            this.blockLength += returnObject.result.blockLength;\r\n            inputLength -= returnObject.result.blockLength;\r\n            this.value.push(returnObject.result);\r\n            if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\r\n                break;\r\n            }\r\n        }\r\n        if (this.isIndefiniteForm) {\r\n            if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\r\n                this.value.pop();\r\n            }\r\n            else {\r\n                this.warnings.push(\"No EndOfContent block encoded\");\r\n            }\r\n        }\r\n        return currentOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const _writer = writer || new ViewWriter();\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            this.value[i].toBER(sizeOnly, _writer);\r\n        }\r\n        if (!writer) {\r\n            return _writer.final();\r\n        }\r\n        return EMPTY_BUFFER;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            isIndefiniteForm: this.isIndefiniteForm,\r\n            value: [],\r\n        };\r\n        for (const value of this.value) {\r\n            object.value.push(value.toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalConstructedValueBlock.NAME = \"ConstructedValueBlock\";\n\nvar _a$v;\r\nclass Constructed extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalConstructedValueBlock);\r\n        this.idBlock.isConstructed = true;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, (this.lenBlock.isIndefiniteForm) ? inputLength : this.lenBlock.length);\r\n        if (resultOffset === -1) {\r\n            this.error = this.valueBlock.error;\r\n            return resultOffset;\r\n        }\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        if (!this.valueBlock.error.length)\r\n            this.blockLength += this.valueBlock.blockLength;\r\n        return resultOffset;\r\n    }\r\n    onAsciiEncoding() {\r\n        const values = [];\r\n        for (const value of this.valueBlock.value) {\r\n            values.push(value.toString(\"ascii\").split(\"\\n\").map(o => `  ${o}`).join(\"\\n\"));\r\n        }\r\n        const blockName = this.idBlock.tagClass === 3\r\n            ? `[${this.idBlock.tagNumber}]`\r\n            : this.constructor.NAME;\r\n        return values.length\r\n            ? `${blockName} :\\n${values.join(\"\\n\")}`\r\n            : `${blockName} :`;\r\n    }\r\n}\r\n_a$v = Constructed;\r\n(() => {\r\n    typeStore.Constructed = _a$v;\r\n})();\r\nConstructed.NAME = \"CONSTRUCTED\";\n\nclass LocalEndOfContentValueBlock extends ValueBlock {\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        return inputOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return EMPTY_BUFFER;\r\n    }\r\n}\r\nLocalEndOfContentValueBlock.override = \"EndOfContentValueBlock\";\n\nvar _a$u;\r\nclass EndOfContent extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalEndOfContentValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 0;\r\n    }\r\n}\r\n_a$u = EndOfContent;\r\n(() => {\r\n    typeStore.EndOfContent = _a$u;\r\n})();\r\nEndOfContent.NAME = END_OF_CONTENT_NAME;\n\nvar _a$t;\r\nclass Null extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, ValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 5;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (this.lenBlock.length > 0)\r\n            this.warnings.push(\"Non-zero length of value block for Null type\");\r\n        if (!this.idBlock.error.length)\r\n            this.blockLength += this.idBlock.blockLength;\r\n        if (!this.lenBlock.error.length)\r\n            this.blockLength += this.lenBlock.blockLength;\r\n        this.blockLength += inputLength;\r\n        if ((inputOffset + inputLength) > inputBuffer.byteLength) {\r\n            this.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\r\n            return -1;\r\n        }\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuf = new ArrayBuffer(2);\r\n        if (!sizeOnly) {\r\n            const retView = new Uint8Array(retBuf);\r\n            retView[0] = 0x05;\r\n            retView[1] = 0x00;\r\n        }\r\n        if (writer) {\r\n            writer.write(retBuf);\r\n        }\r\n        return retBuf;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME}`;\r\n    }\r\n}\r\n_a$t = Null;\r\n(() => {\r\n    typeStore.Null = _a$t;\r\n})();\r\nNull.NAME = \"NULL\";\n\nclass LocalBooleanValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        if (parameters.valueHex) {\r\n            this.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(parameters.valueHex);\r\n        }\r\n        else {\r\n            this.valueHexView = new Uint8Array(1);\r\n        }\r\n        if (value) {\r\n            this.value = value;\r\n        }\r\n    }\r\n    get value() {\r\n        for (const octet of this.valueHexView) {\r\n            if (octet > 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    set value(value) {\r\n        this.valueHexView[0] = value ? 0xFF : 0x00;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        if (inputLength > 1)\r\n            this.warnings.push(\"Boolean value encoded in more then 1 octet\");\r\n        this.isHexOnly = true;\r\n        pvutils__namespace.utilDecodeTC.call(this);\r\n        this.blockLength = inputLength;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER() {\r\n        return this.valueHexView.slice();\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalBooleanValueBlock.NAME = \"BooleanValueBlock\";\n\nvar _a$s;\r\nclass Boolean extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalBooleanValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 1;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.value;\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.value = value;\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.getValue}`;\r\n    }\r\n}\r\n_a$s = Boolean;\r\n(() => {\r\n    typeStore.Boolean = _a$s;\r\n})();\r\nBoolean.NAME = \"BOOLEAN\";\n\nclass LocalOctetStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isConstructed = isConstructed;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = 0;\r\n        if (this.isConstructed) {\r\n            this.isHexOnly = false;\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (let i = 0; i < this.value.length; i++) {\r\n                const currentBlockName = this.value[i].constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== OCTET_STRING_NAME) {\r\n                    this.error = \"OCTET STRING may consists of OCTET STRINGs only\";\r\n                    return -1;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.isHexOnly = true;\r\n            resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n            this.blockLength = inputLength;\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed)\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.byteLength)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalOctetStringValueBlock.NAME = \"OctetStringValueBlock\";\n\nvar _a$r;\r\nclass OctetString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalOctetStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 4;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        if (inputLength === 0) {\r\n            if (this.idBlock.error.length === 0)\r\n                this.blockLength += this.idBlock.blockLength;\r\n            if (this.lenBlock.error.length === 0)\r\n                this.blockLength += this.lenBlock.blockLength;\r\n            return inputOffset;\r\n        }\r\n        if (!this.valueBlock.isConstructed) {\r\n            const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\r\n            const buf = view.subarray(inputOffset, inputOffset + inputLength);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === inputLength) {\r\n                        this.valueBlock.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        return `${this.constructor.NAME} : ${pvtsutils__namespace.Convert.ToHex(this.valueBlock.valueHexView)}`;\r\n    }\r\n    getValue() {\r\n        if (!this.idBlock.isConstructed) {\r\n            return this.valueBlock.valueHexView.slice().buffer;\r\n        }\r\n        const array = [];\r\n        for (const content of this.valueBlock.value) {\r\n            if (content instanceof OctetString) {\r\n                array.push(content.valueBlock.valueHexView);\r\n            }\r\n        }\r\n        return pvtsutils__namespace.BufferSourceConverter.concat(array);\r\n    }\r\n}\r\n_a$r = OctetString;\r\n(() => {\r\n    typeStore.OctetString = _a$r;\r\n})();\r\nOctetString.NAME = OCTET_STRING_NAME;\n\nclass LocalBitStringValueBlock extends HexBlock(LocalConstructedValueBlock) {\r\n    constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.unusedBits = unusedBits;\r\n        this.isConstructed = isConstructed;\r\n        this.blockLength = this.valueHexView.byteLength;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        let resultOffset = -1;\r\n        if (this.isConstructed) {\r\n            resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\r\n            if (resultOffset === -1)\r\n                return resultOffset;\r\n            for (const value of this.value) {\r\n                const currentBlockName = value.constructor.NAME;\r\n                if (currentBlockName === END_OF_CONTENT_NAME) {\r\n                    if (this.isIndefiniteForm)\r\n                        break;\r\n                    else {\r\n                        this.error = \"EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only\";\r\n                        return -1;\r\n                    }\r\n                }\r\n                if (currentBlockName !== BIT_STRING_NAME) {\r\n                    this.error = \"BIT STRING may consists of BIT STRINGs only\";\r\n                    return -1;\r\n                }\r\n                const valueBlock = value.valueBlock;\r\n                if ((this.unusedBits > 0) && (valueBlock.unusedBits > 0)) {\r\n                    this.error = \"Using of \\\"unused bits\\\" inside constructive BIT STRING allowed for least one only\";\r\n                    return -1;\r\n                }\r\n                this.unusedBits = valueBlock.unusedBits;\r\n            }\r\n            return resultOffset;\r\n        }\r\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.unusedBits = intBuffer[0];\r\n        if (this.unusedBits > 7) {\r\n            this.error = \"Unused bits for BitString must be in range 0-7\";\r\n            return -1;\r\n        }\r\n        if (!this.unusedBits) {\r\n            const buf = intBuffer.subarray(1);\r\n            try {\r\n                if (buf.byteLength) {\r\n                    const asn = localFromBER(buf, 0, buf.byteLength);\r\n                    if (asn.offset !== -1 && asn.offset === (inputLength - 1)) {\r\n                        this.value = [asn.result];\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        this.valueHexView = intBuffer.subarray(1);\r\n        this.blockLength = intBuffer.length;\r\n        return (inputOffset + inputLength);\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        if (this.isConstructed) {\r\n            return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\r\n        }\r\n        if (sizeOnly) {\r\n            return new ArrayBuffer(this.valueHexView.byteLength + 1);\r\n        }\r\n        if (!this.valueHexView.byteLength) {\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(this.valueHexView.length + 1);\r\n        retView[0] = this.unusedBits;\r\n        retView.set(this.valueHexView, 1);\r\n        return retView.buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            unusedBits: this.unusedBits,\r\n            isConstructed: this.isConstructed,\r\n        };\r\n    }\r\n}\r\nLocalBitStringValueBlock.NAME = \"BitStringValueBlock\";\n\nvar _a$q;\r\nclass BitString extends BaseBlock {\r\n    constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\r\n        var _b, _c;\r\n        (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : (parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length));\r\n        super({\r\n            idBlock: {\r\n                isConstructed: parameters.isConstructed,\r\n                ...idBlock,\r\n            },\r\n            lenBlock: {\r\n                ...lenBlock,\r\n                isIndefiniteForm: !!parameters.isIndefiniteForm,\r\n            },\r\n            ...parameters,\r\n        }, LocalBitStringValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 3;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        this.valueBlock.isConstructed = this.idBlock.isConstructed;\r\n        this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\r\n        return super.fromBER(inputBuffer, inputOffset, inputLength);\r\n    }\r\n    onAsciiEncoding() {\r\n        if (this.valueBlock.isConstructed || (this.valueBlock.value && this.valueBlock.value.length)) {\r\n            return Constructed.prototype.onAsciiEncoding.call(this);\r\n        }\r\n        else {\r\n            const bits = [];\r\n            const valueHex = this.valueBlock.valueHexView;\r\n            for (const byte of valueHex) {\r\n                bits.push(byte.toString(2).padStart(8, \"0\"));\r\n            }\r\n            const bitsStr = bits.join(\"\");\r\n            return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\r\n        }\r\n    }\r\n}\r\n_a$q = BitString;\r\n(() => {\r\n    typeStore.BitString = _a$q;\r\n})();\r\nBitString.NAME = BIT_STRING_NAME;\n\nvar _a$p;\r\nfunction viewAdd(first, second) {\r\n    const c = new Uint8Array([0]);\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    let firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value = 0;\r\n    const max = (secondViewCopyLength < firstViewCopyLength) ? firstViewCopyLength : secondViewCopyLength;\r\n    let counter = 0;\r\n    for (let i = max; i >= 0; i--, counter++) {\r\n        switch (true) {\r\n            case (counter < secondViewCopy.length):\r\n                value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\r\n                break;\r\n            default:\r\n                value = firstViewCopy[firstViewCopyLength - counter] + c[0];\r\n        }\r\n        c[0] = value / 10;\r\n        switch (true) {\r\n            case (counter >= firstViewCopy.length):\r\n                firstViewCopy = pvutils__namespace.utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\r\n                break;\r\n            default:\r\n                firstViewCopy[firstViewCopyLength - counter] = value % 10;\r\n        }\r\n    }\r\n    if (c[0] > 0)\r\n        firstViewCopy = pvutils__namespace.utilConcatView(c, firstViewCopy);\r\n    return firstViewCopy;\r\n}\r\nfunction power2(n) {\r\n    if (n >= powers2.length) {\r\n        for (let p = powers2.length; p <= n; p++) {\r\n            const c = new Uint8Array([0]);\r\n            let digits = (powers2[p - 1]).slice(0);\r\n            for (let i = (digits.length - 1); i >= 0; i--) {\r\n                const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\r\n                c[0] = newValue[0] / 10;\r\n                digits[i] = newValue[0] % 10;\r\n            }\r\n            if (c[0] > 0)\r\n                digits = pvutils__namespace.utilConcatView(c, digits);\r\n            powers2.push(digits);\r\n        }\r\n    }\r\n    return powers2[n];\r\n}\r\nfunction viewSub(first, second) {\r\n    let b = 0;\r\n    const firstView = new Uint8Array(first);\r\n    const secondView = new Uint8Array(second);\r\n    const firstViewCopy = firstView.slice(0);\r\n    const firstViewCopyLength = firstViewCopy.length - 1;\r\n    const secondViewCopy = secondView.slice(0);\r\n    const secondViewCopyLength = secondViewCopy.length - 1;\r\n    let value;\r\n    let counter = 0;\r\n    for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\r\n        value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\r\n        switch (true) {\r\n            case (value < 0):\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n                break;\r\n            default:\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n        }\r\n    }\r\n    if (b > 0) {\r\n        for (let i = (firstViewCopyLength - secondViewCopyLength + 1); i >= 0; i--, counter++) {\r\n            value = firstViewCopy[firstViewCopyLength - counter] - b;\r\n            if (value < 0) {\r\n                b = 1;\r\n                firstViewCopy[firstViewCopyLength - counter] = value + 10;\r\n            }\r\n            else {\r\n                b = 0;\r\n                firstViewCopy[firstViewCopyLength - counter] = value;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return firstViewCopy.slice();\r\n}\r\nclass LocalIntegerValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ value, ...parameters } = {}) {\r\n        super(parameters);\r\n        this._valueDec = 0;\r\n        if (parameters.valueHex) {\r\n            this.setValueHex();\r\n        }\r\n        if (value !== undefined) {\r\n            this.valueDec = value;\r\n        }\r\n    }\r\n    setValueHex() {\r\n        if (this.valueHexView.length >= 4) {\r\n            this.warnings.push(\"Too big Integer for decoding, hex only\");\r\n            this.isHexOnly = true;\r\n            this._valueDec = 0;\r\n        }\r\n        else {\r\n            this.isHexOnly = false;\r\n            if (this.valueHexView.length > 0) {\r\n                this._valueDec = pvutils__namespace.utilDecodeTC.call(this);\r\n            }\r\n        }\r\n    }\r\n    set valueDec(v) {\r\n        this._valueDec = v;\r\n        this.isHexOnly = false;\r\n        this.valueHexView = new Uint8Array(pvutils__namespace.utilEncodeTC(v));\r\n    }\r\n    get valueDec() {\r\n        return this._valueDec;\r\n    }\r\n    fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\r\n        const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (offset === -1)\r\n            return offset;\r\n        const view = this.valueHexView;\r\n        if ((view[0] === 0x00) && ((view[1] & 0x80) !== 0)) {\r\n            this.valueHexView = view.subarray(1);\r\n        }\r\n        else {\r\n            if (expectedLength !== 0) {\r\n                if (view.length < expectedLength) {\r\n                    if ((expectedLength - view.length) > 1)\r\n                        expectedLength = view.length + 1;\r\n                    this.valueHexView = view.subarray(expectedLength - view.length);\r\n                }\r\n            }\r\n        }\r\n        return offset;\r\n    }\r\n    toDER(sizeOnly = false) {\r\n        const view = this.valueHexView;\r\n        switch (true) {\r\n            case ((view[0] & 0x80) !== 0):\r\n                {\r\n                    const updatedView = new Uint8Array(this.valueHexView.length + 1);\r\n                    updatedView[0] = 0x00;\r\n                    updatedView.set(view, 1);\r\n                    this.valueHexView = updatedView;\r\n                }\r\n                break;\r\n            case ((view[0] === 0x00) && ((view[1] & 0x80) === 0)):\r\n                {\r\n                    this.valueHexView = this.valueHexView.subarray(1);\r\n                }\r\n                break;\r\n        }\r\n        return this.toBER(sizeOnly);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\r\n        if (resultOffset === -1) {\r\n            return resultOffset;\r\n        }\r\n        this.setValueHex();\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return sizeOnly\r\n            ? new ArrayBuffer(this.valueHexView.length)\r\n            : this.valueHexView.slice().buffer;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n    toString() {\r\n        const firstBit = (this.valueHexView.length * 8) - 1;\r\n        let digits = new Uint8Array((this.valueHexView.length * 8) / 3);\r\n        let bitNumber = 0;\r\n        let currentByte;\r\n        const asn1View = this.valueHexView;\r\n        let result = \"\";\r\n        let flag = false;\r\n        for (let byteNumber = (asn1View.byteLength - 1); byteNumber >= 0; byteNumber--) {\r\n            currentByte = asn1View[byteNumber];\r\n            for (let i = 0; i < 8; i++) {\r\n                if ((currentByte & 1) === 1) {\r\n                    switch (bitNumber) {\r\n                        case firstBit:\r\n                            digits = viewSub(power2(bitNumber), digits);\r\n                            result = \"-\";\r\n                            break;\r\n                        default:\r\n                            digits = viewAdd(digits, power2(bitNumber));\r\n                    }\r\n                }\r\n                bitNumber++;\r\n                currentByte >>= 1;\r\n            }\r\n        }\r\n        for (let i = 0; i < digits.length; i++) {\r\n            if (digits[i])\r\n                flag = true;\r\n            if (flag)\r\n                result += digitsString.charAt(digits[i]);\r\n        }\r\n        if (flag === false)\r\n            result += digitsString.charAt(0);\r\n        return result;\r\n    }\r\n}\r\n_a$p = LocalIntegerValueBlock;\r\nLocalIntegerValueBlock.NAME = \"IntegerValueBlock\";\r\n(() => {\r\n    Object.defineProperty(_a$p.prototype, \"valueHex\", {\r\n        set: function (v) {\r\n            this.valueHexView = new Uint8Array(v);\r\n            this.setValueHex();\r\n        },\r\n        get: function () {\r\n            return this.valueHexView.slice().buffer;\r\n        },\r\n    });\r\n})();\n\nvar _a$o;\r\nclass Integer extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalIntegerValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 2;\r\n    }\r\n    toBigInt() {\r\n        assertBigInt();\r\n        return BigInt(this.valueBlock.toString());\r\n    }\r\n    static fromBigInt(value) {\r\n        assertBigInt();\r\n        const bigIntValue = BigInt(value);\r\n        const writer = new ViewWriter();\r\n        const hex = bigIntValue.toString(16).replace(/^-/, \"\");\r\n        const view = new Uint8Array(pvtsutils__namespace.Convert.FromHex(hex));\r\n        if (bigIntValue < 0) {\r\n            const first = new Uint8Array(view.length + (view[0] & 0x80 ? 1 : 0));\r\n            first[0] |= 0x80;\r\n            const firstInt = BigInt(`0x${pvtsutils__namespace.Convert.ToHex(first)}`);\r\n            const secondInt = firstInt + bigIntValue;\r\n            const second = pvtsutils__namespace.BufferSourceConverter.toUint8Array(pvtsutils__namespace.Convert.FromHex(secondInt.toString(16)));\r\n            second[0] |= 0x80;\r\n            writer.write(second);\r\n        }\r\n        else {\r\n            if (view[0] & 0x80) {\r\n                writer.write(new Uint8Array([0]));\r\n            }\r\n            writer.write(view);\r\n        }\r\n        const res = new Integer({\r\n            valueHex: writer.final(),\r\n        });\r\n        return res;\r\n    }\r\n    convertToDER() {\r\n        const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\r\n        integer.valueBlock.toDER();\r\n        return integer;\r\n    }\r\n    convertFromDER() {\r\n        return new Integer({\r\n            valueHex: this.valueBlock.valueHexView[0] === 0\r\n                ? this.valueBlock.valueHexView.subarray(1)\r\n                : this.valueBlock.valueHexView,\r\n        });\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\r\n    }\r\n}\r\n_a$o = Integer;\r\n(() => {\r\n    typeStore.Integer = _a$o;\r\n})();\r\nInteger.NAME = \"INTEGER\";\n\nvar _a$n;\r\nclass Enumerated extends Integer {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 10;\r\n    }\r\n}\r\n_a$n = Enumerated;\r\n(() => {\r\n    typeStore.Enumerated = _a$n;\r\n})();\r\nEnumerated.NAME = \"ENUMERATED\";\n\nclass LocalSidValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n        this.isFirstSid = isFirstSid;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (!inputLength) {\r\n            return inputOffset;\r\n        }\r\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\r\n            return -1;\r\n        }\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++) {\r\n            tempView[i] = this.valueHexView[i];\r\n        }\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    set valueBigInt(value) {\r\n        assertBigInt();\r\n        let bits = BigInt(value).toString(2);\r\n        while (bits.length % 7) {\r\n            bits = \"0\" + bits;\r\n        }\r\n        const bytes = new Uint8Array(bits.length / 7);\r\n        for (let i = 0; i < bytes.length; i++) {\r\n            bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 0x80 : 0);\r\n        }\r\n        this.fromBER(bytes.buffer, 0, bytes.length);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            if (this.isFirstSid) {\r\n                let sidValue = this.valueDec;\r\n                if (this.valueDec <= 39)\r\n                    result = \"0.\";\r\n                else {\r\n                    if (this.valueDec <= 79) {\r\n                        result = \"1.\";\r\n                        sidValue -= 40;\r\n                    }\r\n                    else {\r\n                        result = \"2.\";\r\n                        sidValue -= 80;\r\n                    }\r\n                }\r\n                result += sidValue.toString();\r\n            }\r\n            else\r\n                result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n            isFirstSid: this.isFirstSid,\r\n        };\r\n    }\r\n}\r\nLocalSidValueBlock.NAME = \"sidBlock\";\n\nclass LocalObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            if (this.value.length === 0)\r\n                sidBlock.isFirstSid = true;\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        let flag = false;\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            if (flag) {\r\n                const sidBlock = this.value[0];\r\n                let plus = 0;\r\n                switch (sidBlock.valueDec) {\r\n                    case 0:\r\n                        break;\r\n                    case 1:\r\n                        plus = 40;\r\n                        break;\r\n                    case 2:\r\n                        plus = 80;\r\n                        break;\r\n                    default:\r\n                        this.value = [];\r\n                        return;\r\n                }\r\n                const parsedSID = parseInt(sid, 10);\r\n                if (isNaN(parsedSID))\r\n                    return;\r\n                sidBlock.valueDec = parsedSID + plus;\r\n                flag = false;\r\n            }\r\n            else {\r\n                const sidBlock = new LocalSidValueBlock();\r\n                if (sid > Number.MAX_SAFE_INTEGER) {\r\n                    assertBigInt();\r\n                    const sidValue = BigInt(sid);\r\n                    sidBlock.valueBigInt = sidValue;\r\n                }\r\n                else {\r\n                    sidBlock.valueDec = parseInt(sid, 10);\r\n                    if (isNaN(sidBlock.valueDec))\r\n                        return;\r\n                }\r\n                if (!this.value.length) {\r\n                    sidBlock.isFirstSid = true;\r\n                    flag = true;\r\n                }\r\n                this.value.push(sidBlock);\r\n            }\r\n        } while (pos2 !== -1);\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                if (this.value[i].isFirstSid)\r\n                    result = `2.{${sidStr} - 80}`;\r\n                else\r\n                    result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        }\r\n        return object;\r\n    }\r\n}\r\nLocalObjectIdentifierValueBlock.NAME = \"ObjectIdentifierValueBlock\";\n\nvar _a$m;\r\nclass ObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 6;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$m = ObjectIdentifier;\r\n(() => {\r\n    typeStore.ObjectIdentifier = _a$m;\r\n})();\r\nObjectIdentifier.NAME = \"OBJECT IDENTIFIER\";\n\nclass LocalRelativeSidValueBlock extends HexBlock(LocalBaseBlock) {\r\n    constructor({ valueDec = 0, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.valueDec = valueDec;\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        if (inputLength === 0)\r\n            return inputOffset;\r\n        const inputView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        if (!checkBufferParams(this, inputView, inputOffset, inputLength))\r\n            return -1;\r\n        const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\r\n        this.valueHexView = new Uint8Array(inputLength);\r\n        for (let i = 0; i < inputLength; i++) {\r\n            this.valueHexView[i] = intBuffer[i] & 0x7F;\r\n            this.blockLength++;\r\n            if ((intBuffer[i] & 0x80) === 0x00)\r\n                break;\r\n        }\r\n        const tempView = new Uint8Array(this.blockLength);\r\n        for (let i = 0; i < this.blockLength; i++)\r\n            tempView[i] = this.valueHexView[i];\r\n        this.valueHexView = tempView;\r\n        if ((intBuffer[this.blockLength - 1] & 0x80) !== 0x00) {\r\n            this.error = \"End of input reached before message was fully decoded\";\r\n            return -1;\r\n        }\r\n        if (this.valueHexView[0] === 0x00)\r\n            this.warnings.push(\"Needlessly long format of SID encoding\");\r\n        if (this.blockLength <= 8)\r\n            this.valueDec = pvutils__namespace.utilFromBase(this.valueHexView, 7);\r\n        else {\r\n            this.isHexOnly = true;\r\n            this.warnings.push(\"Too big SID for decoding, hex only\");\r\n        }\r\n        return (inputOffset + this.blockLength);\r\n    }\r\n    toBER(sizeOnly) {\r\n        if (this.isHexOnly) {\r\n            if (sizeOnly)\r\n                return (new ArrayBuffer(this.valueHexView.byteLength));\r\n            const curView = this.valueHexView;\r\n            const retView = new Uint8Array(this.blockLength);\r\n            for (let i = 0; i < (this.blockLength - 1); i++)\r\n                retView[i] = curView[i] | 0x80;\r\n            retView[this.blockLength - 1] = curView[this.blockLength - 1];\r\n            return retView.buffer;\r\n        }\r\n        const encodedBuf = pvutils__namespace.utilToBase(this.valueDec, 7);\r\n        if (encodedBuf.byteLength === 0) {\r\n            this.error = \"Error during encoding SID value\";\r\n            return EMPTY_BUFFER;\r\n        }\r\n        const retView = new Uint8Array(encodedBuf.byteLength);\r\n        if (!sizeOnly) {\r\n            const encodedView = new Uint8Array(encodedBuf);\r\n            const len = encodedBuf.byteLength - 1;\r\n            for (let i = 0; i < len; i++)\r\n                retView[i] = encodedView[i] | 0x80;\r\n            retView[len] = encodedView[len];\r\n        }\r\n        return retView.buffer;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        if (this.isHexOnly)\r\n            result = pvtsutils__namespace.Convert.ToHex(this.valueHexView);\r\n        else {\r\n            result = this.valueDec.toString();\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            valueDec: this.valueDec,\r\n        };\r\n    }\r\n}\r\nLocalRelativeSidValueBlock.NAME = \"relativeSidBlock\";\n\nclass LocalRelativeObjectIdentifierValueBlock extends ValueBlock {\r\n    constructor({ value = EMPTY_STRING, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = [];\r\n        if (value) {\r\n            this.fromString(value);\r\n        }\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        let resultOffset = inputOffset;\r\n        while (inputLength > 0) {\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\r\n            if (resultOffset === -1) {\r\n                this.blockLength = 0;\r\n                this.error = sidBlock.error;\r\n                return resultOffset;\r\n            }\r\n            this.blockLength += sidBlock.blockLength;\r\n            inputLength -= sidBlock.blockLength;\r\n            this.value.push(sidBlock);\r\n        }\r\n        return resultOffset;\r\n    }\r\n    toBER(sizeOnly, writer) {\r\n        const retBuffers = [];\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            const valueBuf = this.value[i].toBER(sizeOnly);\r\n            if (valueBuf.byteLength === 0) {\r\n                this.error = this.value[i].error;\r\n                return EMPTY_BUFFER;\r\n            }\r\n            retBuffers.push(valueBuf);\r\n        }\r\n        return concat(retBuffers);\r\n    }\r\n    fromString(string) {\r\n        this.value = [];\r\n        let pos1 = 0;\r\n        let pos2 = 0;\r\n        let sid = \"\";\r\n        do {\r\n            pos2 = string.indexOf(\".\", pos1);\r\n            if (pos2 === -1)\r\n                sid = string.substring(pos1);\r\n            else\r\n                sid = string.substring(pos1, pos2);\r\n            pos1 = pos2 + 1;\r\n            const sidBlock = new LocalRelativeSidValueBlock();\r\n            sidBlock.valueDec = parseInt(sid, 10);\r\n            if (isNaN(sidBlock.valueDec))\r\n                return true;\r\n            this.value.push(sidBlock);\r\n        } while (pos2 !== -1);\r\n        return true;\r\n    }\r\n    toString() {\r\n        let result = \"\";\r\n        let isHexOnly = false;\r\n        for (let i = 0; i < this.value.length; i++) {\r\n            isHexOnly = this.value[i].isHexOnly;\r\n            let sidStr = this.value[i].toString();\r\n            if (i !== 0)\r\n                result = `${result}.`;\r\n            if (isHexOnly) {\r\n                sidStr = `{${sidStr}}`;\r\n                result += sidStr;\r\n            }\r\n            else\r\n                result += sidStr;\r\n        }\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const object = {\r\n            ...super.toJSON(),\r\n            value: this.toString(),\r\n            sidArray: [],\r\n        };\r\n        for (let i = 0; i < this.value.length; i++)\r\n            object.sidArray.push(this.value[i].toJSON());\r\n        return object;\r\n    }\r\n}\r\nLocalRelativeObjectIdentifierValueBlock.NAME = \"RelativeObjectIdentifierValueBlock\";\n\nvar _a$l;\r\nclass RelativeObjectIdentifier extends BaseBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters, LocalRelativeObjectIdentifierValueBlock);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 13;\r\n    }\r\n    getValue() {\r\n        return this.valueBlock.toString();\r\n    }\r\n    setValue(value) {\r\n        this.valueBlock.fromString(value);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.valueBlock.toString() || \"empty\"}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.getValue(),\r\n        };\r\n    }\r\n}\r\n_a$l = RelativeObjectIdentifier;\r\n(() => {\r\n    typeStore.RelativeObjectIdentifier = _a$l;\r\n})();\r\nRelativeObjectIdentifier.NAME = \"RelativeObjectIdentifier\";\n\nvar _a$k;\r\nclass Sequence extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 16;\r\n    }\r\n}\r\n_a$k = Sequence;\r\n(() => {\r\n    typeStore.Sequence = _a$k;\r\n})();\r\nSequence.NAME = \"SEQUENCE\";\n\nvar _a$j;\r\nclass Set extends Constructed {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 17;\r\n    }\r\n}\r\n_a$j = Set;\r\n(() => {\r\n    typeStore.Set = _a$j;\r\n})();\r\nSet.NAME = \"SET\";\n\nclass LocalStringValueBlock extends HexBlock(ValueBlock) {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.isHexOnly = true;\r\n        this.value = EMPTY_STRING;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            value: this.value,\r\n        };\r\n    }\r\n}\r\nLocalStringValueBlock.NAME = \"StringValueBlock\";\n\nclass LocalSimpleStringValueBlock extends LocalStringValueBlock {\r\n}\r\nLocalSimpleStringValueBlock.NAME = \"SimpleStringValueBlock\";\n\nclass LocalSimpleStringBlock extends BaseStringBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters, LocalSimpleStringValueBlock);\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLen = inputString.length;\r\n        const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\r\n        for (let i = 0; i < strLen; i++)\r\n            view[i] = inputString.charCodeAt(i);\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalSimpleStringBlock.NAME = \"SIMPLE STRING\";\n\nclass LocalUtf8StringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n        try {\r\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf8String(inputBuffer);\r\n        }\r\n        catch (ex) {\r\n            this.warnings.push(`Error during \"decodeURIComponent\": ${ex}, using raw string`);\r\n            this.valueBlock.value = pvtsutils__namespace.Convert.ToBinary(inputBuffer);\r\n        }\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf8String(inputString));\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUtf8StringValueBlock.NAME = \"Utf8StringValueBlock\";\n\nvar _a$i;\r\nclass Utf8String extends LocalUtf8StringValueBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 12;\r\n    }\r\n}\r\n_a$i = Utf8String;\r\n(() => {\r\n    typeStore.Utf8String = _a$i;\r\n})();\r\nUtf8String.NAME = \"UTF8String\";\n\nclass LocalBmpStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        this.valueBlock.value = pvtsutils__namespace.Convert.ToUtf16String(inputBuffer);\r\n        this.valueBlock.valueHexView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer);\r\n    }\r\n    fromString(inputString) {\r\n        this.valueBlock.value = inputString;\r\n        this.valueBlock.valueHexView = new Uint8Array(pvtsutils__namespace.Convert.FromUtf16String(inputString));\r\n    }\r\n}\r\nLocalBmpStringValueBlock.NAME = \"BmpStringValueBlock\";\n\nvar _a$h;\r\nclass BmpString extends LocalBmpStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 30;\r\n    }\r\n}\r\n_a$h = BmpString;\r\n(() => {\r\n    typeStore.BmpString = _a$h;\r\n})();\r\nBmpString.NAME = \"BMPString\";\n\nclass LocalUniversalStringValueBlock extends LocalSimpleStringBlock {\r\n    fromBuffer(inputBuffer) {\r\n        const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\r\n        const valueView = new Uint8Array(copyBuffer);\r\n        for (let i = 0; i < valueView.length; i += 4) {\r\n            valueView[i] = valueView[i + 3];\r\n            valueView[i + 1] = valueView[i + 2];\r\n            valueView[i + 2] = 0x00;\r\n            valueView[i + 3] = 0x00;\r\n        }\r\n        this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\r\n    }\r\n    fromString(inputString) {\r\n        const strLength = inputString.length;\r\n        const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\r\n        for (let i = 0; i < strLength; i++) {\r\n            const codeBuf = pvutils__namespace.utilToBase(inputString.charCodeAt(i), 8);\r\n            const codeView = new Uint8Array(codeBuf);\r\n            if (codeView.length > 4)\r\n                continue;\r\n            const dif = 4 - codeView.length;\r\n            for (let j = (codeView.length - 1); j >= 0; j--)\r\n                valueHexView[i * 4 + j + dif] = codeView[j];\r\n        }\r\n        this.valueBlock.value = inputString;\r\n    }\r\n}\r\nLocalUniversalStringValueBlock.NAME = \"UniversalStringValueBlock\";\n\nvar _a$g;\r\nclass UniversalString extends LocalUniversalStringValueBlock {\r\n    constructor({ ...parameters } = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 28;\r\n    }\r\n}\r\n_a$g = UniversalString;\r\n(() => {\r\n    typeStore.UniversalString = _a$g;\r\n})();\r\nUniversalString.NAME = \"UniversalString\";\n\nvar _a$f;\r\nclass NumericString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 18;\r\n    }\r\n}\r\n_a$f = NumericString;\r\n(() => {\r\n    typeStore.NumericString = _a$f;\r\n})();\r\nNumericString.NAME = \"NumericString\";\n\nvar _a$e;\r\nclass PrintableString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 19;\r\n    }\r\n}\r\n_a$e = PrintableString;\r\n(() => {\r\n    typeStore.PrintableString = _a$e;\r\n})();\r\nPrintableString.NAME = \"PrintableString\";\n\nvar _a$d;\r\nclass TeletexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 20;\r\n    }\r\n}\r\n_a$d = TeletexString;\r\n(() => {\r\n    typeStore.TeletexString = _a$d;\r\n})();\r\nTeletexString.NAME = \"TeletexString\";\n\nvar _a$c;\r\nclass VideotexString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 21;\r\n    }\r\n}\r\n_a$c = VideotexString;\r\n(() => {\r\n    typeStore.VideotexString = _a$c;\r\n})();\r\nVideotexString.NAME = \"VideotexString\";\n\nvar _a$b;\r\nclass IA5String extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 22;\r\n    }\r\n}\r\n_a$b = IA5String;\r\n(() => {\r\n    typeStore.IA5String = _a$b;\r\n})();\r\nIA5String.NAME = \"IA5String\";\n\nvar _a$a;\r\nclass GraphicString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 25;\r\n    }\r\n}\r\n_a$a = GraphicString;\r\n(() => {\r\n    typeStore.GraphicString = _a$a;\r\n})();\r\nGraphicString.NAME = \"GraphicString\";\n\nvar _a$9;\r\nclass VisibleString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 26;\r\n    }\r\n}\r\n_a$9 = VisibleString;\r\n(() => {\r\n    typeStore.VisibleString = _a$9;\r\n})();\r\nVisibleString.NAME = \"VisibleString\";\n\nvar _a$8;\r\nclass GeneralString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 27;\r\n    }\r\n}\r\n_a$8 = GeneralString;\r\n(() => {\r\n    typeStore.GeneralString = _a$8;\r\n})();\r\nGeneralString.NAME = \"GeneralString\";\n\nvar _a$7;\r\nclass CharacterString extends LocalSimpleStringBlock {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 29;\r\n    }\r\n}\r\n_a$7 = CharacterString;\r\n(() => {\r\n    typeStore.CharacterString = _a$7;\r\n})();\r\nCharacterString.NAME = \"CharacterString\";\n\nvar _a$6;\r\nclass UTCTime extends VisibleString {\r\n    constructor({ value, valueDate, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.year = 0;\r\n        this.month = 0;\r\n        this.day = 0;\r\n        this.hour = 0;\r\n        this.minute = 0;\r\n        this.second = 0;\r\n        if (value) {\r\n            this.fromString(value);\r\n            this.valueBlock.valueHexView = new Uint8Array(value.length);\r\n            for (let i = 0; i < value.length; i++)\r\n                this.valueBlock.valueHexView[i] = value.charCodeAt(i);\r\n        }\r\n        if (valueDate) {\r\n            this.fromDate(valueDate);\r\n            this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\r\n        }\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 23;\r\n    }\r\n    fromBuffer(inputBuffer) {\r\n        this.fromString(String.fromCharCode.apply(null, pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer)));\r\n    }\r\n    toBuffer() {\r\n        const str = this.toString();\r\n        const buffer = new ArrayBuffer(str.length);\r\n        const view = new Uint8Array(buffer);\r\n        for (let i = 0; i < str.length; i++)\r\n            view[i] = str.charCodeAt(i);\r\n        return buffer;\r\n    }\r\n    fromDate(inputDate) {\r\n        this.year = inputDate.getUTCFullYear();\r\n        this.month = inputDate.getUTCMonth() + 1;\r\n        this.day = inputDate.getUTCDate();\r\n        this.hour = inputDate.getUTCHours();\r\n        this.minute = inputDate.getUTCMinutes();\r\n        this.second = inputDate.getUTCSeconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second)));\r\n    }\r\n    fromString(inputString) {\r\n        const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\r\n        const parserArray = parser.exec(inputString);\r\n        if (parserArray === null) {\r\n            this.error = \"Wrong input string for conversion\";\r\n            return;\r\n        }\r\n        const year = parseInt(parserArray[1], 10);\r\n        if (year >= 50)\r\n            this.year = 1900 + year;\r\n        else\r\n            this.year = 2000 + year;\r\n        this.month = parseInt(parserArray[2], 10);\r\n        this.day = parseInt(parserArray[3], 10);\r\n        this.hour = parseInt(parserArray[4], 10);\r\n        this.minute = parseInt(parserArray[5], 10);\r\n        this.second = parseInt(parserArray[6], 10);\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = new Array(7);\r\n            outputArray[0] = pvutils__namespace.padNumber(((this.year < 2000) ? (this.year - 1900) : (this.year - 2000)), 2);\r\n            outputArray[1] = pvutils__namespace.padNumber(this.month, 2);\r\n            outputArray[2] = pvutils__namespace.padNumber(this.day, 2);\r\n            outputArray[3] = pvutils__namespace.padNumber(this.hour, 2);\r\n            outputArray[4] = pvutils__namespace.padNumber(this.minute, 2);\r\n            outputArray[5] = pvutils__namespace.padNumber(this.second, 2);\r\n            outputArray[6] = \"Z\";\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    onAsciiEncoding() {\r\n        return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            year: this.year,\r\n            month: this.month,\r\n            day: this.day,\r\n            hour: this.hour,\r\n            minute: this.minute,\r\n            second: this.second,\r\n        };\r\n    }\r\n}\r\n_a$6 = UTCTime;\r\n(() => {\r\n    typeStore.UTCTime = _a$6;\r\n})();\r\nUTCTime.NAME = \"UTCTime\";\n\nvar _a$5;\r\nclass GeneralizedTime extends UTCTime {\r\n    constructor(parameters = {}) {\r\n        var _b;\r\n        super(parameters);\r\n        (_b = this.millisecond) !== null && _b !== void 0 ? _b : (this.millisecond = 0);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 24;\r\n    }\r\n    fromDate(inputDate) {\r\n        super.fromDate(inputDate);\r\n        this.millisecond = inputDate.getUTCMilliseconds();\r\n    }\r\n    toDate() {\r\n        return (new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)));\r\n    }\r\n    fromString(inputString) {\r\n        let isUTC = false;\r\n        let timeString = \"\";\r\n        let dateTimeString = \"\";\r\n        let fractionPart = 0;\r\n        let parser;\r\n        let hourDifference = 0;\r\n        let minuteDifference = 0;\r\n        if (inputString[inputString.length - 1] === \"Z\") {\r\n            timeString = inputString.substring(0, inputString.length - 1);\r\n            isUTC = true;\r\n        }\r\n        else {\r\n            const number = new Number(inputString[inputString.length - 1]);\r\n            if (isNaN(number.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            timeString = inputString;\r\n        }\r\n        if (isUTC) {\r\n            if (timeString.indexOf(\"+\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            if (timeString.indexOf(\"-\") !== -1)\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        else {\r\n            let multiplier = 1;\r\n            let differencePosition = timeString.indexOf(\"+\");\r\n            let differenceString = \"\";\r\n            if (differencePosition === -1) {\r\n                differencePosition = timeString.indexOf(\"-\");\r\n                multiplier = -1;\r\n            }\r\n            if (differencePosition !== -1) {\r\n                differenceString = timeString.substring(differencePosition + 1);\r\n                timeString = timeString.substring(0, differencePosition);\r\n                if ((differenceString.length !== 2) && (differenceString.length !== 4))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                let number = parseInt(differenceString.substring(0, 2), 10);\r\n                if (isNaN(number.valueOf()))\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                hourDifference = multiplier * number;\r\n                if (differenceString.length === 4) {\r\n                    number = parseInt(differenceString.substring(2, 4), 10);\r\n                    if (isNaN(number.valueOf()))\r\n                        throw new Error(\"Wrong input string for conversion\");\r\n                    minuteDifference = multiplier * number;\r\n                }\r\n            }\r\n        }\r\n        let fractionPointPosition = timeString.indexOf(\".\");\r\n        if (fractionPointPosition === -1)\r\n            fractionPointPosition = timeString.indexOf(\",\");\r\n        if (fractionPointPosition !== -1) {\r\n            const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\r\n            if (isNaN(fractionPartCheck.valueOf()))\r\n                throw new Error(\"Wrong input string for conversion\");\r\n            fractionPart = fractionPartCheck.valueOf();\r\n            dateTimeString = timeString.substring(0, fractionPointPosition);\r\n        }\r\n        else\r\n            dateTimeString = timeString;\r\n        switch (true) {\r\n            case (dateTimeString.length === 8):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1)\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n                break;\r\n            case (dateTimeString.length === 10):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.minute = Math.floor(fractionResult);\r\n                    fractionResult = 60 * (fractionResult - this.minute);\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 12):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    let fractionResult = 60 * fractionPart;\r\n                    this.second = Math.floor(fractionResult);\r\n                    fractionResult = 1000 * (fractionResult - this.second);\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            case (dateTimeString.length === 14):\r\n                parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\r\n                if (fractionPointPosition !== -1) {\r\n                    const fractionResult = 1000 * fractionPart;\r\n                    this.millisecond = Math.floor(fractionResult);\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Wrong input string for conversion\");\r\n        }\r\n        const parserArray = parser.exec(dateTimeString);\r\n        if (parserArray === null)\r\n            throw new Error(\"Wrong input string for conversion\");\r\n        for (let j = 1; j < parserArray.length; j++) {\r\n            switch (j) {\r\n                case 1:\r\n                    this.year = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 2:\r\n                    this.month = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 3:\r\n                    this.day = parseInt(parserArray[j], 10);\r\n                    break;\r\n                case 4:\r\n                    this.hour = parseInt(parserArray[j], 10) + hourDifference;\r\n                    break;\r\n                case 5:\r\n                    this.minute = parseInt(parserArray[j], 10) + minuteDifference;\r\n                    break;\r\n                case 6:\r\n                    this.second = parseInt(parserArray[j], 10);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Wrong input string for conversion\");\r\n            }\r\n        }\r\n        if (isUTC === false) {\r\n            const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\r\n            this.year = tempDate.getUTCFullYear();\r\n            this.month = tempDate.getUTCMonth();\r\n            this.day = tempDate.getUTCDay();\r\n            this.hour = tempDate.getUTCHours();\r\n            this.minute = tempDate.getUTCMinutes();\r\n            this.second = tempDate.getUTCSeconds();\r\n            this.millisecond = tempDate.getUTCMilliseconds();\r\n        }\r\n    }\r\n    toString(encoding = \"iso\") {\r\n        if (encoding === \"iso\") {\r\n            const outputArray = [];\r\n            outputArray.push(pvutils__namespace.padNumber(this.year, 4));\r\n            outputArray.push(pvutils__namespace.padNumber(this.month, 2));\r\n            outputArray.push(pvutils__namespace.padNumber(this.day, 2));\r\n            outputArray.push(pvutils__namespace.padNumber(this.hour, 2));\r\n            outputArray.push(pvutils__namespace.padNumber(this.minute, 2));\r\n            outputArray.push(pvutils__namespace.padNumber(this.second, 2));\r\n            if (this.millisecond !== 0) {\r\n                outputArray.push(\".\");\r\n                outputArray.push(pvutils__namespace.padNumber(this.millisecond, 3));\r\n            }\r\n            outputArray.push(\"Z\");\r\n            return outputArray.join(\"\");\r\n        }\r\n        return super.toString(encoding);\r\n    }\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            millisecond: this.millisecond,\r\n        };\r\n    }\r\n}\r\n_a$5 = GeneralizedTime;\r\n(() => {\r\n    typeStore.GeneralizedTime = _a$5;\r\n})();\r\nGeneralizedTime.NAME = \"GeneralizedTime\";\n\nvar _a$4;\r\nclass DATE extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 31;\r\n    }\r\n}\r\n_a$4 = DATE;\r\n(() => {\r\n    typeStore.DATE = _a$4;\r\n})();\r\nDATE.NAME = \"DATE\";\n\nvar _a$3;\r\nclass TimeOfDay extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 32;\r\n    }\r\n}\r\n_a$3 = TimeOfDay;\r\n(() => {\r\n    typeStore.TimeOfDay = _a$3;\r\n})();\r\nTimeOfDay.NAME = \"TimeOfDay\";\n\nvar _a$2;\r\nclass DateTime extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 33;\r\n    }\r\n}\r\n_a$2 = DateTime;\r\n(() => {\r\n    typeStore.DateTime = _a$2;\r\n})();\r\nDateTime.NAME = \"DateTime\";\n\nvar _a$1;\r\nclass Duration extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 34;\r\n    }\r\n}\r\n_a$1 = Duration;\r\n(() => {\r\n    typeStore.Duration = _a$1;\r\n})();\r\nDuration.NAME = \"Duration\";\n\nvar _a;\r\nclass TIME extends Utf8String {\r\n    constructor(parameters = {}) {\r\n        super(parameters);\r\n        this.idBlock.tagClass = 1;\r\n        this.idBlock.tagNumber = 14;\r\n    }\r\n}\r\n_a = TIME;\r\n(() => {\r\n    typeStore.TIME = _a;\r\n})();\r\nTIME.NAME = \"TIME\";\n\nclass Any {\r\n    constructor({ name = EMPTY_STRING, optional = false, } = {}) {\r\n        this.name = name;\r\n        this.optional = optional;\r\n    }\r\n}\n\nclass Choice extends Any {\r\n    constructor({ value = [], ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n    }\r\n}\n\nclass Repeated extends Any {\r\n    constructor({ value = new Any(), local = false, ...parameters } = {}) {\r\n        super(parameters);\r\n        this.value = value;\r\n        this.local = local;\r\n    }\r\n}\n\nclass RawData {\r\n    constructor({ data = EMPTY_VIEW } = {}) {\r\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(data);\r\n    }\r\n    get data() {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n    set data(value) {\r\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(value);\r\n    }\r\n    fromBER(inputBuffer, inputOffset, inputLength) {\r\n        const endLength = inputOffset + inputLength;\r\n        this.dataView = pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\r\n        return endLength;\r\n    }\r\n    toBER(sizeOnly) {\r\n        return this.dataView.slice().buffer;\r\n    }\r\n}\n\nfunction compareSchema(root, inputData, inputSchema) {\r\n    if (inputSchema instanceof Choice) {\r\n        for (let j = 0; j < inputSchema.value.length; j++) {\r\n            const result = compareSchema(root, inputData, inputSchema.value[j]);\r\n            if (result.verified) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n        {\r\n            const _result = {\r\n                verified: false,\r\n                result: {\r\n                    error: \"Wrong values for Choice type\"\r\n                },\r\n            };\r\n            if (inputSchema.hasOwnProperty(NAME))\r\n                _result.name = inputSchema.name;\r\n            return _result;\r\n        }\r\n    }\r\n    if (inputSchema instanceof Any) {\r\n        if (inputSchema.hasOwnProperty(NAME))\r\n            root[inputSchema.name] = inputData;\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if ((root instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong root object\" }\r\n        };\r\n    }\r\n    if ((inputData instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 data\" }\r\n        };\r\n    }\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((ID_BLOCK in inputSchema) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((FROM_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if ((TO_BER in inputSchema.idBlock) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    const encodedId = inputSchema.idBlock.toBER(false);\r\n    if (encodedId.byteLength === 0) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error encoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\r\n    if (decodedOffset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Error decoding idBlock for ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema\" }\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\r\n        return {\r\n            verified: false,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.idBlock.isHexOnly) {\r\n        if ((VALUE_HEX_VIEW in inputSchema.idBlock) === false) {\r\n            return {\r\n                verified: false,\r\n                result: { error: \"Wrong ASN.1 schema\" }\r\n            };\r\n        }\r\n        const schemaView = inputSchema.idBlock.valueHexView;\r\n        const asn1View = inputData.idBlock.valueHexView;\r\n        if (schemaView.length !== asn1View.length) {\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < schemaView.length; i++) {\r\n            if (schemaView[i] !== asn1View[1]) {\r\n                return {\r\n                    verified: false,\r\n                    result: root\r\n                };\r\n            }\r\n        }\r\n    }\r\n    if (inputSchema.name) {\r\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n        if (inputSchema.name)\r\n            root[inputSchema.name] = inputData;\r\n    }\r\n    if (inputSchema instanceof typeStore.Constructed) {\r\n        let admission = 0;\r\n        let result = {\r\n            verified: false,\r\n            result: {\r\n                error: \"Unknown error\",\r\n            }\r\n        };\r\n        let maxLength = inputSchema.valueBlock.value.length;\r\n        if (maxLength > 0) {\r\n            if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                maxLength = inputData.valueBlock.value.length;\r\n            }\r\n        }\r\n        if (maxLength === 0) {\r\n            return {\r\n                verified: true,\r\n                result: root\r\n            };\r\n        }\r\n        if ((inputData.valueBlock.value.length === 0) &&\r\n            (inputSchema.valueBlock.value.length !== 0)) {\r\n            let _optional = true;\r\n            for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\r\n                _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\r\n            if (_optional) {\r\n                return {\r\n                    verified: true,\r\n                    result: root\r\n                };\r\n            }\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name)\r\n                    delete root[inputSchema.name];\r\n            }\r\n            root.error = \"Inconsistent object length\";\r\n            return {\r\n                verified: false,\r\n                result: root\r\n            };\r\n        }\r\n        for (let i = 0; i < maxLength; i++) {\r\n            if ((i - admission) >= inputData.valueBlock.value.length) {\r\n                if (inputSchema.valueBlock.value[i].optional === false) {\r\n                    const _result = {\r\n                        verified: false,\r\n                        result: root\r\n                    };\r\n                    root.error = \"Inconsistent length between ASN.1 data and schema\";\r\n                    if (inputSchema.name) {\r\n                        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                        if (inputSchema.name) {\r\n                            delete root[inputSchema.name];\r\n                            _result.name = inputSchema.name;\r\n                        }\r\n                    }\r\n                    return _result;\r\n                }\r\n            }\r\n            else {\r\n                if (inputSchema.valueBlock.value[0] instanceof Repeated) {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[0].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    if ((NAME in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].name.length > 0)) {\r\n                        let arrayRoot = {};\r\n                        if ((LOCAL in inputSchema.valueBlock.value[0]) && (inputSchema.valueBlock.value[0].local))\r\n                            arrayRoot = inputData;\r\n                        else\r\n                            arrayRoot = root;\r\n                        if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === \"undefined\")\r\n                            arrayRoot[inputSchema.valueBlock.value[0].name] = [];\r\n                        arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\r\n                    if (result.verified === false) {\r\n                        if (inputSchema.valueBlock.value[i].optional)\r\n                            admission++;\r\n                        else {\r\n                            if (inputSchema.name) {\r\n                                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                                if (inputSchema.name)\r\n                                    delete root[inputSchema.name];\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (result.verified === false) {\r\n            const _result = {\r\n                verified: false,\r\n                result: root\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return {\r\n            verified: true,\r\n            result: root\r\n        };\r\n    }\r\n    if (inputSchema.primitiveSchema &&\r\n        (VALUE_HEX_VIEW in inputData.valueBlock)) {\r\n        const asn1 = localFromBER(inputData.valueBlock.valueHexView);\r\n        if (asn1.offset === -1) {\r\n            const _result = {\r\n                verified: false,\r\n                result: asn1.result\r\n            };\r\n            if (inputSchema.name) {\r\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\r\n                if (inputSchema.name) {\r\n                    delete root[inputSchema.name];\r\n                    _result.name = inputSchema.name;\r\n                }\r\n            }\r\n            return _result;\r\n        }\r\n        return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\r\n    }\r\n    return {\r\n        verified: true,\r\n        result: root\r\n    };\r\n}\r\nfunction verifySchema(inputBuffer, inputSchema) {\r\n    if ((inputSchema instanceof Object) === false) {\r\n        return {\r\n            verified: false,\r\n            result: { error: \"Wrong ASN.1 schema type\" }\r\n        };\r\n    }\r\n    const asn1 = localFromBER(pvtsutils__namespace.BufferSourceConverter.toUint8Array(inputBuffer));\r\n    if (asn1.offset === -1) {\r\n        return {\r\n            verified: false,\r\n            result: asn1.result\r\n        };\r\n    }\r\n    return compareSchema(asn1.result, asn1.result, inputSchema);\r\n}\n\nexports.Any = Any;\nexports.BaseBlock = BaseBlock;\nexports.BaseStringBlock = BaseStringBlock;\nexports.BitString = BitString;\nexports.BmpString = BmpString;\nexports.Boolean = Boolean;\nexports.CharacterString = CharacterString;\nexports.Choice = Choice;\nexports.Constructed = Constructed;\nexports.DATE = DATE;\nexports.DateTime = DateTime;\nexports.Duration = Duration;\nexports.EndOfContent = EndOfContent;\nexports.Enumerated = Enumerated;\nexports.GeneralString = GeneralString;\nexports.GeneralizedTime = GeneralizedTime;\nexports.GraphicString = GraphicString;\nexports.HexBlock = HexBlock;\nexports.IA5String = IA5String;\nexports.Integer = Integer;\nexports.Null = Null;\nexports.NumericString = NumericString;\nexports.ObjectIdentifier = ObjectIdentifier;\nexports.OctetString = OctetString;\nexports.Primitive = Primitive;\nexports.PrintableString = PrintableString;\nexports.RawData = RawData;\nexports.RelativeObjectIdentifier = RelativeObjectIdentifier;\nexports.Repeated = Repeated;\nexports.Sequence = Sequence;\nexports.Set = Set;\nexports.TIME = TIME;\nexports.TeletexString = TeletexString;\nexports.TimeOfDay = TimeOfDay;\nexports.UTCTime = UTCTime;\nexports.UniversalString = UniversalString;\nexports.Utf8String = Utf8String;\nexports.ValueBlock = ValueBlock;\nexports.VideotexString = VideotexString;\nexports.ViewWriter = ViewWriter;\nexports.VisibleString = VisibleString;\nexports.compareSchema = compareSchema;\nexports.fromBER = fromBER;\nexports.verifySchema = verifySchema;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXNuMWpzL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVc7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDREQUFTOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHdGQUF3RixJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixZQUFZLElBQUksSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsYUFBYSxJQUFJLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLHdFQUF3RSxJQUFJO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLElBQUksMEVBQTBFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQ0FBc0MsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLEtBQUssc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQ0FBa0MsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixZQUFZLGVBQWUsa0JBQWtCLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCLElBQUksaUVBQWlFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxrQkFBa0IsdURBQXVELElBQUk7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQixJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlDQUF5QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YsZ0NBQWdDO0FBQ2hDLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsV0FBVztBQUNYLFlBQVk7QUFDWixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZix1QkFBdUI7QUFDdkIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9hc24xanMvYnVpbGQvaW5kZXguanM/MTA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgR01PIEdsb2JhbFNpZ25cbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDIyLCBQZWN1bGlhciBWZW50dXJlc1xuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogQXV0aG9yIDIwMTQtMjAxOSwgWXVyeSBTdHJvemhldnNreVxuICogXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuICogYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogXG4gKiAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIFxuICogKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAqICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yXG4gKiAgIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiBcbiAqICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbVxuICogICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICogXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuICogQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gKiAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gKiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbiAqIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICogU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBwdnV0aWxzID0gcmVxdWlyZSgncHZ1dGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XG4gIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuW1wiZGVmYXVsdFwiXSA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgcHZ0c3V0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UocHZ0c3V0aWxzKTtcbnZhciBwdnV0aWxzX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UocHZ1dGlscyk7XG5cbmZ1bmN0aW9uIGFzc2VydEJpZ0ludCgpIHtcclxuICAgIGlmICh0eXBlb2YgQmlnSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IGlzIG5vdCBkZWZpbmVkLiBZb3VyIGVudmlyb25tZW50IGRvZXNuJ3QgaW1wbGVtZW50IEJpZ0ludC5cIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29uY2F0KGJ1ZmZlcnMpIHtcclxuICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xyXG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1tpXTtcclxuICAgICAgICBvdXRwdXRMZW5ndGggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0TGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XHJcbiAgICAgICAgcmV0Vmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcHJldkxlbmd0aCk7XHJcbiAgICAgICAgcHJldkxlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxufVxyXG5mdW5jdGlvbiBjaGVja0J1ZmZlclBhcmFtcyhiYXNlQmxvY2ssIGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgIGlmICghKGlucHV0QnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRCdWZmZXIgbXVzdCBiZSAnVWludDhBcnJheSdcIjtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRCdWZmZXIgaGFzIHplcm8gbGVuZ3RoXCI7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIGJhc2VCbG9jay5lcnJvciA9IFwiV3JvbmcgcGFyYW1ldGVyOiBpbnB1dE9mZnNldCBsZXNzIHRoYW4gemVyb1wiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dExlbmd0aCA8IDApIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIldyb25nIHBhcmFtZXRlcjogaW5wdXRMZW5ndGggbGVzcyB0aGFuIHplcm9cIjtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoKGlucHV0QnVmZmVyLmJ5dGVMZW5ndGggLSBpbnB1dE9mZnNldCAtIGlucHV0TGVuZ3RoKSA8IDApIHtcclxuICAgICAgICBiYXNlQmxvY2suZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkIChpbmNvbnNpc3RlbnQgb2Zmc2V0IGFuZCBsZW5ndGggdmFsdWVzKVwiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbmNsYXNzIFZpZXdXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgd3JpdGUoYnVmKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGJ1Zik7XHJcbiAgICB9XHJcbiAgICBmaW5hbCgpIHtcclxuICAgICAgICByZXR1cm4gY29uY2F0KHRoaXMuaXRlbXMpO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IHBvd2VyczIgPSBbbmV3IFVpbnQ4QXJyYXkoWzFdKV07XHJcbmNvbnN0IGRpZ2l0c1N0cmluZyA9IFwiMDEyMzQ1Njc4OVwiO1xyXG5jb25zdCBOQU1FID0gXCJuYW1lXCI7XHJcbmNvbnN0IFZBTFVFX0hFWF9WSUVXID0gXCJ2YWx1ZUhleFZpZXdcIjtcclxuY29uc3QgSVNfSEVYX09OTFkgPSBcImlzSGV4T25seVwiO1xyXG5jb25zdCBJRF9CTE9DSyA9IFwiaWRCbG9ja1wiO1xyXG5jb25zdCBUQUdfQ0xBU1MgPSBcInRhZ0NsYXNzXCI7XHJcbmNvbnN0IFRBR19OVU1CRVIgPSBcInRhZ051bWJlclwiO1xyXG5jb25zdCBJU19DT05TVFJVQ1RFRCA9IFwiaXNDb25zdHJ1Y3RlZFwiO1xyXG5jb25zdCBGUk9NX0JFUiA9IFwiZnJvbUJFUlwiO1xyXG5jb25zdCBUT19CRVIgPSBcInRvQkVSXCI7XHJcbmNvbnN0IExPQ0FMID0gXCJsb2NhbFwiO1xyXG5jb25zdCBFTVBUWV9TVFJJTkcgPSBcIlwiO1xyXG5jb25zdCBFTVBUWV9CVUZGRVIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcbmNvbnN0IEVNUFRZX1ZJRVcgPSBuZXcgVWludDhBcnJheSgwKTtcclxuY29uc3QgRU5EX09GX0NPTlRFTlRfTkFNRSA9IFwiRW5kT2ZDb250ZW50XCI7XHJcbmNvbnN0IE9DVEVUX1NUUklOR19OQU1FID0gXCJPQ1RFVCBTVFJJTkdcIjtcclxuY29uc3QgQklUX1NUUklOR19OQU1FID0gXCJCSVQgU1RSSU5HXCI7XG5cbmZ1bmN0aW9uIEhleEJsb2NrKEJhc2VDbGFzcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmV0dXJuIF9hID0gY2xhc3MgU29tZSBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gYXJnc1swXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gKF9hID0gcGFyYW1zLmlzSGV4T25seSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHBhcmFtcy52YWx1ZUhleCA/IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLnZhbHVlSGV4KSA6IEVNUFRZX1ZJRVc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2V0IHZhbHVlSGV4KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldCB2YWx1ZUhleCh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gaW5wdXRCdWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG5ldyBVaW50OEFycmF5KGlucHV0QnVmZmVyKSA6IGlucHV0QnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCB2aWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGVuZ3RoID0gaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgZW5kTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiWmVybyBidWZmZXIgbGVuZ3RoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBpbnB1dExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbmRMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdG9CRVIoc2l6ZU9ubHkgPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkZsYWcgJ2lzSGV4T25seScgaXMgbm90IHNldCwgYWJvcnRcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcih0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCA9PT0gdGhpcy52YWx1ZUhleFZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnZhbHVlSGV4Vmlldy5idWZmZXJcclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaXNIZXhPbmx5OiB0aGlzLmlzSGV4T25seSxcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhleDogcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4VmlldyksXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfYS5OQU1FID0gXCJoZXhCbG9ja1wiLFxyXG4gICAgICAgIF9hO1xyXG59XG5cbmNsYXNzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgYmxvY2tMZW5ndGggPSAwLCBlcnJvciA9IEVNUFRZX1NUUklORywgd2FybmluZ3MgPSBbXSwgdmFsdWVCZWZvcmVEZWNvZGUgPSBFTVBUWV9WSUVXLCB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoID0gYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcclxuICAgICAgICB0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkodmFsdWVCZWZvcmVEZWNvZGUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGJsb2NrTmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5OQU1FO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlQmVmb3JlRGVjb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldy5zbGljZSgpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHNldCB2YWx1ZUJlZm9yZURlY29kZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGJsb2NrTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5OQU1FLFxyXG4gICAgICAgICAgICBibG9ja0xlbmd0aDogdGhpcy5ibG9ja0xlbmd0aCxcclxuICAgICAgICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsXHJcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzLFxyXG4gICAgICAgICAgICB2YWx1ZUJlZm9yZURlY29kZTogcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlQmVmb3JlRGVjb2RlVmlldyksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJhc2VCbG9jay5OQU1FID0gXCJiYXNlQmxvY2tcIjtcblxuY2xhc3MgVmFsdWVCbG9jayBleHRlbmRzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIlVzZXIgbmVlZCB0byBtYWtlIGEgc3BlY2lmaWMgZnVuY3Rpb24gaW4gYSBjbGFzcyB3aGljaCBleHRlbmRzICdWYWx1ZUJsb2NrJ1wiKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJVc2VyIG5lZWQgdG8gbWFrZSBhIHNwZWNpZmljIGZ1bmN0aW9uIGluIGEgY2xhc3Mgd2hpY2ggZXh0ZW5kcyAnVmFsdWVCbG9jaydcIik7XHJcbiAgICB9XHJcbn1cclxuVmFsdWVCbG9jay5OQU1FID0gXCJ2YWx1ZUJsb2NrXCI7XG5cbmNsYXNzIExvY2FsSWRlbnRpZmljYXRpb25CbG9jayBleHRlbmRzIEhleEJsb2NrKExvY2FsQmFzZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IGlkQmxvY2sgPSB7fSwgfSA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgaWYgKGlkQmxvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSAoX2EgPSBpZEJsb2NrLmlzSGV4T25seSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gaWRCbG9jay52YWx1ZUhleCA/IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaWRCbG9jay52YWx1ZUhleCkgOiBFTVBUWV9WSUVXO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ0NsYXNzID0gKF9iID0gaWRCbG9jay50YWdDbGFzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogLTE7XHJcbiAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gKF9jID0gaWRCbG9jay50YWdOdW1iZXIpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSAoX2QgPSBpZEJsb2NrLmlzQ29uc3RydWN0ZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ051bWJlciA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGZpcnN0T2N0ZXQgPSAwO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50YWdDbGFzcykge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4MDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgZmlyc3RPY3RldCB8PSAweDQwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGZpcnN0T2N0ZXQgfD0gMHg4MDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4QzA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVua25vd24gdGFnIGNsYXNzXCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxyXG4gICAgICAgICAgICBmaXJzdE9jdGV0IHw9IDB4MjA7XHJcbiAgICAgICAgaWYgKHRoaXMudGFnTnVtYmVyIDwgMzEgJiYgIXRoaXMuaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSgxKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlciA9IHRoaXMudGFnTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgbnVtYmVyICY9IDB4MUY7XHJcbiAgICAgICAgICAgICAgICBmaXJzdE9jdGV0IHw9IG51bWJlcjtcclxuICAgICAgICAgICAgICAgIHJldFZpZXdbMF0gPSBmaXJzdE9jdGV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGV4T25seSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkQnVmID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxUb0Jhc2UodGhpcy50YWdOdW1iZXIsIDcpO1xyXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRCdWYpO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSArIDEpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gKGZpcnN0T2N0ZXQgfCAweDFGKTtcclxuICAgICAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2l6ZSAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Vmlld1tpICsgMV0gPSBlbmNvZGVkVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W3NpemVdID0gZW5jb2RlZFZpZXdbc2l6ZSAtIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGggKyAxKTtcclxuICAgICAgICByZXRWaWV3WzBdID0gKGZpcnN0T2N0ZXQgfCAweDFGKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1clZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoY3VyVmlldy5sZW5ndGggLSAxKTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tpICsgMV0gPSBjdXJWaWV3W2ldIHwgMHg4MDtcclxuICAgICAgICAgICAgcmV0Vmlld1t0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoXSA9IGN1clZpZXdbY3VyVmlldy5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldFZpZXcuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dFZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChpbnRCdWZmZXIubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRhZ0NsYXNzTWFzayA9IGludEJ1ZmZlclswXSAmIDB4QzA7XHJcbiAgICAgICAgc3dpdGNoICh0YWdDbGFzc01hc2spIHtcclxuICAgICAgICAgICAgY2FzZSAweDAwOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICgxKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDB4NDA6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0NsYXNzID0gKDIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMHg4MDpcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnQ2xhc3MgPSAoMyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAweEMwOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdDbGFzcyA9ICg0KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVW5rbm93biB0YWcgY2xhc3NcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gKGludEJ1ZmZlclswXSAmIDB4MjApID09PSAweDIwO1xyXG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgdGFnTnVtYmVyTWFzayA9IGludEJ1ZmZlclswXSAmIDB4MUY7XHJcbiAgICAgICAgaWYgKHRhZ051bWJlck1hc2sgIT09IDB4MUYpIHtcclxuICAgICAgICAgICAgdGhpcy50YWdOdW1iZXIgPSAodGFnTnVtYmVyTWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMTtcclxuICAgICAgICAgICAgbGV0IGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMjU1KTtcclxuICAgICAgICAgICAgbGV0IHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCA9IDI1NTtcclxuICAgICAgICAgICAgd2hpbGUgKGludEJ1ZmZlcltjb3VudF0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSBpbnRCdWZmZXIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCArPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcEJ1ZmZlclZpZXcgPSBuZXcgVWludDhBcnJheSh0YWdOdW1iZXJCdWZmZXJNYXhMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW50VGFnTnVtYmVyQnVmZmVyLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wQnVmZmVyVmlld1tpXSA9IGludFRhZ051bWJlckJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXIgPSB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHRhZ051bWJlckJ1ZmZlck1heExlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IChjb3VudCArIDEpO1xyXG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXJbY291bnQgLSAxXSA9IGludEJ1ZmZlcltjb3VudF0gJiAweDdGO1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wQnVmZmVyVmlldyA9IG5ldyBVaW50OEFycmF5KGNvdW50KTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgdGVtcEJ1ZmZlclZpZXdbaV0gPSBpbnRUYWdOdW1iZXJCdWZmZXJbaV07XHJcbiAgICAgICAgICAgIGludFRhZ051bWJlckJ1ZmZlciA9IHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xyXG4gICAgICAgICAgICBpbnRUYWdOdW1iZXJCdWZmZXIuc2V0KHRlbXBCdWZmZXJWaWV3KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tMZW5ndGggPD0gOSlcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnTnVtYmVyID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZShpbnRUYWdOdW1iZXJCdWZmZXIsIDcpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlRhZyB0b28gbG9uZywgcmVwcmVzZW50ZWQgYXMgaGV4LWNvZGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoKHRoaXMudGFnQ2xhc3MgPT09IDEpKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5pc0NvbnN0cnVjdGVkKSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudGFnTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDk6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjM6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI0OlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgMzI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMzOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAzNDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJDb25zdHJ1Y3RlZCBlbmNvZGluZyB1c2VkIGZvciBwcmltaXRpdmUgdHlwZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHRhZ0NsYXNzOiB0aGlzLnRhZ0NsYXNzLFxyXG4gICAgICAgICAgICB0YWdOdW1iZXI6IHRoaXMudGFnTnVtYmVyLFxyXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiB0aGlzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbElkZW50aWZpY2F0aW9uQmxvY2suTkFNRSA9IFwiaWRlbnRpZmljYXRpb25CbG9ja1wiO1xuXG5jbGFzcyBMb2NhbExlbmd0aEJsb2NrIGV4dGVuZHMgTG9jYWxCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyBsZW5CbG9jayA9IHt9LCB9ID0ge30pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaXNJbmRlZmluaXRlRm9ybSA9IChfYSA9IGxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gKF9iID0gbGVuQmxvY2subG9uZ0Zvcm1Vc2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IChfYyA9IGxlbkJsb2NrLmxlbmd0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIHZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSB2aWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBpZiAoaW50QnVmZmVyLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yID0gXCJaZXJvIGJ1ZmZlciBsZW5ndGhcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50QnVmZmVyWzBdID09PSAweEZGKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkxlbmd0aCBibG9jayAweEZGIGlzIHJlc2VydmVkIGJ5IHN0YW5kYXJkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0luZGVmaW5pdGVGb3JtID0gaW50QnVmZmVyWzBdID09PSAweDgwO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDE7XHJcbiAgICAgICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyB0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb25nRm9ybVVzZWQgPSAhIShpbnRCdWZmZXJbMF0gJiAweDgwKTtcclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gKGludEJ1ZmZlclswXSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gaW50QnVmZmVyWzBdICYgMHg3RjtcclxuICAgICAgICBpZiAoY291bnQgPiA4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlRvbyBiaWcgaW50ZWdlclwiO1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoY291bnQgKyAxKSA+IGludEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5PZmZzZXQgPSBpbnB1dE9mZnNldCArIDE7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoQnVmZmVyVmlldyA9IHZpZXcuc3ViYXJyYXkobGVuT2Zmc2V0LCBsZW5PZmZzZXQgKyBjb3VudCk7XHJcbiAgICAgICAgaWYgKGxlbmd0aEJ1ZmZlclZpZXdbY291bnQgLSAxXSA9PT0gMHgwMClcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTmVlZGxlc3NseSBsb25nIGVuY29kZWQgbGVuZ3RoXCIpO1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZShsZW5ndGhCdWZmZXJWaWV3LCA4KTtcclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQgJiYgKHRoaXMubGVuZ3RoIDw9IDEyNykpXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlVubmVjZXNzYXJ5IHVzYWdlIG9mIGxvbmcgbGVuZ3RoIGZvcm1cIik7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGNvdW50ICsgMTtcclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHJldEJ1ZjtcclxuICAgICAgICBsZXQgcmV0VmlldztcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxMjcpXHJcbiAgICAgICAgICAgIHRoaXMubG9uZ0Zvcm1Vc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luZGVmaW5pdGVGb3JtKSB7XHJcbiAgICAgICAgICAgIHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigxKTtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHJldEJ1Zik7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3WzBdID0gMHg4MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5sb25nRm9ybVVzZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMubGVuZ3RoLCA4KTtcclxuICAgICAgICAgICAgaWYgKGVuY29kZWRCdWYuYnl0ZUxlbmd0aCA+IDEyNykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiVG9vIGJpZyBsZW5ndGhcIjtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoRU1QVFlfQlVGRkVSKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChzaXplT25seSlcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoIHwgMHg4MDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVkQnVmLmJ5dGVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHJldFZpZXdbaSArIDFdID0gZW5jb2RlZFZpZXdbaV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigxKTtcclxuICAgICAgICBpZiAoc2l6ZU9ubHkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICByZXRWaWV3WzBdID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXRCdWY7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIGlzSW5kZWZpbml0ZUZvcm06IHRoaXMuaXNJbmRlZmluaXRlRm9ybSxcclxuICAgICAgICAgICAgbG9uZ0Zvcm1Vc2VkOiB0aGlzLmxvbmdGb3JtVXNlZCxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmxlbmd0aCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsTGVuZ3RoQmxvY2suTkFNRSA9IFwibGVuZ3RoQmxvY2tcIjtcblxuY29uc3QgdHlwZVN0b3JlID0ge307XG5cbmNsYXNzIEJhc2VCbG9jayBleHRlbmRzIExvY2FsQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSA9IEVNUFRZX1NUUklORywgb3B0aW9uYWwgPSBmYWxzZSwgcHJpbWl0aXZlU2NoZW1hLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSwgdmFsdWVCbG9ja1R5cGUpIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcclxuICAgICAgICBpZiAocHJpbWl0aXZlU2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJpbWl0aXZlU2NoZW1hID0gcHJpbWl0aXZlU2NoZW1hO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlkQmxvY2sgPSBuZXcgTG9jYWxJZGVudGlmaWNhdGlvbkJsb2NrKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMubGVuQmxvY2sgPSBuZXcgTG9jYWxMZW5ndGhCbG9jayhwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sgPSB2YWx1ZUJsb2NrVHlwZSA/IG5ldyB2YWx1ZUJsb2NrVHlwZShwYXJhbWV0ZXJzKSA6IG5ldyBWYWx1ZUJsb2NrKHBhcmFtZXRlcnMpO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKSA/IGlucHV0TGVuZ3RoIDogdGhpcy5sZW5CbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCBfd3JpdGVyID0gd3JpdGVyIHx8IG5ldyBWaWV3V3JpdGVyKCk7XHJcbiAgICAgICAgaWYgKCF3cml0ZXIpIHtcclxuICAgICAgICAgICAgcHJlcGFyZUluZGVmaW5pdGVGb3JtKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZEJsb2NrQnVmID0gdGhpcy5pZEJsb2NrLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICBfd3JpdGVyLndyaXRlKGlkQmxvY2tCdWYpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgX3dyaXRlci53cml0ZShuZXcgVWludDhBcnJheShbMHg4MF0pLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay50b0JFUihzaXplT25seSwgX3dyaXRlcik7XHJcbiAgICAgICAgICAgIF93cml0ZXIud3JpdGUobmV3IEFycmF5QnVmZmVyKDIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQmxvY2tCdWYgPSB0aGlzLnZhbHVlQmxvY2sudG9CRVIoc2l6ZU9ubHkpO1xyXG4gICAgICAgICAgICB0aGlzLmxlbkJsb2NrLmxlbmd0aCA9IHZhbHVlQmxvY2tCdWYuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbGVuQmxvY2tCdWYgPSB0aGlzLmxlbkJsb2NrLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICAgICAgX3dyaXRlci53cml0ZShsZW5CbG9ja0J1Zik7XHJcbiAgICAgICAgICAgIF93cml0ZXIud3JpdGUodmFsdWVCbG9ja0J1Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfd3JpdGVyLmZpbmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgaWRCbG9jazogdGhpcy5pZEJsb2NrLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBsZW5CbG9jazogdGhpcy5sZW5CbG9jay50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWVCbG9jazogdGhpcy52YWx1ZUJsb2NrLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIG9wdGlvbmFsOiB0aGlzLm9wdGlvbmFsLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWl0aXZlU2NoZW1hKVxyXG4gICAgICAgICAgICBvYmplY3QucHJpbWl0aXZlU2NoZW1hID0gdGhpcy5wcmltaXRpdmVTY2hlbWEudG9KU09OKCk7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKGVuY29kaW5nID0gXCJhc2NpaVwiKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImFzY2lpXCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25Bc2NpaUVuY29kaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LlRvSGV4KHRoaXMudG9CRVIoKSk7XHJcbiAgICB9XHJcbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3B2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJsb2NrLnZhbHVlQmVmb3JlRGVjb2RlVmlldyl9YDtcclxuICAgIH1cclxuICAgIGlzRXF1YWwob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0aGlzUmF3ID0gdGhpcy50b0JFUigpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyUmF3ID0gb3RoZXIudG9CRVIoKTtcclxuICAgICAgICByZXR1cm4gcHZ1dGlsc19fbmFtZXNwYWNlLmlzRXF1YWxCdWZmZXIodGhpc1Jhdywgb3RoZXJSYXcpO1xyXG4gICAgfVxyXG59XHJcbkJhc2VCbG9jay5OQU1FID0gXCJCYXNlQmxvY2tcIjtcclxuZnVuY3Rpb24gcHJlcGFyZUluZGVmaW5pdGVGb3JtKGJhc2VCbG9jaykge1xyXG4gICAgaWYgKGJhc2VCbG9jayBpbnN0YW5jZW9mIHR5cGVTdG9yZS5Db25zdHJ1Y3RlZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYmFzZUJsb2NrLnZhbHVlQmxvY2sudmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHByZXBhcmVJbmRlZmluaXRlRm9ybSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGJhc2VCbG9jay5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAhIWJhc2VCbG9jay5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtO1xyXG59XG5cbmNsYXNzIEJhc2VTdHJpbmdCbG9jayBleHRlbmRzIEJhc2VCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gRU1QVFlfU1RSSU5HLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSwgc3RyaW5nVmFsdWVCbG9ja1R5cGUpIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBzdHJpbmdWYWx1ZUJsb2NrVHlwZSk7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZTtcclxuICAgIH1cclxuICAgIHNldFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRPZmZzZXQgPSB0aGlzLnZhbHVlQmxvY2suZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsICh0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pID8gaW5wdXRMZW5ndGggOiB0aGlzLmxlbkJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMudmFsdWVCbG9jay5lcnJvcjtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcm9tQnVmZmVyKHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICcke3RoaXMudmFsdWVCbG9jay52YWx1ZX0nYDtcclxuICAgIH1cclxufVxyXG5CYXNlU3RyaW5nQmxvY2suTkFNRSA9IFwiQmFzZVN0cmluZ0Jsb2NrXCI7XG5cbmNsYXNzIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKFZhbHVlQmxvY2spIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgaXNIZXhPbmx5ID0gdHJ1ZSwgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlzSGV4T25seSA9IGlzSGV4T25seTtcclxuICAgIH1cclxufVxyXG5Mb2NhbFByaW1pdGl2ZVZhbHVlQmxvY2suTkFNRSA9IFwiUHJpbWl0aXZlVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkdztcclxuY2xhc3MgUHJpbWl0aXZlIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsUHJpbWl0aXZlVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5fYSR3ID0gUHJpbWl0aXZlO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlByaW1pdGl2ZSA9IF9hJHc7XHJcbn0pKCk7XHJcblByaW1pdGl2ZS5OQU1FID0gXCJQUklNSVRJVkVcIjtcblxuZnVuY3Rpb24gbG9jYWxDaGFuZ2VUeXBlKGlucHV0T2JqZWN0LCBuZXdUeXBlKSB7XHJcbiAgICBpZiAoaW5wdXRPYmplY3QgaW5zdGFuY2VvZiBuZXdUeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0T2JqZWN0O1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV3T2JqZWN0ID0gbmV3IG5ld1R5cGUoKTtcclxuICAgIG5ld09iamVjdC5pZEJsb2NrID0gaW5wdXRPYmplY3QuaWRCbG9jaztcclxuICAgIG5ld09iamVjdC5sZW5CbG9jayA9IGlucHV0T2JqZWN0LmxlbkJsb2NrO1xyXG4gICAgbmV3T2JqZWN0Lndhcm5pbmdzID0gaW5wdXRPYmplY3Qud2FybmluZ3M7XHJcbiAgICBuZXdPYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gaW5wdXRPYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3O1xyXG4gICAgcmV0dXJuIG5ld09iamVjdDtcclxufVxyXG5mdW5jdGlvbiBsb2NhbEZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0ID0gMCwgaW5wdXRMZW5ndGggPSBpbnB1dEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgIGNvbnN0IGluY29taW5nT2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XHJcbiAgICBsZXQgcmV0dXJuT2JqZWN0ID0gbmV3IEJhc2VCbG9jayh7fSwgVmFsdWVCbG9jayk7XHJcbiAgICBjb25zdCBiYXNlQmxvY2sgPSBuZXcgTG9jYWxCYXNlQmxvY2soKTtcclxuICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXMoYmFzZUJsb2NrLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC5lcnJvciA9IGJhc2VCbG9jay5lcnJvcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dEJ1ZmZlci5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICBpZiAoIWludEJ1ZmZlci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSBcIlplcm8gYnVmZmVyIGxlbmd0aFwiO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGxldCByZXN1bHRPZmZzZXQgPSByZXR1cm5PYmplY3QuaWRCbG9jay5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgaWYgKHJldHVybk9iamVjdC5pZEJsb2NrLndhcm5pbmdzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LmlkQmxvY2sud2FybmluZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSByZXR1cm5PYmplY3QuaWRCbG9jay5lcnJvcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbnB1dE9mZnNldCA9IHJlc3VsdE9mZnNldDtcclxuICAgIGlucHV0TGVuZ3RoIC09IHJldHVybk9iamVjdC5pZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICBpZiAocmV0dXJuT2JqZWN0LmxlbkJsb2NrLndhcm5pbmdzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybk9iamVjdC53YXJuaW5ncy5jb25jYXQocmV0dXJuT2JqZWN0LmxlbkJsb2NrLndhcm5pbmdzKTtcclxuICAgIH1cclxuICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmVycm9yO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlucHV0T2Zmc2V0ID0gcmVzdWx0T2Zmc2V0O1xyXG4gICAgaW5wdXRMZW5ndGggLT0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgaWYgKCFyZXR1cm5PYmplY3QuaWRCbG9jay5pc0NvbnN0cnVjdGVkICYmXHJcbiAgICAgICAgcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICByZXR1cm5PYmplY3QuZXJyb3IgPSBcIkluZGVmaW5pdGUgbGVuZ3RoIGZvcm0gdXNlZCBmb3IgcHJpbWl0aXZlIGVuY29kaW5nIGZvcm1cIjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvZmZzZXQ6IC0xLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBsZXQgbmV3QVNOMVR5cGUgPSBCYXNlQmxvY2s7XHJcbiAgICBzd2l0Y2ggKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ0NsYXNzKSB7XHJcbiAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICBpZiAoKHJldHVybk9iamVjdC5pZEJsb2NrLnRhZ051bWJlciA+PSAzNykgJiZcclxuICAgICAgICAgICAgICAgIChyZXR1cm5PYmplY3QuaWRCbG9jay5pc0hleE9ubHkgPT09IGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJVTklWRVJTQUwgMzcgYW5kIHVwcGVyIHRhZ3MgYXJlIHJlc2VydmVkIGJ5IEFTTi4xIHN0YW5kYXJkXCI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3RcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChyZXR1cm5PYmplY3QuaWRCbG9jay50YWdOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXR1cm5PYmplY3QubGVuQmxvY2subGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJUeXBlIFtVTklWRVJTQUwgMF0gaXMgcmVzZXJ2ZWRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJldHVybk9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5FbmRPZkNvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuQm9vbGVhbjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5JbnRlZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkJpdFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5PY3RldFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5OdWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLk9iamVjdElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkVudW1lcmF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlV0ZjhTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuVElNRTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTU6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuT2JqZWN0LmVycm9yID0gXCJbVU5JVkVSU0FMIDE1XSBpcyByZXNlcnZlZCBieSBBU04uMSBzdGFuZGFyZFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogLTEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmV0dXJuT2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTY6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuU2VxdWVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE3OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlNldDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTg6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuTnVtZXJpY1N0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTk6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuUHJpbnRhYmxlU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5UZWxldGV4U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMTpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5WaWRlb3RleFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjI6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuSUE1U3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyMzpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5VVENUaW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5HZW5lcmFsaXplZFRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI1OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkdyYXBoaWNTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlZpc2libGVTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI3OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkdlbmVyYWxTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlVuaXZlcnNhbFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjk6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuQ2hhcmFjdGVyU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzMDpcclxuICAgICAgICAgICAgICAgICAgICBuZXdBU04xVHlwZSA9IHR5cGVTdG9yZS5CbXBTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMxOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkRBVEU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLlRpbWVPZkRheTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzM6XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QVNOMVR5cGUgPSB0eXBlU3RvcmUuRGF0ZVRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM0OlxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FTTjFUeXBlID0gdHlwZVN0b3JlLkR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09iamVjdCA9IHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdHlwZVN0b3JlLkNvbnN0cnVjdGVkKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdHlwZVN0b3JlLlByaW1pdGl2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld09iamVjdC5pZEJsb2NrID0gcmV0dXJuT2JqZWN0LmlkQmxvY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0LmxlbkJsb2NrID0gcmV0dXJuT2JqZWN0LmxlbkJsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld09iamVjdC53YXJuaW5ncyA9IHJldHVybk9iamVjdC53YXJuaW5ncztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5PYmplY3QgPSBuZXdPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICBuZXdBU04xVHlwZSA9IHJldHVybk9iamVjdC5pZEJsb2NrLmlzQ29uc3RydWN0ZWRcclxuICAgICAgICAgICAgICAgID8gdHlwZVN0b3JlLkNvbnN0cnVjdGVkXHJcbiAgICAgICAgICAgICAgICA6IHR5cGVTdG9yZS5QcmltaXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuT2JqZWN0ID0gbG9jYWxDaGFuZ2VUeXBlKHJldHVybk9iamVjdCwgbmV3QVNOMVR5cGUpO1xyXG4gICAgcmVzdWx0T2Zmc2V0ID0gcmV0dXJuT2JqZWN0LmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCByZXR1cm5PYmplY3QubGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybSA/IGlucHV0TGVuZ3RoIDogcmV0dXJuT2JqZWN0LmxlbkJsb2NrLmxlbmd0aCk7XHJcbiAgICByZXR1cm5PYmplY3QudmFsdWVCZWZvcmVEZWNvZGVWaWV3ID0gaW5wdXRCdWZmZXIuc3ViYXJyYXkoaW5jb21pbmdPZmZzZXQsIGluY29taW5nT2Zmc2V0ICsgcmV0dXJuT2JqZWN0LmJsb2NrTGVuZ3RoKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb2Zmc2V0OiByZXN1bHRPZmZzZXQsXHJcbiAgICAgICAgcmVzdWx0OiByZXR1cm5PYmplY3RcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZnJvbUJFUihpbnB1dEJ1ZmZlcikge1xyXG4gICAgaWYgKCFpbnB1dEJ1ZmZlci5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEJhc2VCbG9jayh7fSwgVmFsdWVCbG9jayk7XHJcbiAgICAgICAgcmVzdWx0LmVycm9yID0gXCJJbnB1dCBidWZmZXIgaGFzIHplcm8gbGVuZ3RoXCI7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb2Zmc2V0OiAtMSxcclxuICAgICAgICAgICAgcmVzdWx0XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBsb2NhbEZyb21CRVIocHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcikuc2xpY2UoKSwgMCwgaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCk7XHJcbn1cblxuZnVuY3Rpb24gY2hlY2tMZW4oaW5kZWZpbml0ZUxlbmd0aCwgbGVuZ3RoKSB7XHJcbiAgICBpZiAoaW5kZWZpbml0ZUxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbmd0aDtcclxufVxyXG5jbGFzcyBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IFtdLCBpc0luZGVmaW5pdGVGb3JtID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNJbmRlZmluaXRlRm9ybSA9IGlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCB2aWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZUJlZm9yZURlY29kZVZpZXcgPSB2aWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUJlZm9yZURlY29kZVZpZXcubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIlplcm8gYnVmZmVyIGxlbmd0aFwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY3VycmVudE9mZnNldCA9IGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChjaGVja0xlbih0aGlzLmlzSW5kZWZpbml0ZUZvcm0sIGlucHV0TGVuZ3RoKSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgcmV0dXJuT2JqZWN0ID0gbG9jYWxGcm9tQkVSKHZpZXcsIGN1cnJlbnRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJldHVybk9iamVjdC5vZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gcmV0dXJuT2JqZWN0LnJlc3VsdC5lcnJvcjtcclxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MuY29uY2F0KHJldHVybk9iamVjdC5yZXN1bHQud2FybmluZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgPSByZXR1cm5PYmplY3Qub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHJldHVybk9iamVjdC5yZXN1bHQuYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlucHV0TGVuZ3RoIC09IHJldHVybk9iamVjdC5yZXN1bHQuYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUucHVzaChyZXR1cm5PYmplY3QucmVzdWx0KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSAmJiByZXR1cm5PYmplY3QucmVzdWx0LmNvbnN0cnVjdG9yLk5BTUUgPT09IEVORF9PRl9DT05URU5UX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXS5jb25zdHJ1Y3Rvci5OQU1FID09PSBFTkRfT0ZfQ09OVEVOVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTm8gRW5kT2ZDb250ZW50IGJsb2NrIGVuY29kZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSwgd3JpdGVyKSB7XHJcbiAgICAgICAgY29uc3QgX3dyaXRlciA9IHdyaXRlciB8fCBuZXcgVmlld1dyaXRlcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldLnRvQkVSKHNpemVPbmx5LCBfd3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF93cml0ZXIuZmluYWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBvYmplY3QgPSB7XHJcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxyXG4gICAgICAgICAgICBpc0luZGVmaW5pdGVGb3JtOiB0aGlzLmlzSW5kZWZpbml0ZUZvcm0sXHJcbiAgICAgICAgICAgIHZhbHVlOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICBvYmplY3QudmFsdWUucHVzaCh2YWx1ZS50b0pTT04oKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2suTkFNRSA9IFwiQ29uc3RydWN0ZWRWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSR2O1xyXG5jbGFzcyBDb25zdHJ1Y3RlZCBleHRlbmRzIEJhc2VCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPSB0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICAgICAgY29uc3QgcmVzdWx0T2Zmc2V0ID0gdGhpcy52YWx1ZUJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCAodGhpcy5sZW5CbG9jay5pc0luZGVmaW5pdGVGb3JtKSA/IGlucHV0TGVuZ3RoIDogdGhpcy5sZW5CbG9jay5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIGlmICghdGhpcy52YWx1ZUJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLnZhbHVlQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHRoaXMudmFsdWVCbG9jay52YWx1ZSkge1xyXG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZS50b1N0cmluZyhcImFzY2lpXCIpLnNwbGl0KFwiXFxuXCIpLm1hcChvID0+IGAgICR7b31gKS5qb2luKFwiXFxuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmxvY2tOYW1lID0gdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID09PSAzXHJcbiAgICAgICAgICAgID8gYFske3RoaXMuaWRCbG9jay50YWdOdW1iZXJ9XWBcclxuICAgICAgICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGhcclxuICAgICAgICAgICAgPyBgJHtibG9ja05hbWV9IDpcXG4ke3ZhbHVlcy5qb2luKFwiXFxuXCIpfWBcclxuICAgICAgICAgICAgOiBgJHtibG9ja05hbWV9IDpgO1xyXG4gICAgfVxyXG59XHJcbl9hJHYgPSBDb25zdHJ1Y3RlZDtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5Db25zdHJ1Y3RlZCA9IF9hJHY7XHJcbn0pKCk7XHJcbkNvbnN0cnVjdGVkLk5BTUUgPSBcIkNPTlNUUlVDVEVEXCI7XG5cbmNsYXNzIExvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgfVxyXG59XHJcbkxvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jay5vdmVycmlkZSA9IFwiRW5kT2ZDb250ZW50VmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkdTtcclxuY2xhc3MgRW5kT2ZDb250ZW50IGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsRW5kT2ZDb250ZW50VmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMDtcclxuICAgIH1cclxufVxyXG5fYSR1ID0gRW5kT2ZDb250ZW50O1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkVuZE9mQ29udGVudCA9IF9hJHU7XHJcbn0pKCk7XHJcbkVuZE9mQ29udGVudC5OQU1FID0gRU5EX09GX0NPTlRFTlRfTkFNRTtcblxudmFyIF9hJHQ7XHJcbmNsYXNzIE51bGwgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNTtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIk5vbi16ZXJvIGxlbmd0aCBvZiB2YWx1ZSBibG9jayBmb3IgTnVsbCB0eXBlXCIpO1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aClcclxuICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmxlbkJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gaW5wdXRMZW5ndGg7XHJcbiAgICAgICAgaWYgKChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKSA+IGlucHV0QnVmZmVyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWQgKGluY29uc2lzdGVudCBvZmZzZXQgYW5kIGxlbmd0aCB2YWx1ZXMpXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBjb25zdCByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoMik7XHJcbiAgICAgICAgaWYgKCFzaXplT25seSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocmV0QnVmKTtcclxuICAgICAgICAgICAgcmV0Vmlld1swXSA9IDB4MDU7XHJcbiAgICAgICAgICAgIHJldFZpZXdbMV0gPSAweDAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZShyZXRCdWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9YDtcclxuICAgIH1cclxufVxyXG5fYSR0ID0gTnVsbDtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5OdWxsID0gX2EkdDtcclxufSkoKTtcclxuTnVsbC5OQU1FID0gXCJOVUxMXCI7XG5cbmNsYXNzIExvY2FsQm9vbGVhblZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLnZhbHVlSGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwYXJhbWV0ZXJzLnZhbHVlSGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2N0ZXQgb2YgdGhpcy52YWx1ZUhleFZpZXcpIHtcclxuICAgICAgICAgICAgaWYgKG9jdGV0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXdbMF0gPSB2YWx1ZSA/IDB4RkYgOiAweDAwO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoID4gMSlcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiQm9vbGVhbiB2YWx1ZSBlbmNvZGVkIGluIG1vcmUgdGhlbiAxIG9jdGV0XCIpO1xyXG4gICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICBwdnV0aWxzX19uYW1lc3BhY2UudXRpbERlY29kZVRDLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGlucHV0TGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiAoaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICB0b0JFUigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJvb2xlYW5WYWx1ZUJsb2NrLk5BTUUgPSBcIkJvb2xlYW5WYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRzO1xyXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsQm9vbGVhblZhbHVlQmxvY2spO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE7XHJcbiAgICB9XHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUJsb2NrLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0VmFsdWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy5nZXRWYWx1ZX1gO1xyXG4gICAgfVxyXG59XHJcbl9hJHMgPSBCb29sZWFuO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkJvb2xlYW4gPSBfYSRzO1xyXG59KSgpO1xyXG5Cb29sZWFuLk5BTUUgPSBcIkJPT0xFQU5cIjtcblxuY2xhc3MgTG9jYWxPY3RldFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jaykge1xyXG4gICAgY29uc3RydWN0b3IoeyBpc0NvbnN0cnVjdGVkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pc0NvbnN0cnVjdGVkID0gaXNDb25zdHJ1Y3RlZDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ID0gTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2sucHJvdG90eXBlLmZyb21CRVIuY2FsbCh0aGlzLCBpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdE9mZnNldCA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCbG9ja05hbWUgPSB0aGlzLnZhbHVlW2ldLmNvbnN0cnVjdG9yLk5BTUU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrTmFtZSA9PT0gRU5EX09GX0NPTlRFTlRfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZWZpbml0ZUZvcm0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJFbmRPZkNvbnRlbnQgaXMgdW5leHBlY3RlZCwgT0NURVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBPQ1RFVCBTVFJJTkdzIG9ubHlcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tOYW1lICE9PSBPQ1RFVF9TVFJJTkdfTkFNRSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIk9DVEVUIFNUUklORyBtYXkgY29uc2lzdHMgb2YgT0NURVQgU1RSSU5HcyBvbmx5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGV4T25seSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSBpbnB1dExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKVxyXG4gICAgICAgICAgICByZXR1cm4gTG9jYWxDb25zdHJ1Y3RlZFZhbHVlQmxvY2sucHJvdG90eXBlLnRvQkVSLmNhbGwodGhpcywgc2l6ZU9ubHksIHdyaXRlcik7XHJcbiAgICAgICAgcmV0dXJuIHNpemVPbmx5XHJcbiAgICAgICAgICAgID8gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpXHJcbiAgICAgICAgICAgIDogdGhpcy52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIGlzQ29uc3RydWN0ZWQ6IHRoaXMuaXNDb25zdHJ1Y3RlZCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsT2N0ZXRTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIk9jdGV0U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkcjtcclxuY2xhc3MgT2N0ZXRTdHJpbmcgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyBpZEJsb2NrID0ge30sIGxlbkJsb2NrID0ge30sIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9iLCBfYztcclxuICAgICAgICAoX2IgPSBwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IChwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQgPSAhISgoX2MgPSBwYXJhbWV0ZXJzLnZhbHVlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSk7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBpZEJsb2NrOiB7XHJcbiAgICAgICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiBwYXJhbWV0ZXJzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgICAgICAgICAuLi5pZEJsb2NrLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZW5CbG9jazoge1xyXG4gICAgICAgICAgICAgICAgLi4ubGVuQmxvY2ssXHJcbiAgICAgICAgICAgICAgICBpc0luZGVmaW5pdGVGb3JtOiAhIXBhcmFtZXRlcnMuaXNJbmRlZmluaXRlRm9ybSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLi4ucGFyYW1ldGVycyxcclxuICAgICAgICB9LCBMb2NhbE9jdGV0U3RyaW5nVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNDtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkID0gdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQ7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzSW5kZWZpbml0ZUZvcm0gPSB0aGlzLmxlbkJsb2NrLmlzSW5kZWZpbml0ZUZvcm07XHJcbiAgICAgICAgaWYgKGlucHV0TGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlkQmxvY2suZXJyb3IubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCArPSB0aGlzLmlkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbkJsb2NrLmVycm9yLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gdGhpcy5sZW5CbG9jay5ibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBpbnB1dEJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpIDogaW5wdXRCdWZmZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1Zi5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuID0gbG9jYWxGcm9tQkVSKGJ1ZiwgMCwgYnVmLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc24ub2Zmc2V0ICE9PSAtMSAmJiBhc24ub2Zmc2V0ID09PSBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBbYXNuLnJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBvbkFzY2lpRW5jb2RpbmcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVCbG9jay5pc0NvbnN0cnVjdGVkIHx8ICh0aGlzLnZhbHVlQmxvY2sudmFsdWUgJiYgdGhpcy52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdGVkLnByb3RvdHlwZS5vbkFzY2lpRW5jb2RpbmcuY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IuTkFNRX0gOiAke3B2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldyl9YDtcclxuICAgIH1cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pZEJsb2NrLmlzQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50IG9mIHRoaXMudmFsdWVCbG9jay52YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIE9jdGV0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKGNvbnRlbnQudmFsdWVCbG9jay52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuY29uY2F0KGFycmF5KTtcclxuICAgIH1cclxufVxyXG5fYSRyID0gT2N0ZXRTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuT2N0ZXRTdHJpbmcgPSBfYSRyO1xyXG59KSgpO1xyXG5PY3RldFN0cmluZy5OQU1FID0gT0NURVRfU1RSSU5HX05BTUU7XG5cbmNsYXNzIExvY2FsQml0U3RyaW5nVmFsdWVCbG9jayBleHRlbmRzIEhleEJsb2NrKExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHVudXNlZEJpdHMgPSAwLCBpc0NvbnN0cnVjdGVkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gdW51c2VkQml0cztcclxuICAgICAgICB0aGlzLmlzQ29uc3RydWN0ZWQgPSBpc0NvbnN0cnVjdGVkO1xyXG4gICAgICAgIHRoaXMuYmxvY2tMZW5ndGggPSB0aGlzLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKCFpbnB1dExlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSAtMTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IExvY2FsQ29uc3RydWN0ZWRWYWx1ZUJsb2NrLnByb3RvdHlwZS5mcm9tQkVSLmNhbGwodGhpcywgaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50QmxvY2tOYW1lID0gdmFsdWUuY29uc3RydWN0b3IuTkFNRTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2tOYW1lID09PSBFTkRfT0ZfQ09OVEVOVF9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRlZmluaXRlRm9ybSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZE9mQ29udGVudCBpcyB1bmV4cGVjdGVkLCBCSVQgU1RSSU5HIG1heSBjb25zaXN0cyBvZiBCSVQgU1RSSU5HcyBvbmx5XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJsb2NrTmFtZSAhPT0gQklUX1NUUklOR19OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiQklUIFNUUklORyBtYXkgY29uc2lzdHMgb2YgQklUIFNUUklOR3Mgb25seVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQmxvY2sgPSB2YWx1ZS52YWx1ZUJsb2NrO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnVudXNlZEJpdHMgPiAwKSAmJiAodmFsdWVCbG9jay51bnVzZWRCaXRzID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gXCJVc2luZyBvZiBcXFwidW51c2VkIGJpdHNcXFwiIGluc2lkZSBjb25zdHJ1Y3RpdmUgQklUIFNUUklORyBhbGxvd2VkIGZvciBsZWFzdCBvbmUgb25seVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudW51c2VkQml0cyA9IHZhbHVlQmxvY2sudW51c2VkQml0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnB1dFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgICAgICBpZiAoIWNoZWNrQnVmZmVyUGFyYW1zKHRoaXMsIGlucHV0VmlldywgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGludEJ1ZmZlciA9IGlucHV0Vmlldy5zdWJhcnJheShpbnB1dE9mZnNldCwgaW5wdXRPZmZzZXQgKyBpbnB1dExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gaW50QnVmZmVyWzBdO1xyXG4gICAgICAgIGlmICh0aGlzLnVudXNlZEJpdHMgPiA3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIlVudXNlZCBiaXRzIGZvciBCaXRTdHJpbmcgbXVzdCBiZSBpbiByYW5nZSAwLTdcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudW51c2VkQml0cykge1xyXG4gICAgICAgICAgICBjb25zdCBidWYgPSBpbnRCdWZmZXIuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc24gPSBsb2NhbEZyb21CRVIoYnVmLCAwLCBidWYuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzbi5vZmZzZXQgIT09IC0xICYmIGFzbi5vZmZzZXQgPT09IChpbnB1dExlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbYXNuLnJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSBpbnRCdWZmZXIuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IGludEJ1ZmZlci5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5LCB3cml0ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbnN0cnVjdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMb2NhbENvbnN0cnVjdGVkVmFsdWVCbG9jay5wcm90b3R5cGUudG9CRVIuY2FsbCh0aGlzLCBzaXplT25seSwgd3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCArIDEpO1xyXG4gICAgICAgIHJldFZpZXdbMF0gPSB0aGlzLnVudXNlZEJpdHM7XHJcbiAgICAgICAgcmV0Vmlldy5zZXQodGhpcy52YWx1ZUhleFZpZXcsIDEpO1xyXG4gICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdW51c2VkQml0czogdGhpcy51bnVzZWRCaXRzLFxyXG4gICAgICAgICAgICBpc0NvbnN0cnVjdGVkOiB0aGlzLmlzQ29uc3RydWN0ZWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJpdFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiQml0U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkcTtcclxuY2xhc3MgQml0U3RyaW5nIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgaWRCbG9jayA9IHt9LCBsZW5CbG9jayA9IHt9LCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgKF9iID0gcGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAocGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkID0gISEoKF9jID0gcGFyYW1ldGVycy52YWx1ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkpO1xyXG4gICAgICAgIHN1cGVyKHtcclxuICAgICAgICAgICAgaWRCbG9jazoge1xyXG4gICAgICAgICAgICAgICAgaXNDb25zdHJ1Y3RlZDogcGFyYW1ldGVycy5pc0NvbnN0cnVjdGVkLFxyXG4gICAgICAgICAgICAgICAgLi4uaWRCbG9jayxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVuQmxvY2s6IHtcclxuICAgICAgICAgICAgICAgIC4uLmxlbkJsb2NrLFxyXG4gICAgICAgICAgICAgICAgaXNJbmRlZmluaXRlRm9ybTogISFwYXJhbWV0ZXJzLmlzSW5kZWZpbml0ZUZvcm0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC4uLnBhcmFtZXRlcnMsXHJcbiAgICAgICAgfSwgTG9jYWxCaXRTdHJpbmdWYWx1ZUJsb2NrKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzO1xyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmlzQ29uc3RydWN0ZWQgPSB0aGlzLmlkQmxvY2suaXNDb25zdHJ1Y3RlZDtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2suaXNJbmRlZmluaXRlRm9ybSA9IHRoaXMubGVuQmxvY2suaXNJbmRlZmluaXRlRm9ybTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUJsb2NrLmlzQ29uc3RydWN0ZWQgfHwgKHRoaXMudmFsdWVCbG9jay52YWx1ZSAmJiB0aGlzLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0ZWQucHJvdG90eXBlLm9uQXNjaWlFbmNvZGluZy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgYml0cyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUhleCA9IHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYnl0ZSBvZiB2YWx1ZUhleCkge1xyXG4gICAgICAgICAgICAgICAgYml0cy5wdXNoKGJ5dGUudG9TdHJpbmcoMikucGFkU3RhcnQoOCwgXCIwXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBiaXRzU3RyID0gYml0cy5qb2luKFwiXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7Yml0c1N0ci5zdWJzdHJpbmcoMCwgYml0c1N0ci5sZW5ndGggLSB0aGlzLnZhbHVlQmxvY2sudW51c2VkQml0cyl9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuX2EkcSA9IEJpdFN0cmluZztcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5CaXRTdHJpbmcgPSBfYSRxO1xyXG59KSgpO1xyXG5CaXRTdHJpbmcuTkFNRSA9IEJJVF9TVFJJTkdfTkFNRTtcblxudmFyIF9hJHA7XHJcbmZ1bmN0aW9uIHZpZXdBZGQoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgY29uc3QgYyA9IG5ldyBVaW50OEFycmF5KFswXSk7XHJcbiAgICBjb25zdCBmaXJzdFZpZXcgPSBuZXcgVWludDhBcnJheShmaXJzdCk7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoc2Vjb25kKTtcclxuICAgIGxldCBmaXJzdFZpZXdDb3B5ID0gZmlyc3RWaWV3LnNsaWNlKDApO1xyXG4gICAgY29uc3QgZmlyc3RWaWV3Q29weUxlbmd0aCA9IGZpcnN0Vmlld0NvcHkubGVuZ3RoIC0gMTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXdDb3B5ID0gc2Vjb25kVmlldy5zbGljZSgwKTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXdDb3B5TGVuZ3RoID0gc2Vjb25kVmlld0NvcHkubGVuZ3RoIC0gMTtcclxuICAgIGxldCB2YWx1ZSA9IDA7XHJcbiAgICBjb25zdCBtYXggPSAoc2Vjb25kVmlld0NvcHlMZW5ndGggPCBmaXJzdFZpZXdDb3B5TGVuZ3RoKSA/IGZpcnN0Vmlld0NvcHlMZW5ndGggOiBzZWNvbmRWaWV3Q29weUxlbmd0aDtcclxuICAgIGxldCBjb3VudGVyID0gMDtcclxuICAgIGZvciAobGV0IGkgPSBtYXg7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoY291bnRlciA8IHNlY29uZFZpZXdDb3B5Lmxlbmd0aCk6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdICsgc2Vjb25kVmlld0NvcHlbc2Vjb25kVmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSArIGNbMF07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gKyBjWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjWzBdID0gdmFsdWUgLyAxMDtcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoY291bnRlciA+PSBmaXJzdFZpZXdDb3B5Lmxlbmd0aCk6XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5ID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxDb25jYXRWaWV3KG5ldyBVaW50OEFycmF5KFt2YWx1ZSAlIDEwXSksIGZpcnN0Vmlld0NvcHkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlICUgMTA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNbMF0gPiAwKVxyXG4gICAgICAgIGZpcnN0Vmlld0NvcHkgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbENvbmNhdFZpZXcoYywgZmlyc3RWaWV3Q29weSk7XHJcbiAgICByZXR1cm4gZmlyc3RWaWV3Q29weTtcclxufVxyXG5mdW5jdGlvbiBwb3dlcjIobikge1xyXG4gICAgaWYgKG4gPj0gcG93ZXJzMi5sZW5ndGgpIHtcclxuICAgICAgICBmb3IgKGxldCBwID0gcG93ZXJzMi5sZW5ndGg7IHAgPD0gbjsgcCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheShbMF0pO1xyXG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gKHBvd2VyczJbcCAtIDFdKS5zbGljZSgwKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IChkaWdpdHMubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ldyBVaW50OEFycmF5KFsoZGlnaXRzW2ldIDw8IDEpICsgY1swXV0pO1xyXG4gICAgICAgICAgICAgICAgY1swXSA9IG5ld1ZhbHVlWzBdIC8gMTA7XHJcbiAgICAgICAgICAgICAgICBkaWdpdHNbaV0gPSBuZXdWYWx1ZVswXSAlIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjWzBdID4gMClcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsQ29uY2F0VmlldyhjLCBkaWdpdHMpO1xyXG4gICAgICAgICAgICBwb3dlcnMyLnB1c2goZGlnaXRzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG93ZXJzMltuXTtcclxufVxyXG5mdW5jdGlvbiB2aWV3U3ViKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgIGxldCBiID0gMDtcclxuICAgIGNvbnN0IGZpcnN0VmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0KTtcclxuICAgIGNvbnN0IHNlY29uZFZpZXcgPSBuZXcgVWludDhBcnJheShzZWNvbmQpO1xyXG4gICAgY29uc3QgZmlyc3RWaWV3Q29weSA9IGZpcnN0Vmlldy5zbGljZSgwKTtcclxuICAgIGNvbnN0IGZpcnN0Vmlld0NvcHlMZW5ndGggPSBmaXJzdFZpZXdDb3B5Lmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3Q29weSA9IHNlY29uZFZpZXcuc2xpY2UoMCk7XHJcbiAgICBjb25zdCBzZWNvbmRWaWV3Q29weUxlbmd0aCA9IHNlY29uZFZpZXdDb3B5Lmxlbmd0aCAtIDE7XHJcbiAgICBsZXQgdmFsdWU7XHJcbiAgICBsZXQgY291bnRlciA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gc2Vjb25kVmlld0NvcHlMZW5ndGg7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICB2YWx1ZSA9IGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdIC0gc2Vjb25kVmlld0NvcHlbc2Vjb25kVmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSAtIGI7XHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgKHZhbHVlIDwgMCk6XHJcbiAgICAgICAgICAgICAgICBiID0gMTtcclxuICAgICAgICAgICAgICAgIGZpcnN0Vmlld0NvcHlbZmlyc3RWaWV3Q29weUxlbmd0aCAtIGNvdW50ZXJdID0gdmFsdWUgKyAxMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiID4gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAoZmlyc3RWaWV3Q29weUxlbmd0aCAtIHNlY29uZFZpZXdDb3B5TGVuZ3RoICsgMSk7IGkgPj0gMDsgaS0tLCBjb3VudGVyKyspIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSAtIGI7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGIgPSAxO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RWaWV3Q29weVtmaXJzdFZpZXdDb3B5TGVuZ3RoIC0gY291bnRlcl0gPSB2YWx1ZSArIDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFZpZXdDb3B5W2ZpcnN0Vmlld0NvcHlMZW5ndGggLSBjb3VudGVyXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmlyc3RWaWV3Q29weS5zbGljZSgpO1xyXG59XHJcbmNsYXNzIExvY2FsSW50ZWdlclZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gMDtcclxuICAgICAgICBpZiAocGFyYW1ldGVycy52YWx1ZUhleCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRWYWx1ZUhleCgpIHtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoID49IDQpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiVG9vIGJpZyBJbnRlZ2VyIGZvciBkZWNvZGluZywgaGV4IG9ubHlcIik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWVEZWMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxEZWNvZGVUQy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IHZhbHVlRGVjKHYpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZURlYyA9IHY7XHJcbiAgICAgICAgdGhpcy5pc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHB2dXRpbHNfX25hbWVzcGFjZS51dGlsRW5jb2RlVEModikpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlRGVjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZURlYztcclxuICAgIH1cclxuICAgIGZyb21ERVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCwgZXhwZWN0ZWRMZW5ndGggPSAwKSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKVxyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBpZiAoKHZpZXdbMF0gPT09IDB4MDApICYmICgodmlld1sxXSAmIDB4ODApICE9PSAwKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHZpZXcuc3ViYXJyYXkoMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRMZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh2aWV3Lmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChleHBlY3RlZExlbmd0aCAtIHZpZXcubGVuZ3RoKSA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoID0gdmlldy5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdmlldy5zdWJhcnJheShleHBlY3RlZExlbmd0aCAtIHZpZXcubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9ERVIoc2l6ZU9ubHkgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICAgICAgY2FzZSAoKHZpZXdbMF0gJiAweDgwKSAhPT0gMCk6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlSGV4Vmlldy5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkVmlld1swXSA9IDB4MDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFZpZXcuc2V0KHZpZXcsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdXBkYXRlZFZpZXc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAoKHZpZXdbMF0gPT09IDB4MDApICYmICgodmlld1sxXSAmIDB4ODApID09PSAwKSk6XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXcgPSB0aGlzLnZhbHVlSGV4Vmlldy5zdWJhcnJheSgxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b0JFUihzaXplT25seSk7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRPZmZzZXQgPSBzdXBlci5mcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0VmFsdWVIZXgoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICByZXR1cm4gc2l6ZU9ubHlcclxuICAgICAgICAgICAgPyBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoKVxyXG4gICAgICAgICAgICA6IHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxyXG4gICAgICAgICAgICB2YWx1ZURlYzogdGhpcy52YWx1ZURlYyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RCaXQgPSAodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICogOCkgLSAxO1xyXG4gICAgICAgIGxldCBkaWdpdHMgPSBuZXcgVWludDhBcnJheSgodGhpcy52YWx1ZUhleFZpZXcubGVuZ3RoICogOCkgLyAzKTtcclxuICAgICAgICBsZXQgYml0TnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgY3VycmVudEJ5dGU7XHJcbiAgICAgICAgY29uc3QgYXNuMVZpZXcgPSB0aGlzLnZhbHVlSGV4VmlldztcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGJ5dGVOdW1iZXIgPSAoYXNuMVZpZXcuYnl0ZUxlbmd0aCAtIDEpOyBieXRlTnVtYmVyID49IDA7IGJ5dGVOdW1iZXItLSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IGFzbjFWaWV3W2J5dGVOdW1iZXJdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50Qnl0ZSAmIDEpID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiaXROdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBmaXJzdEJpdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyA9IHZpZXdTdWIocG93ZXIyKGJpdE51bWJlciksIGRpZ2l0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIi1cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gdmlld0FkZChkaWdpdHMsIHBvd2VyMihiaXROdW1iZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiaXROdW1iZXIrKztcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCeXRlID4+PSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdHNbaV0pXHJcbiAgICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGZsYWcpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZGlnaXRzU3RyaW5nLmNoYXJBdChkaWdpdHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmxhZyA9PT0gZmFsc2UpXHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBkaWdpdHNTdHJpbmcuY2hhckF0KDApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuX2EkcCA9IExvY2FsSW50ZWdlclZhbHVlQmxvY2s7XHJcbkxvY2FsSW50ZWdlclZhbHVlQmxvY2suTkFNRSA9IFwiSW50ZWdlclZhbHVlQmxvY2tcIjtcclxuKCgpID0+IHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfYSRwLnByb3RvdHlwZSwgXCJ2YWx1ZUhleFwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHYpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlSGV4KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVIZXhWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufSkoKTtcblxudmFyIF9hJG87XHJcbmNsYXNzIEludGVnZXIgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxJbnRlZ2VyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjtcclxuICAgIH1cclxuICAgIHRvQmlnSW50KCkge1xyXG4gICAgICAgIGFzc2VydEJpZ0ludCgpO1xyXG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21CaWdJbnQodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRCaWdJbnQoKTtcclxuICAgICAgICBjb25zdCBiaWdJbnRWYWx1ZSA9IEJpZ0ludCh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IFZpZXdXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCBoZXggPSBiaWdJbnRWYWx1ZS50b1N0cmluZygxNikucmVwbGFjZSgvXi0vLCBcIlwiKTtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tSGV4KGhleCkpO1xyXG4gICAgICAgIGlmIChiaWdJbnRWYWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBuZXcgVWludDhBcnJheSh2aWV3Lmxlbmd0aCArICh2aWV3WzBdICYgMHg4MCA/IDEgOiAwKSk7XHJcbiAgICAgICAgICAgIGZpcnN0WzBdIHw9IDB4ODA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW50ID0gQmlnSW50KGAweCR7cHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleChmaXJzdCl9YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZEludCA9IGZpcnN0SW50ICsgYmlnSW50VmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZCA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tSGV4KHNlY29uZEludC50b1N0cmluZygxNikpKTtcclxuICAgICAgICAgICAgc2Vjb25kWzBdIHw9IDB4ODA7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZShzZWNvbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHZpZXdbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUobmV3IFVpbnQ4QXJyYXkoWzBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlKHZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgSW50ZWdlcih7XHJcbiAgICAgICAgICAgIHZhbHVlSGV4OiB3cml0ZXIuZmluYWwoKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgY29udmVydFRvREVSKCkge1xyXG4gICAgICAgIGNvbnN0IGludGVnZXIgPSBuZXcgSW50ZWdlcih7IHZhbHVlSGV4OiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3IH0pO1xyXG4gICAgICAgIGludGVnZXIudmFsdWVCbG9jay50b0RFUigpO1xyXG4gICAgICAgIHJldHVybiBpbnRlZ2VyO1xyXG4gICAgfVxyXG4gICAgY29udmVydEZyb21ERVIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlZ2VyKHtcclxuICAgICAgICAgICAgdmFsdWVIZXg6IHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXdbMF0gPT09IDBcclxuICAgICAgICAgICAgICAgID8gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldy5zdWJhcnJheSgxKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKX1gO1xyXG4gICAgfVxyXG59XHJcbl9hJG8gPSBJbnRlZ2VyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkludGVnZXIgPSBfYSRvO1xyXG59KSgpO1xyXG5JbnRlZ2VyLk5BTUUgPSBcIklOVEVHRVJcIjtcblxudmFyIF9hJG47XHJcbmNsYXNzIEVudW1lcmF0ZWQgZXh0ZW5kcyBJbnRlZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDEwO1xyXG4gICAgfVxyXG59XHJcbl9hJG4gPSBFbnVtZXJhdGVkO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkVudW1lcmF0ZWQgPSBfYSRuO1xyXG59KSgpO1xyXG5FbnVtZXJhdGVkLk5BTUUgPSBcIkVOVU1FUkFURURcIjtcblxuY2xhc3MgTG9jYWxTaWRWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soVmFsdWVCbG9jaykge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZURlYyA9IC0xLCBpc0ZpcnN0U2lkID0gZmFsc2UsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZURlYyA9IHZhbHVlRGVjO1xyXG4gICAgICAgIHRoaXMuaXNGaXJzdFNpZCA9IGlzRmlyc3RTaWQ7XHJcbiAgICB9XHJcbiAgICBmcm9tQkVSKGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgICAgICBpZiAoIWlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5wdXRWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlclBhcmFtcyh0aGlzLCBpbnB1dFZpZXcsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnRCdWZmZXIgPSBpbnB1dFZpZXcuc3ViYXJyYXkoaW5wdXRPZmZzZXQsIGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlSGV4Vmlld1tpXSA9IGludEJ1ZmZlcltpXSAmIDB4N0Y7XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGgrKztcclxuICAgICAgICAgICAgaWYgKChpbnRCdWZmZXJbaV0gJiAweDgwKSA9PT0gMHgwMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ZW1wVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYmxvY2tMZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ibG9ja0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRlbXBWaWV3W2ldID0gdGhpcy52YWx1ZUhleFZpZXdbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVIZXhWaWV3ID0gdGVtcFZpZXc7XHJcbiAgICAgICAgaWYgKChpbnRCdWZmZXJbdGhpcy5ibG9ja0xlbmd0aCAtIDFdICYgMHg4MCkgIT09IDB4MDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy52YWx1ZUhleFZpZXdbMF0gPT09IDB4MDApXHJcbiAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChcIk5lZWRsZXNzbHkgbG9uZyBmb3JtYXQgb2YgU0lEIGVuY29kaW5nXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmJsb2NrTGVuZ3RoIDw9IDgpXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVEZWMgPSBwdnV0aWxzX19uYW1lc3BhY2UudXRpbEZyb21CYXNlKHRoaXMudmFsdWVIZXhWaWV3LCA3KTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hleE9ubHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJUb28gYmlnIFNJRCBmb3IgZGVjb2RpbmcsIGhleCBvbmx5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGlucHV0T2Zmc2V0ICsgdGhpcy5ibG9ja0xlbmd0aCk7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWVCaWdJbnQodmFsdWUpIHtcclxuICAgICAgICBhc3NlcnRCaWdJbnQoKTtcclxuICAgICAgICBsZXQgYml0cyA9IEJpZ0ludCh2YWx1ZSkudG9TdHJpbmcoMik7XHJcbiAgICAgICAgd2hpbGUgKGJpdHMubGVuZ3RoICUgNykge1xyXG4gICAgICAgICAgICBiaXRzID0gXCIwXCIgKyBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpdHMubGVuZ3RoIC8gNyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBieXRlc1tpXSA9IHBhcnNlSW50KGJpdHMuc2xpY2UoaSAqIDcsIGkgKiA3ICsgNyksIDIpICsgKGkgKyAxIDwgYnl0ZXMubGVuZ3RoID8gMHg4MCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZyb21CRVIoYnl0ZXMuYnVmZmVyLCAwLCBieXRlcy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJWaWV3ID0gdGhpcy52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAodGhpcy5ibG9ja0xlbmd0aCAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gY3VyVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xyXG4gICAgICAgIGlmIChlbmNvZGVkQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRXJyb3IgZHVyaW5nIGVuY29kaW5nIFNJRCB2YWx1ZVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGVuY29kZWRCdWYuYnl0ZUxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gZW5jb2RlZFZpZXdbaV0gfCAweDgwO1xyXG4gICAgICAgICAgICByZXRWaWV3W2xlbl0gPSBlbmNvZGVkVmlld1tsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0VmlldztcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSGV4T25seSlcclxuICAgICAgICAgICAgcmVzdWx0ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0hleCh0aGlzLnZhbHVlSGV4Vmlldyk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmlyc3RTaWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzaWRWYWx1ZSA9IHRoaXMudmFsdWVEZWM7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZURlYyA8PSAzOSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjAuXCI7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZURlYyA8PSA3OSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBcIjEuXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZFZhbHVlIC09IDQwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gXCIyLlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRWYWx1ZSAtPSA4MDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkVmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlRGVjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlRGVjOiB0aGlzLnZhbHVlRGVjLFxyXG4gICAgICAgICAgICBpc0ZpcnN0U2lkOiB0aGlzLmlzRmlyc3RTaWQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Mb2NhbFNpZFZhbHVlQmxvY2suTkFNRSA9IFwic2lkQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayBleHRlbmRzIFZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IEVNUFRZX1NUUklORywgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbVN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnJvbUJFUihpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQsIGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdE9mZnNldCA9IGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIHdoaWxlIChpbnB1dExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3Qgc2lkQmxvY2sgPSBuZXcgTG9jYWxTaWRWYWx1ZUJsb2NrKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHNpZEJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIHJlc3VsdE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gc2lkQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHNpZEJsb2NrLmlzRmlyc3RTaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoICs9IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICBpbnB1dExlbmd0aCAtPSBzaWRCbG9jay5ibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHNpZEJsb2NrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdE9mZnNldDtcclxuICAgIH1cclxuICAgIHRvQkVSKHNpemVPbmx5KSB7XHJcbiAgICAgICAgY29uc3QgcmV0QnVmZmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUJ1ZiA9IHRoaXMudmFsdWVbaV0udG9CRVIoc2l6ZU9ubHkpO1xyXG4gICAgICAgICAgICBpZiAodmFsdWVCdWYuYnl0ZUxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMudmFsdWVbaV0uZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldEJ1ZmZlcnMucHVzaCh2YWx1ZUJ1Zik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb25jYXQocmV0QnVmZmVycyk7XHJcbiAgICB9XHJcbiAgICBmcm9tU3RyaW5nKHN0cmluZykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBbXTtcclxuICAgICAgICBsZXQgcG9zMSA9IDA7XHJcbiAgICAgICAgbGV0IHBvczIgPSAwO1xyXG4gICAgICAgIGxldCBzaWQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwb3MyID0gc3RyaW5nLmluZGV4T2YoXCIuXCIsIHBvczEpO1xyXG4gICAgICAgICAgICBpZiAocG9zMiA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEpO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzaWQgPSBzdHJpbmcuc3Vic3RyaW5nKHBvczEsIHBvczIpO1xyXG4gICAgICAgICAgICBwb3MxID0gcG9zMiArIDE7XHJcbiAgICAgICAgICAgIGlmIChmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IHRoaXMudmFsdWVbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgcGx1cyA9IDA7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNpZEJsb2NrLnZhbHVlRGVjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdXMgPSA0MDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVzID0gODA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU0lEID0gcGFyc2VJbnQoc2lkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VkU0lEKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBzaWRCbG9jay52YWx1ZURlYyA9IHBhcnNlZFNJRCArIHBsdXM7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaWRCbG9jayA9IG5ldyBMb2NhbFNpZFZhbHVlQmxvY2soKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaWQgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEJpZ0ludCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZFZhbHVlID0gQmlnSW50KHNpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkQmxvY2sudmFsdWVCaWdJbnQgPSBzaWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLnZhbHVlRGVjID0gcGFyc2VJbnQoc2lkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHNpZEJsb2NrLnZhbHVlRGVjKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZEJsb2NrLmlzRmlyc3RTaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZS5wdXNoKHNpZEJsb2NrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHBvczIgIT09IC0xKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXNIZXhPbmx5ID0gdGhpcy52YWx1ZVtpXS5pc0hleE9ubHk7XHJcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fS5gO1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICBzaWRTdHIgPSBgeyR7c2lkU3RyfX1gO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbaV0uaXNGaXJzdFNpZClcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBgMi57JHtzaWRTdHJ9IC0gODB9YDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkU3RyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzaWRTdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc2lkQXJyYXk6IFtdLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG9iamVjdC5zaWRBcnJheS5wdXNoKHRoaXMudmFsdWVbaV0udG9KU09OKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfVxyXG59XHJcbkxvY2FsT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2suTkFNRSA9IFwiT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2tcIjtcblxudmFyIF9hJG07XHJcbmNsYXNzIE9iamVjdElkZW50aWZpZXIgZXh0ZW5kcyBCYXNlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycywgTG9jYWxPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gNjtcclxuICAgIH1cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIHNldFZhbHVlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnZhbHVlQmxvY2sudG9TdHJpbmcoKSB8fCBcImVtcHR5XCJ9YDtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbl9hJG0gPSBPYmplY3RJZGVudGlmaWVyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLk9iamVjdElkZW50aWZpZXIgPSBfYSRtO1xyXG59KSgpO1xyXG5PYmplY3RJZGVudGlmaWVyLk5BTUUgPSBcIk9CSkVDVCBJREVOVElGSUVSXCI7XG5cbmNsYXNzIExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrIGV4dGVuZHMgSGV4QmxvY2soTG9jYWxCYXNlQmxvY2spIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWVEZWMgPSAwLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWVEZWMgPSB2YWx1ZURlYztcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGlucHV0VmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJQYXJhbXModGhpcywgaW5wdXRWaWV3LCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY29uc3QgaW50QnVmZmVyID0gaW5wdXRWaWV3LnN1YmFycmF5KGlucHV0T2Zmc2V0LCBpbnB1dE9mZnNldCArIGlucHV0TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0TGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0TGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUhleFZpZXdbaV0gPSBpbnRCdWZmZXJbaV0gJiAweDdGO1xyXG4gICAgICAgICAgICB0aGlzLmJsb2NrTGVuZ3RoKys7XHJcbiAgICAgICAgICAgIGlmICgoaW50QnVmZmVyW2ldICYgMHg4MCkgPT09IDB4MDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGVtcFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYmxvY2tMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgdGVtcFZpZXdbaV0gPSB0aGlzLnZhbHVlSGV4Vmlld1tpXTtcclxuICAgICAgICB0aGlzLnZhbHVlSGV4VmlldyA9IHRlbXBWaWV3O1xyXG4gICAgICAgIGlmICgoaW50QnVmZmVyW3RoaXMuYmxvY2tMZW5ndGggLSAxXSAmIDB4ODApICE9PSAweDAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIkVuZCBvZiBpbnB1dCByZWFjaGVkIGJlZm9yZSBtZXNzYWdlIHdhcyBmdWxseSBkZWNvZGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWVIZXhWaWV3WzBdID09PSAweDAwKVxyXG4gICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2goXCJOZWVkbGVzc2x5IGxvbmcgZm9ybWF0IG9mIFNJRCBlbmNvZGluZ1wiKTtcclxuICAgICAgICBpZiAodGhpcy5ibG9ja0xlbmd0aCA8PSA4KVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlRGVjID0gcHZ1dGlsc19fbmFtZXNwYWNlLnV0aWxGcm9tQmFzZSh0aGlzLnZhbHVlSGV4VmlldywgNyk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIZXhPbmx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiVG9vIGJpZyBTSUQgZm9yIGRlY29kaW5nLCBoZXggb25seVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChpbnB1dE9mZnNldCArIHRoaXMuYmxvY2tMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHkpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpIHtcclxuICAgICAgICAgICAgaWYgKHNpemVPbmx5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJWaWV3ID0gdGhpcy52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAodGhpcy5ibG9ja0xlbmd0aCAtIDEpOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gY3VyVmlld1tpXSB8IDB4ODA7XHJcbiAgICAgICAgICAgIHJldFZpZXdbdGhpcy5ibG9ja0xlbmd0aCAtIDFdID0gY3VyVmlld1t0aGlzLmJsb2NrTGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHJldHVybiByZXRWaWV3LmJ1ZmZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5jb2RlZEJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKHRoaXMudmFsdWVEZWMsIDcpO1xyXG4gICAgICAgIGlmIChlbmNvZGVkQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5lcnJvciA9IFwiRXJyb3IgZHVyaW5nIGVuY29kaW5nIFNJRCB2YWx1ZVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zi5ieXRlTGVuZ3RoKTtcclxuICAgICAgICBpZiAoIXNpemVPbmx5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEJ1Zik7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGVuY29kZWRCdWYuYnl0ZUxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgICAgICByZXRWaWV3W2ldID0gZW5jb2RlZFZpZXdbaV0gfCAweDgwO1xyXG4gICAgICAgICAgICByZXRWaWV3W2xlbl0gPSBlbmNvZGVkVmlld1tsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0Vmlldy5idWZmZXI7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBpZiAodGhpcy5pc0hleE9ubHkpXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkNvbnZlcnQuVG9IZXgodGhpcy52YWx1ZUhleFZpZXcpO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnZhbHVlRGVjLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlRGVjOiB0aGlzLnZhbHVlRGVjLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuTG9jYWxSZWxhdGl2ZVNpZFZhbHVlQmxvY2suTkFNRSA9IFwicmVsYXRpdmVTaWRCbG9ja1wiO1xuXG5jbGFzcyBMb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2sgZXh0ZW5kcyBWYWx1ZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgPSBFTVBUWV9TVFJJTkcsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IFtdO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGxldCByZXN1bHRPZmZzZXQgPSBpbnB1dE9mZnNldDtcclxuICAgICAgICB3aGlsZSAoaW5wdXRMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZEJsb2NrID0gbmV3IExvY2FsUmVsYXRpdmVTaWRWYWx1ZUJsb2NrKCk7XHJcbiAgICAgICAgICAgIHJlc3VsdE9mZnNldCA9IHNpZEJsb2NrLmZyb21CRVIoaW5wdXRCdWZmZXIsIHJlc3VsdE9mZnNldCwgaW5wdXRMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0T2Zmc2V0ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gc2lkQmxvY2suZXJyb3I7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmxvY2tMZW5ndGggKz0gc2lkQmxvY2suYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgIGlucHV0TGVuZ3RoIC09IHNpZEJsb2NrLmJsb2NrTGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgdG9CRVIoc2l6ZU9ubHksIHdyaXRlcikge1xyXG4gICAgICAgIGNvbnN0IHJldEJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVCdWYgPSB0aGlzLnZhbHVlW2ldLnRvQkVSKHNpemVPbmx5KTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlQnVmLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB0aGlzLnZhbHVlW2ldLmVycm9yO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0JVRkZFUjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXRCdWZmZXJzLnB1c2godmFsdWVCdWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29uY2F0KHJldEJ1ZmZlcnMpO1xyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gW107XHJcbiAgICAgICAgbGV0IHBvczEgPSAwO1xyXG4gICAgICAgIGxldCBwb3MyID0gMDtcclxuICAgICAgICBsZXQgc2lkID0gXCJcIjtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHBvczIgPSBzdHJpbmcuaW5kZXhPZihcIi5cIiwgcG9zMSk7XHJcbiAgICAgICAgICAgIGlmIChwb3MyID09PSAtMSlcclxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNpZCA9IHN0cmluZy5zdWJzdHJpbmcocG9zMSwgcG9zMik7XHJcbiAgICAgICAgICAgIHBvczEgPSBwb3MyICsgMTtcclxuICAgICAgICAgICAgY29uc3Qgc2lkQmxvY2sgPSBuZXcgTG9jYWxSZWxhdGl2ZVNpZFZhbHVlQmxvY2soKTtcclxuICAgICAgICAgICAgc2lkQmxvY2sudmFsdWVEZWMgPSBwYXJzZUludChzaWQsIDEwKTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHNpZEJsb2NrLnZhbHVlRGVjKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlLnB1c2goc2lkQmxvY2spO1xyXG4gICAgICAgIH0gd2hpbGUgKHBvczIgIT09IC0xKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBpc0hleE9ubHkgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXNIZXhPbmx5ID0gdGhpcy52YWx1ZVtpXS5pc0hleE9ubHk7XHJcbiAgICAgICAgICAgIGxldCBzaWRTdHIgPSB0aGlzLnZhbHVlW2ldLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChpICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYCR7cmVzdWx0fS5gO1xyXG4gICAgICAgICAgICBpZiAoaXNIZXhPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICBzaWRTdHIgPSBgeyR7c2lkU3RyfX1gO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNpZFN0cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc2lkU3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHNpZEFycmF5OiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgb2JqZWN0LnNpZEFycmF5LnB1c2godGhpcy52YWx1ZVtpXS50b0pTT04oKSk7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgIH1cclxufVxyXG5Mb2NhbFJlbGF0aXZlT2JqZWN0SWRlbnRpZmllclZhbHVlQmxvY2suTkFNRSA9IFwiUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkbDtcclxuY2xhc3MgUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyIGV4dGVuZHMgQmFzZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMsIExvY2FsUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyVmFsdWVCbG9jayk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTM7XHJcbiAgICB9XHJcbiAgICBnZXRWYWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay5mcm9tU3RyaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIG9uQXNjaWlFbmNvZGluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfSA6ICR7dGhpcy52YWx1ZUJsb2NrLnRvU3RyaW5nKCkgfHwgXCJlbXB0eVwifWA7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFZhbHVlKCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5fYSRsID0gUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlJlbGF0aXZlT2JqZWN0SWRlbnRpZmllciA9IF9hJGw7XHJcbn0pKCk7XHJcblJlbGF0aXZlT2JqZWN0SWRlbnRpZmllci5OQU1FID0gXCJSZWxhdGl2ZU9iamVjdElkZW50aWZpZXJcIjtcblxudmFyIF9hJGs7XHJcbmNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgQ29uc3RydWN0ZWQge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTY7XHJcbiAgICB9XHJcbn1cclxuX2EkayA9IFNlcXVlbmNlO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlNlcXVlbmNlID0gX2EkaztcclxufSkoKTtcclxuU2VxdWVuY2UuTkFNRSA9IFwiU0VRVUVOQ0VcIjtcblxudmFyIF9hJGo7XHJcbmNsYXNzIFNldCBleHRlbmRzIENvbnN0cnVjdGVkIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE3O1xyXG4gICAgfVxyXG59XHJcbl9hJGogPSBTZXQ7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuU2V0ID0gX2EkajtcclxufSkoKTtcclxuU2V0Lk5BTUUgPSBcIlNFVFwiO1xuXG5jbGFzcyBMb2NhbFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBIZXhCbG9jayhWYWx1ZUJsb2NrKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pc0hleE9ubHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSBFTVBUWV9TVFJJTkc7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4uc3VwZXIudG9KU09OKCksXHJcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuTG9jYWxTdHJpbmdWYWx1ZUJsb2NrLk5BTUUgPSBcIlN0cmluZ1ZhbHVlQmxvY2tcIjtcblxuY2xhc3MgTG9jYWxTaW1wbGVTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxTdHJpbmdWYWx1ZUJsb2NrIHtcclxufVxyXG5Mb2NhbFNpbXBsZVN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiU2ltcGxlU3RyaW5nVmFsdWVCbG9ja1wiO1xuXG5jbGFzcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIGV4dGVuZHMgQmFzZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzLCBMb2NhbFNpbXBsZVN0cmluZ1ZhbHVlQmxvY2spO1xyXG4gICAgfVxyXG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHN0ckxlbiA9IGlucHV0U3RyaW5nLmxlbmd0aDtcclxuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHN0ckxlbik7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJMZW47IGkrKylcclxuICAgICAgICAgICAgdmlld1tpXSA9IGlucHV0U3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gaW5wdXRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxTaW1wbGVTdHJpbmdCbG9jay5OQU1FID0gXCJTSU1QTEUgU1RSSU5HXCI7XG5cbmNsYXNzIExvY2FsVXRmOFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub1V0ZjhTdHJpbmcoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKGBFcnJvciBkdXJpbmcgXCJkZWNvZGVVUklDb21wb25lbnRcIjogJHtleH0sIHVzaW5nIHJhdyBzdHJpbmdgKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gcHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Ub0JpbmFyeShpbnB1dEJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnJvbVN0cmluZyhpbnB1dFN0cmluZykge1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBuZXcgVWludDhBcnJheShwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LkZyb21VdGY4U3RyaW5nKGlucHV0U3RyaW5nKSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlID0gaW5wdXRTdHJpbmc7XHJcbiAgICB9XHJcbn1cclxuTG9jYWxVdGY4U3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJVdGY4U3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkaTtcclxuY2xhc3MgVXRmOFN0cmluZyBleHRlbmRzIExvY2FsVXRmOFN0cmluZ1ZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTI7XHJcbiAgICB9XHJcbn1cclxuX2EkaSA9IFV0ZjhTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVXRmOFN0cmluZyA9IF9hJGk7XHJcbn0pKCk7XHJcblV0ZjhTdHJpbmcuTkFNRSA9IFwiVVRGOFN0cmluZ1wiO1xuXG5jbGFzcyBMb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2sgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGZyb21CdWZmZXIoaW5wdXRCdWZmZXIpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5Db252ZXJ0LlRvVXRmMTZTdHJpbmcoaW5wdXRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGlucHV0QnVmZmVyKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWUgPSBpbnB1dFN0cmluZztcclxuICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocHZ0c3V0aWxzX19uYW1lc3BhY2UuQ29udmVydC5Gcm9tVXRmMTZTdHJpbmcoaW5wdXRTdHJpbmcpKTtcclxuICAgIH1cclxufVxyXG5Mb2NhbEJtcFN0cmluZ1ZhbHVlQmxvY2suTkFNRSA9IFwiQm1wU3RyaW5nVmFsdWVCbG9ja1wiO1xuXG52YXIgX2EkaDtcclxuY2xhc3MgQm1wU3RyaW5nIGV4dGVuZHMgTG9jYWxCbXBTdHJpbmdWYWx1ZUJsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgLi4ucGFyYW1ldGVycyB9ID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzMDtcclxuICAgIH1cclxufVxyXG5fYSRoID0gQm1wU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkJtcFN0cmluZyA9IF9hJGg7XHJcbn0pKCk7XHJcbkJtcFN0cmluZy5OQU1FID0gXCJCTVBTdHJpbmdcIjtcblxuY2xhc3MgTG9jYWxVbml2ZXJzYWxTdHJpbmdWYWx1ZUJsb2NrIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBmcm9tQnVmZmVyKGlucHV0QnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgY29weUJ1ZmZlciA9IEFycmF5QnVmZmVyLmlzVmlldyhpbnB1dEJ1ZmZlcikgPyBpbnB1dEJ1ZmZlci5zbGljZSgpLmJ1ZmZlciA6IGlucHV0QnVmZmVyLnNsaWNlKDApO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlVmlldyA9IG5ldyBVaW50OEFycmF5KGNvcHlCdWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVWaWV3Lmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIHZhbHVlVmlld1tpXSA9IHZhbHVlVmlld1tpICsgM107XHJcbiAgICAgICAgICAgIHZhbHVlVmlld1tpICsgMV0gPSB2YWx1ZVZpZXdbaSArIDJdO1xyXG4gICAgICAgICAgICB2YWx1ZVZpZXdbaSArIDJdID0gMHgwMDtcclxuICAgICAgICAgICAgdmFsdWVWaWV3W2kgKyAzXSA9IDB4MDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQzMkFycmF5KGNvcHlCdWZmZXIpKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzdHJMZW5ndGggPSBpbnB1dFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgdmFsdWVIZXhWaWV3ID0gdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHN0ckxlbmd0aCAqIDQpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29kZUJ1ZiA9IHB2dXRpbHNfX25hbWVzcGFjZS51dGlsVG9CYXNlKGlucHV0U3RyaW5nLmNoYXJDb2RlQXQoaSksIDgpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlVmlldyA9IG5ldyBVaW50OEFycmF5KGNvZGVCdWYpO1xyXG4gICAgICAgICAgICBpZiAoY29kZVZpZXcubGVuZ3RoID4gNClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBjb25zdCBkaWYgPSA0IC0gY29kZVZpZXcubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gKGNvZGVWaWV3Lmxlbmd0aCAtIDEpOyBqID49IDA7IGotLSlcclxuICAgICAgICAgICAgICAgIHZhbHVlSGV4Vmlld1tpICogNCArIGogKyBkaWZdID0gY29kZVZpZXdbal07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZSA9IGlucHV0U3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbkxvY2FsVW5pdmVyc2FsU3RyaW5nVmFsdWVCbG9jay5OQU1FID0gXCJVbml2ZXJzYWxTdHJpbmdWYWx1ZUJsb2NrXCI7XG5cbnZhciBfYSRnO1xyXG5jbGFzcyBVbml2ZXJzYWxTdHJpbmcgZXh0ZW5kcyBMb2NhbFVuaXZlcnNhbFN0cmluZ1ZhbHVlQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IoeyAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI4O1xyXG4gICAgfVxyXG59XHJcbl9hJGcgPSBVbml2ZXJzYWxTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVW5pdmVyc2FsU3RyaW5nID0gX2EkZztcclxufSkoKTtcclxuVW5pdmVyc2FsU3RyaW5nLk5BTUUgPSBcIlVuaXZlcnNhbFN0cmluZ1wiO1xuXG52YXIgX2EkZjtcclxuY2xhc3MgTnVtZXJpY1N0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMTg7XHJcbiAgICB9XHJcbn1cclxuX2EkZiA9IE51bWVyaWNTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuTnVtZXJpY1N0cmluZyA9IF9hJGY7XHJcbn0pKCk7XHJcbk51bWVyaWNTdHJpbmcuTkFNRSA9IFwiTnVtZXJpY1N0cmluZ1wiO1xuXG52YXIgX2EkZTtcclxuY2xhc3MgUHJpbnRhYmxlU3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAxOTtcclxuICAgIH1cclxufVxyXG5fYSRlID0gUHJpbnRhYmxlU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlByaW50YWJsZVN0cmluZyA9IF9hJGU7XHJcbn0pKCk7XHJcblByaW50YWJsZVN0cmluZy5OQU1FID0gXCJQcmludGFibGVTdHJpbmdcIjtcblxudmFyIF9hJGQ7XHJcbmNsYXNzIFRlbGV0ZXhTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDIwO1xyXG4gICAgfVxyXG59XHJcbl9hJGQgPSBUZWxldGV4U3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlRlbGV0ZXhTdHJpbmcgPSBfYSRkO1xyXG59KSgpO1xyXG5UZWxldGV4U3RyaW5nLk5BTUUgPSBcIlRlbGV0ZXhTdHJpbmdcIjtcblxudmFyIF9hJGM7XHJcbmNsYXNzIFZpZGVvdGV4U3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMTtcclxuICAgIH1cclxufVxyXG5fYSRjID0gVmlkZW90ZXhTdHJpbmc7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVmlkZW90ZXhTdHJpbmcgPSBfYSRjO1xyXG59KSgpO1xyXG5WaWRlb3RleFN0cmluZy5OQU1FID0gXCJWaWRlb3RleFN0cmluZ1wiO1xuXG52YXIgX2EkYjtcclxuY2xhc3MgSUE1U3RyaW5nIGV4dGVuZHMgTG9jYWxTaW1wbGVTdHJpbmdCbG9jayB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyMjtcclxuICAgIH1cclxufVxyXG5fYSRiID0gSUE1U3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLklBNVN0cmluZyA9IF9hJGI7XHJcbn0pKCk7XHJcbklBNVN0cmluZy5OQU1FID0gXCJJQTVTdHJpbmdcIjtcblxudmFyIF9hJGE7XHJcbmNsYXNzIEdyYXBoaWNTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI1O1xyXG4gICAgfVxyXG59XHJcbl9hJGEgPSBHcmFwaGljU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdyYXBoaWNTdHJpbmcgPSBfYSRhO1xyXG59KSgpO1xyXG5HcmFwaGljU3RyaW5nLk5BTUUgPSBcIkdyYXBoaWNTdHJpbmdcIjtcblxudmFyIF9hJDk7XHJcbmNsYXNzIFZpc2libGVTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI2O1xyXG4gICAgfVxyXG59XHJcbl9hJDkgPSBWaXNpYmxlU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLlZpc2libGVTdHJpbmcgPSBfYSQ5O1xyXG59KSgpO1xyXG5WaXNpYmxlU3RyaW5nLk5BTUUgPSBcIlZpc2libGVTdHJpbmdcIjtcblxudmFyIF9hJDg7XHJcbmNsYXNzIEdlbmVyYWxTdHJpbmcgZXh0ZW5kcyBMb2NhbFNpbXBsZVN0cmluZ0Jsb2NrIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDI3O1xyXG4gICAgfVxyXG59XHJcbl9hJDggPSBHZW5lcmFsU3RyaW5nO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdlbmVyYWxTdHJpbmcgPSBfYSQ4O1xyXG59KSgpO1xyXG5HZW5lcmFsU3RyaW5nLk5BTUUgPSBcIkdlbmVyYWxTdHJpbmdcIjtcblxudmFyIF9hJDc7XHJcbmNsYXNzIENoYXJhY3RlclN0cmluZyBleHRlbmRzIExvY2FsU2ltcGxlU3RyaW5nQmxvY2sge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMjk7XHJcbiAgICB9XHJcbn1cclxuX2EkNyA9IENoYXJhY3RlclN0cmluZztcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5DaGFyYWN0ZXJTdHJpbmcgPSBfYSQ3O1xyXG59KSgpO1xyXG5DaGFyYWN0ZXJTdHJpbmcuTkFNRSA9IFwiQ2hhcmFjdGVyU3RyaW5nXCI7XG5cbnZhciBfYSQ2O1xyXG5jbGFzcyBVVENUaW1lIGV4dGVuZHMgVmlzaWJsZVN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCB2YWx1ZURhdGUsIC4uLnBhcmFtZXRlcnMgfSA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy55ZWFyID0gMDtcclxuICAgICAgICB0aGlzLm1vbnRoID0gMDtcclxuICAgICAgICB0aGlzLmRheSA9IDA7XHJcbiAgICAgICAgdGhpcy5ob3VyID0gMDtcclxuICAgICAgICB0aGlzLm1pbnV0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zZWNvbmQgPSAwO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVCbG9jay52YWx1ZUhleFZpZXdbaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWVEYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJvbURhdGUodmFsdWVEYXRlKTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMudG9CdWZmZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDIzO1xyXG4gICAgfVxyXG4gICAgZnJvbUJ1ZmZlcihpbnB1dEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuZnJvbVN0cmluZyhTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpKSk7XHJcbiAgICB9XHJcbiAgICB0b0J1ZmZlcigpIHtcclxuICAgICAgICBjb25zdCBzdHIgPSB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHN0ci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICB2aWV3W2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGZyb21EYXRlKGlucHV0RGF0ZSkge1xyXG4gICAgICAgIHRoaXMueWVhciA9IGlucHV0RGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgIHRoaXMubW9udGggPSBpbnB1dERhdGUuZ2V0VVRDTW9udGgoKSArIDE7XHJcbiAgICAgICAgdGhpcy5kYXkgPSBpbnB1dERhdGUuZ2V0VVRDRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaG91ciA9IGlucHV0RGF0ZS5nZXRVVENIb3VycygpO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gaW5wdXREYXRlLmdldFVUQ01pbnV0ZXMoKTtcclxuICAgICAgICB0aGlzLnNlY29uZCA9IGlucHV0RGF0ZS5nZXRVVENTZWNvbmRzKCk7XHJcbiAgICB9XHJcbiAgICB0b0RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIChuZXcgRGF0ZShEYXRlLlVUQyh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQpKSk7XHJcbiAgICB9XHJcbiAgICBmcm9tU3RyaW5nKGlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VyID0gLyhcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KVovaWc7XHJcbiAgICAgICAgY29uc3QgcGFyc2VyQXJyYXkgPSBwYXJzZXIuZXhlYyhpbnB1dFN0cmluZyk7XHJcbiAgICAgICAgaWYgKHBhcnNlckFycmF5ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChwYXJzZXJBcnJheVsxXSwgMTApO1xyXG4gICAgICAgIGlmICh5ZWFyID49IDUwKVxyXG4gICAgICAgICAgICB0aGlzLnllYXIgPSAxOTAwICsgeWVhcjtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMueWVhciA9IDIwMDAgKyB5ZWFyO1xyXG4gICAgICAgIHRoaXMubW9udGggPSBwYXJzZUludChwYXJzZXJBcnJheVsyXSwgMTApO1xyXG4gICAgICAgIHRoaXMuZGF5ID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbM10sIDEwKTtcclxuICAgICAgICB0aGlzLmhvdXIgPSBwYXJzZUludChwYXJzZXJBcnJheVs0XSwgMTApO1xyXG4gICAgICAgIHRoaXMubWludXRlID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbNV0sIDEwKTtcclxuICAgICAgICB0aGlzLnNlY29uZCA9IHBhcnNlSW50KHBhcnNlckFycmF5WzZdLCAxMCk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZyhlbmNvZGluZyA9IFwiaXNvXCIpIHtcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IFwiaXNvXCIpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0QXJyYXkgPSBuZXcgQXJyYXkoNyk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzBdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcigoKHRoaXMueWVhciA8IDIwMDApID8gKHRoaXMueWVhciAtIDE5MDApIDogKHRoaXMueWVhciAtIDIwMDApKSwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzFdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1vbnRoLCAyKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXlbMl0gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuZGF5LCAyKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXlbM10gPSBwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuaG91ciwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzRdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLm1pbnV0ZSwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzVdID0gcHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnNlY29uZCwgMik7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5WzZdID0gXCJaXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRBcnJheS5qb2luKFwiXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoZW5jb2RpbmcpO1xyXG4gICAgfVxyXG4gICAgb25Bc2NpaUVuY29kaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9IDogJHt0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YDtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgeWVhcjogdGhpcy55ZWFyLFxyXG4gICAgICAgICAgICBtb250aDogdGhpcy5tb250aCxcclxuICAgICAgICAgICAgZGF5OiB0aGlzLmRheSxcclxuICAgICAgICAgICAgaG91cjogdGhpcy5ob3VyLFxyXG4gICAgICAgICAgICBtaW51dGU6IHRoaXMubWludXRlLFxyXG4gICAgICAgICAgICBzZWNvbmQ6IHRoaXMuc2Vjb25kLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuX2EkNiA9IFVUQ1RpbWU7XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuVVRDVGltZSA9IF9hJDY7XHJcbn0pKCk7XHJcblVUQ1RpbWUuTkFNRSA9IFwiVVRDVGltZVwiO1xuXG52YXIgX2EkNTtcclxuY2xhc3MgR2VuZXJhbGl6ZWRUaW1lIGV4dGVuZHMgVVRDVGltZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICB2YXIgX2I7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgKF9iID0gdGhpcy5taWxsaXNlY29uZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKHRoaXMubWlsbGlzZWNvbmQgPSAwKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAyNDtcclxuICAgIH1cclxuICAgIGZyb21EYXRlKGlucHV0RGF0ZSkge1xyXG4gICAgICAgIHN1cGVyLmZyb21EYXRlKGlucHV0RGF0ZSk7XHJcbiAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IGlucHV0RGF0ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcclxuICAgIH1cclxuICAgIHRvRGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5LCB0aGlzLmhvdXIsIHRoaXMubWludXRlLCB0aGlzLnNlY29uZCwgdGhpcy5taWxsaXNlY29uZCkpKTtcclxuICAgIH1cclxuICAgIGZyb21TdHJpbmcoaW5wdXRTdHJpbmcpIHtcclxuICAgICAgICBsZXQgaXNVVEMgPSBmYWxzZTtcclxuICAgICAgICBsZXQgdGltZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgbGV0IGRhdGVUaW1lU3RyaW5nID0gXCJcIjtcclxuICAgICAgICBsZXQgZnJhY3Rpb25QYXJ0ID0gMDtcclxuICAgICAgICBsZXQgcGFyc2VyO1xyXG4gICAgICAgIGxldCBob3VyRGlmZmVyZW5jZSA9IDA7XHJcbiAgICAgICAgbGV0IG1pbnV0ZURpZmZlcmVuY2UgPSAwO1xyXG4gICAgICAgIGlmIChpbnB1dFN0cmluZ1tpbnB1dFN0cmluZy5sZW5ndGggLSAxXSA9PT0gXCJaXCIpIHtcclxuICAgICAgICAgICAgdGltZVN0cmluZyA9IGlucHV0U3RyaW5nLnN1YnN0cmluZygwLCBpbnB1dFN0cmluZy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgaXNVVEMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gbmV3IE51bWJlcihpbnB1dFN0cmluZ1tpbnB1dFN0cmluZy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihudW1iZXIudmFsdWVPZigpKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgdGltZVN0cmluZyA9IGlucHV0U3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVVEMpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVTdHJpbmcuaW5kZXhPZihcIitcIikgIT09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICBpZiAodGltZVN0cmluZy5pbmRleE9mKFwiLVwiKSAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlUG9zaXRpb24gPSB0aW1lU3RyaW5nLmluZGV4T2YoXCIrXCIpO1xyXG4gICAgICAgICAgICBsZXQgZGlmZmVyZW5jZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlUG9zaXRpb24gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlUG9zaXRpb24gPSB0aW1lU3RyaW5nLmluZGV4T2YoXCItXCIpO1xyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlUG9zaXRpb24gIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmZXJlbmNlU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoZGlmZmVyZW5jZVBvc2l0aW9uICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aW1lU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoMCwgZGlmZmVyZW5jZVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICgoZGlmZmVyZW5jZVN0cmluZy5sZW5ndGggIT09IDIpICYmIChkaWZmZXJlbmNlU3RyaW5nLmxlbmd0aCAhPT0gNCkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG51bWJlciA9IHBhcnNlSW50KGRpZmZlcmVuY2VTdHJpbmcuc3Vic3RyaW5nKDAsIDIpLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlT2YoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgaG91ckRpZmZlcmVuY2UgPSBtdWx0aXBsaWVyICogbnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2VTdHJpbmcubGVuZ3RoID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoZGlmZmVyZW5jZVN0cmluZy5zdWJzdHJpbmcoMiwgNCksIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4obnVtYmVyLnZhbHVlT2YoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW51dGVEaWZmZXJlbmNlID0gbXVsdGlwbGllciAqIG51bWJlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZnJhY3Rpb25Qb2ludFBvc2l0aW9uID0gdGltZVN0cmluZy5pbmRleE9mKFwiLlwiKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uID09PSAtMSlcclxuICAgICAgICAgICAgZnJhY3Rpb25Qb2ludFBvc2l0aW9uID0gdGltZVN0cmluZy5pbmRleE9mKFwiLFwiKTtcclxuICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFjdGlvblBhcnRDaGVjayA9IG5ldyBOdW1iZXIoYDAke3RpbWVTdHJpbmcuc3Vic3RyaW5nKGZyYWN0aW9uUG9pbnRQb3NpdGlvbil9YCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihmcmFjdGlvblBhcnRDaGVjay52YWx1ZU9mKCkpKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICBmcmFjdGlvblBhcnQgPSBmcmFjdGlvblBhcnRDaGVjay52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGRhdGVUaW1lU3RyaW5nID0gdGltZVN0cmluZy5zdWJzdHJpbmcoMCwgZnJhY3Rpb25Qb2ludFBvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBkYXRlVGltZVN0cmluZyA9IHRpbWVTdHJpbmc7XHJcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gOCk6XHJcbiAgICAgICAgICAgICAgICBwYXJzZXIgPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgaW5wdXQgc3RyaW5nIGZvciBjb252ZXJzaW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gMTApOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gLyhcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pL2lnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYWN0aW9uUG9pbnRQb3NpdGlvbiAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnJhY3Rpb25SZXN1bHQgPSA2MCAqIGZyYWN0aW9uUGFydDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZSA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWN0aW9uUmVzdWx0ID0gNjAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLm1pbnV0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWNvbmQgPSBNYXRoLmZsb29yKGZyYWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblJlc3VsdCA9IDEwMDAgKiAoZnJhY3Rpb25SZXN1bHQgLSB0aGlzLnNlY29uZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZCA9IE1hdGguZmxvb3IoZnJhY3Rpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgKGRhdGVUaW1lU3RyaW5nLmxlbmd0aCA9PT0gMTIpOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VyID0gLyhcXGR7NH0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkvaWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdGlvblJlc3VsdCA9IDYwICogZnJhY3Rpb25QYXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhY3Rpb25SZXN1bHQgPSAxMDAwICogKGZyYWN0aW9uUmVzdWx0IC0gdGhpcy5zZWNvbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBNYXRoLmZsb29yKGZyYWN0aW9uUmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIChkYXRlVGltZVN0cmluZy5sZW5ndGggPT09IDE0KTpcclxuICAgICAgICAgICAgICAgIHBhcnNlciA9IC8oXFxkezR9KShcXGR7Mn0pKFxcZHsyfSkoXFxkezJ9KShcXGR7Mn0pKFxcZHsyfSkvaWc7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhY3Rpb25Qb2ludFBvc2l0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYWN0aW9uUmVzdWx0ID0gMTAwMCAqIGZyYWN0aW9uUGFydDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gTWF0aC5mbG9vcihmcmFjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyc2VyQXJyYXkgPSBwYXJzZXIuZXhlYyhkYXRlVGltZVN0cmluZyk7XHJcbiAgICAgICAgaWYgKHBhcnNlckFycmF5ID09PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBpbnB1dCBzdHJpbmcgZm9yIGNvbnZlcnNpb25cIik7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBwYXJzZXJBcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGggPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF5ID0gcGFyc2VJbnQocGFyc2VyQXJyYXlbal0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvdXIgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApICsgaG91ckRpZmZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taW51dGUgPSBwYXJzZUludChwYXJzZXJBcnJheVtqXSwgMTApICsgbWludXRlRGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlY29uZCA9IHBhcnNlSW50KHBhcnNlckFycmF5W2pdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGlucHV0IHN0cmluZyBmb3IgY29udmVyc2lvblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVVEMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBEYXRlID0gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRheSwgdGhpcy5ob3VyLCB0aGlzLm1pbnV0ZSwgdGhpcy5zZWNvbmQsIHRoaXMubWlsbGlzZWNvbmQpO1xyXG4gICAgICAgICAgICB0aGlzLnllYXIgPSB0ZW1wRGF0ZS5nZXRVVENGdWxsWWVhcigpO1xyXG4gICAgICAgICAgICB0aGlzLm1vbnRoID0gdGVtcERhdGUuZ2V0VVRDTW9udGgoKTtcclxuICAgICAgICAgICAgdGhpcy5kYXkgPSB0ZW1wRGF0ZS5nZXRVVENEYXkoKTtcclxuICAgICAgICAgICAgdGhpcy5ob3VyID0gdGVtcERhdGUuZ2V0VVRDSG91cnMoKTtcclxuICAgICAgICAgICAgdGhpcy5taW51dGUgPSB0ZW1wRGF0ZS5nZXRVVENNaW51dGVzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kID0gdGVtcERhdGUuZ2V0VVRDU2Vjb25kcygpO1xyXG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kID0gdGVtcERhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoZW5jb2RpbmcgPSBcImlzb1wiKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSBcImlzb1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dEFycmF5ID0gW107XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnllYXIsIDQpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubW9udGgsIDIpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMuZGF5LCAyKSk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLmhvdXIsIDIpKTtcclxuICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChwdnV0aWxzX19uYW1lc3BhY2UucGFkTnVtYmVyKHRoaXMubWludXRlLCAyKSk7XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2gocHZ1dGlsc19fbmFtZXNwYWNlLnBhZE51bWJlcih0aGlzLnNlY29uZCwgMikpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5taWxsaXNlY29uZCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0QXJyYXkucHVzaChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXRBcnJheS5wdXNoKHB2dXRpbHNfX25hbWVzcGFjZS5wYWROdW1iZXIodGhpcy5taWxsaXNlY29uZCwgMykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG91dHB1dEFycmF5LnB1c2goXCJaXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0QXJyYXkuam9pbihcIlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKGVuY29kaW5nKTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAuLi5zdXBlci50b0pTT04oKSxcclxuICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoaXMubWlsbGlzZWNvbmQsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5fYSQ1ID0gR2VuZXJhbGl6ZWRUaW1lO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkdlbmVyYWxpemVkVGltZSA9IF9hJDU7XHJcbn0pKCk7XHJcbkdlbmVyYWxpemVkVGltZS5OQU1FID0gXCJHZW5lcmFsaXplZFRpbWVcIjtcblxudmFyIF9hJDQ7XHJcbmNsYXNzIERBVEUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDMxO1xyXG4gICAgfVxyXG59XHJcbl9hJDQgPSBEQVRFO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkRBVEUgPSBfYSQ0O1xyXG59KSgpO1xyXG5EQVRFLk5BTUUgPSBcIkRBVEVcIjtcblxudmFyIF9hJDM7XHJcbmNsYXNzIFRpbWVPZkRheSBleHRlbmRzIFV0ZjhTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMzI7XHJcbiAgICB9XHJcbn1cclxuX2EkMyA9IFRpbWVPZkRheTtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5UaW1lT2ZEYXkgPSBfYSQzO1xyXG59KSgpO1xyXG5UaW1lT2ZEYXkuTkFNRSA9IFwiVGltZU9mRGF5XCI7XG5cbnZhciBfYSQyO1xyXG5jbGFzcyBEYXRlVGltZSBleHRlbmRzIFV0ZjhTdHJpbmcge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIocGFyYW1ldGVycyk7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ0NsYXNzID0gMTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnTnVtYmVyID0gMzM7XHJcbiAgICB9XHJcbn1cclxuX2EkMiA9IERhdGVUaW1lO1xyXG4oKCkgPT4ge1xyXG4gICAgdHlwZVN0b3JlLkRhdGVUaW1lID0gX2EkMjtcclxufSkoKTtcclxuRGF0ZVRpbWUuTkFNRSA9IFwiRGF0ZVRpbWVcIjtcblxudmFyIF9hJDE7XHJcbmNsYXNzIER1cmF0aW9uIGV4dGVuZHMgVXRmOFN0cmluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcclxuICAgICAgICBzdXBlcihwYXJhbWV0ZXJzKTtcclxuICAgICAgICB0aGlzLmlkQmxvY2sudGFnQ2xhc3MgPSAxO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdOdW1iZXIgPSAzNDtcclxuICAgIH1cclxufVxyXG5fYSQxID0gRHVyYXRpb247XHJcbigoKSA9PiB7XHJcbiAgICB0eXBlU3RvcmUuRHVyYXRpb24gPSBfYSQxO1xyXG59KSgpO1xyXG5EdXJhdGlvbi5OQU1FID0gXCJEdXJhdGlvblwiO1xuXG52YXIgX2E7XHJcbmNsYXNzIFRJTUUgZXh0ZW5kcyBVdGY4U3RyaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMuaWRCbG9jay50YWdDbGFzcyA9IDE7XHJcbiAgICAgICAgdGhpcy5pZEJsb2NrLnRhZ051bWJlciA9IDE0O1xyXG4gICAgfVxyXG59XHJcbl9hID0gVElNRTtcclxuKCgpID0+IHtcclxuICAgIHR5cGVTdG9yZS5USU1FID0gX2E7XHJcbn0pKCk7XHJcblRJTUUuTkFNRSA9IFwiVElNRVwiO1xuXG5jbGFzcyBBbnkge1xyXG4gICAgY29uc3RydWN0b3IoeyBuYW1lID0gRU1QVFlfU1RSSU5HLCBvcHRpb25hbCA9IGZhbHNlLCB9ID0ge30pIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSBvcHRpb25hbDtcclxuICAgIH1cclxufVxuXG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBBbnkge1xyXG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSA9IFtdLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSZXBlYXRlZCBleHRlbmRzIEFueSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlID0gbmV3IEFueSgpLCBsb2NhbCA9IGZhbHNlLCAuLi5wYXJhbWV0ZXJzIH0gPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUmF3RGF0YSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgPSBFTVBUWV9WSUVXIH0gPSB7fSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuc2xpY2UoKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVZpZXcgPSBwdnRzdXRpbHNfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGZyb21CRVIoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGVuZExlbmd0aCA9IGlucHV0T2Zmc2V0ICsgaW5wdXRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5kYXRhVmlldyA9IHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpLnN1YmFycmF5KGlucHV0T2Zmc2V0LCBlbmRMZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBlbmRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICB0b0JFUihzaXplT25seSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LnNsaWNlKCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLCBpbnB1dFNjaGVtYSkge1xyXG4gICAgaWYgKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgQ2hvaWNlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbnB1dFNjaGVtYS52YWx1ZS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlU2NoZW1hKHJvb3QsIGlucHV0RGF0YSwgaW5wdXRTY2hlbWEudmFsdWVbal0pO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnZlcmlmaWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogXCJXcm9uZyB2YWx1ZXMgZm9yIENob2ljZSB0eXBlXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcclxuICAgICAgICAgICAgICAgIF9yZXN1bHQubmFtZSA9IGlucHV0U2NoZW1hLm5hbWU7XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYSBpbnN0YW5jZW9mIEFueSkge1xyXG4gICAgICAgIGlmIChpbnB1dFNjaGVtYS5oYXNPd25Qcm9wZXJ0eShOQU1FKSlcclxuICAgICAgICAgICAgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXSA9IGlucHV0RGF0YTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogdHJ1ZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgocm9vdCBpbnN0YW5jZW9mIE9iamVjdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3Jvbmcgcm9vdCBvYmplY3RcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoaW5wdXREYXRhIGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBkYXRhXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoKGlucHV0U2NoZW1hIGluc3RhbmNlb2YgT2JqZWN0KSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoSURfQkxPQ0sgaW4gaW5wdXRTY2hlbWEpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKChGUk9NX0JFUiBpbiBpbnB1dFNjaGVtYS5pZEJsb2NrKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICgoVE9fQkVSIGluIGlucHV0U2NoZW1hLmlkQmxvY2spID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZW5jb2RlZElkID0gaW5wdXRTY2hlbWEuaWRCbG9jay50b0JFUihmYWxzZSk7XHJcbiAgICBpZiAoZW5jb2RlZElkLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJFcnJvciBlbmNvZGluZyBpZEJsb2NrIGZvciBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlY29kZWRPZmZzZXQgPSBpbnB1dFNjaGVtYS5pZEJsb2NrLmZyb21CRVIoZW5jb2RlZElkLCAwLCBlbmNvZGVkSWQuYnl0ZUxlbmd0aCk7XHJcbiAgICBpZiAoZGVjb2RlZE9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJFcnJvciBkZWNvZGluZyBpZEJsb2NrIGZvciBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmhhc093blByb3BlcnR5KFRBR19DTEFTUykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay50YWdDbGFzcyAhPT0gaW5wdXREYXRhLmlkQmxvY2sudGFnQ2xhc3MpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay5oYXNPd25Qcm9wZXJ0eShUQUdfTlVNQkVSKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogeyBlcnJvcjogXCJXcm9uZyBBU04uMSBzY2hlbWFcIiB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLnRhZ051bWJlciAhPT0gaW5wdXREYXRhLmlkQmxvY2sudGFnTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaGFzT3duUHJvcGVydHkoSVNfQ09OU1RSVUNURUQpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYVwiIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0U2NoZW1hLmlkQmxvY2suaXNDb25zdHJ1Y3RlZCAhPT0gaW5wdXREYXRhLmlkQmxvY2suaXNDb25zdHJ1Y3RlZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmICghKElTX0hFWF9PTkxZIGluIGlucHV0U2NoZW1hLmlkQmxvY2spKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEuaWRCbG9jay5pc0hleE9ubHkgIT09IGlucHV0RGF0YS5pZEJsb2NrLmlzSGV4T25seSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChpbnB1dFNjaGVtYS5pZEJsb2NrLmlzSGV4T25seSkge1xyXG4gICAgICAgIGlmICgoVkFMVUVfSEVYX1ZJRVcgaW4gaW5wdXRTY2hlbWEuaWRCbG9jaykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHsgZXJyb3I6IFwiV3JvbmcgQVNOLjEgc2NoZW1hXCIgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY2hlbWFWaWV3ID0gaW5wdXRTY2hlbWEuaWRCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgY29uc3QgYXNuMVZpZXcgPSBpbnB1dERhdGEuaWRCbG9jay52YWx1ZUhleFZpZXc7XHJcbiAgICAgICAgaWYgKHNjaGVtYVZpZXcubGVuZ3RoICE9PSBhc24xVmlldy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVtYVZpZXcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVZpZXdbaV0gIT09IGFzbjFWaWV3WzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgIGlucHV0U2NoZW1hLm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIEVNUFRZX1NUUklORyk7XHJcbiAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpXHJcbiAgICAgICAgICAgIHJvb3RbaW5wdXRTY2hlbWEubmFtZV0gPSBpbnB1dERhdGE7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEgaW5zdGFuY2VvZiB0eXBlU3RvcmUuQ29uc3RydWN0ZWQpIHtcclxuICAgICAgICBsZXQgYWRtaXNzaW9uID0gMDtcclxuICAgICAgICBsZXQgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDoge1xyXG4gICAgICAgICAgICAgICAgZXJyb3I6IFwiVW5rbm93biBlcnJvclwiLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbWF4TGVuZ3RoID0gaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgaWYgKG1heExlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0gaW5zdGFuY2VvZiBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgbWF4TGVuZ3RoID0gaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoID09PSAwKSAmJlxyXG4gICAgICAgICAgICAoaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZS5sZW5ndGggIT09IDApKSB7XHJcbiAgICAgICAgICAgIGxldCBfb3B0aW9uYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWUubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICBfb3B0aW9uYWwgPSBfb3B0aW9uYWwgJiYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0ub3B0aW9uYWwgfHwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoX29wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByb290W2lucHV0U2NoZW1hLm5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBvYmplY3QgbGVuZ3RoXCI7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoKGkgLSBhZG1pc3Npb24pID49IGlucHV0RGF0YS52YWx1ZUJsb2NrLnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0ub3B0aW9uYWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX3Jlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJvb3RcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QuZXJyb3IgPSBcIkluY29uc2lzdGVudCBsZW5ndGggYmV0d2VlbiBBU04uMSBkYXRhIGFuZCBzY2hlbWFcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzdWx0Lm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0gaW5zdGFuY2VvZiBSZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaV0sIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRtaXNzaW9uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChOQU1FIGluIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0pICYmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWUubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFycmF5Um9vdCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKExPQ0FMIGluIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbMF0pICYmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLmxvY2FsKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdCA9IGlucHV0RGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlSb290ID0gcm9vdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcnJheVJvb3RbaW5wdXRTY2hlbWEudmFsdWVCbG9jay52YWx1ZVswXS5uYW1lXSA9PT0gXCJ1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Um9vdFtpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlWzBdLm5hbWVdLnB1c2goaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbXBhcmVTY2hlbWEocm9vdCwgaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVbaSAtIGFkbWlzc2lvbl0sIGlucHV0U2NoZW1hLnZhbHVlQmxvY2sudmFsdWVbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQudmVyaWZpZWQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlW2ldLm9wdGlvbmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRtaXNzaW9uKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdC52ZXJpZmllZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY29uc3QgX3Jlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRTY2hlbWEubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXRTY2hlbWEubmFtZSA9IGlucHV0U2NoZW1hLm5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgRU1QVFlfU1RSSU5HKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJvb3RbaW5wdXRTY2hlbWEubmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdC5uYW1lID0gaW5wdXRTY2hlbWEubmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVyaWZpZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHJlc3VsdDogcm9vdFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hICYmXHJcbiAgICAgICAgKFZBTFVFX0hFWF9WSUVXIGluIGlucHV0RGF0YS52YWx1ZUJsb2NrKSkge1xyXG4gICAgICAgIGNvbnN0IGFzbjEgPSBsb2NhbEZyb21CRVIoaW5wdXREYXRhLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3KTtcclxuICAgICAgICBpZiAoYXNuMS5vZmZzZXQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IF9yZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGFzbjEucmVzdWx0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpbnB1dFNjaGVtYS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dFNjaGVtYS5uYW1lID0gaW5wdXRTY2hlbWEubmFtZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBFTVBUWV9TVFJJTkcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0U2NoZW1hLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcm9vdFtpbnB1dFNjaGVtYS5uYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzdWx0Lm5hbWUgPSBpbnB1dFNjaGVtYS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZVNjaGVtYShyb290LCBhc24xLnJlc3VsdCwgaW5wdXRTY2hlbWEucHJpbWl0aXZlU2NoZW1hKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmVyaWZpZWQ6IHRydWUsXHJcbiAgICAgICAgcmVzdWx0OiByb290XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHZlcmlmeVNjaGVtYShpbnB1dEJ1ZmZlciwgaW5wdXRTY2hlbWEpIHtcclxuICAgIGlmICgoaW5wdXRTY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcmlmaWVkOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzdWx0OiB7IGVycm9yOiBcIldyb25nIEFTTi4xIHNjaGVtYSB0eXBlXCIgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBhc24xID0gbG9jYWxGcm9tQkVSKHB2dHN1dGlsc19fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoaW5wdXRCdWZmZXIpKTtcclxuICAgIGlmIChhc24xLm9mZnNldCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJpZmllZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlc3VsdDogYXNuMS5yZXN1bHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBhcmVTY2hlbWEoYXNuMS5yZXN1bHQsIGFzbjEucmVzdWx0LCBpbnB1dFNjaGVtYSk7XHJcbn1cblxuZXhwb3J0cy5BbnkgPSBBbnk7XG5leHBvcnRzLkJhc2VCbG9jayA9IEJhc2VCbG9jaztcbmV4cG9ydHMuQmFzZVN0cmluZ0Jsb2NrID0gQmFzZVN0cmluZ0Jsb2NrO1xuZXhwb3J0cy5CaXRTdHJpbmcgPSBCaXRTdHJpbmc7XG5leHBvcnRzLkJtcFN0cmluZyA9IEJtcFN0cmluZztcbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG5leHBvcnRzLkNoYXJhY3RlclN0cmluZyA9IENoYXJhY3RlclN0cmluZztcbmV4cG9ydHMuQ2hvaWNlID0gQ2hvaWNlO1xuZXhwb3J0cy5Db25zdHJ1Y3RlZCA9IENvbnN0cnVjdGVkO1xuZXhwb3J0cy5EQVRFID0gREFURTtcbmV4cG9ydHMuRGF0ZVRpbWUgPSBEYXRlVGltZTtcbmV4cG9ydHMuRHVyYXRpb24gPSBEdXJhdGlvbjtcbmV4cG9ydHMuRW5kT2ZDb250ZW50ID0gRW5kT2ZDb250ZW50O1xuZXhwb3J0cy5FbnVtZXJhdGVkID0gRW51bWVyYXRlZDtcbmV4cG9ydHMuR2VuZXJhbFN0cmluZyA9IEdlbmVyYWxTdHJpbmc7XG5leHBvcnRzLkdlbmVyYWxpemVkVGltZSA9IEdlbmVyYWxpemVkVGltZTtcbmV4cG9ydHMuR3JhcGhpY1N0cmluZyA9IEdyYXBoaWNTdHJpbmc7XG5leHBvcnRzLkhleEJsb2NrID0gSGV4QmxvY2s7XG5leHBvcnRzLklBNVN0cmluZyA9IElBNVN0cmluZztcbmV4cG9ydHMuSW50ZWdlciA9IEludGVnZXI7XG5leHBvcnRzLk51bGwgPSBOdWxsO1xuZXhwb3J0cy5OdW1lcmljU3RyaW5nID0gTnVtZXJpY1N0cmluZztcbmV4cG9ydHMuT2JqZWN0SWRlbnRpZmllciA9IE9iamVjdElkZW50aWZpZXI7XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gT2N0ZXRTdHJpbmc7XG5leHBvcnRzLlByaW1pdGl2ZSA9IFByaW1pdGl2ZTtcbmV4cG9ydHMuUHJpbnRhYmxlU3RyaW5nID0gUHJpbnRhYmxlU3RyaW5nO1xuZXhwb3J0cy5SYXdEYXRhID0gUmF3RGF0YTtcbmV4cG9ydHMuUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyID0gUmVsYXRpdmVPYmplY3RJZGVudGlmaWVyO1xuZXhwb3J0cy5SZXBlYXRlZCA9IFJlcGVhdGVkO1xuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuZXhwb3J0cy5TZXQgPSBTZXQ7XG5leHBvcnRzLlRJTUUgPSBUSU1FO1xuZXhwb3J0cy5UZWxldGV4U3RyaW5nID0gVGVsZXRleFN0cmluZztcbmV4cG9ydHMuVGltZU9mRGF5ID0gVGltZU9mRGF5O1xuZXhwb3J0cy5VVENUaW1lID0gVVRDVGltZTtcbmV4cG9ydHMuVW5pdmVyc2FsU3RyaW5nID0gVW5pdmVyc2FsU3RyaW5nO1xuZXhwb3J0cy5VdGY4U3RyaW5nID0gVXRmOFN0cmluZztcbmV4cG9ydHMuVmFsdWVCbG9jayA9IFZhbHVlQmxvY2s7XG5leHBvcnRzLlZpZGVvdGV4U3RyaW5nID0gVmlkZW90ZXhTdHJpbmc7XG5leHBvcnRzLlZpZXdXcml0ZXIgPSBWaWV3V3JpdGVyO1xuZXhwb3J0cy5WaXNpYmxlU3RyaW5nID0gVmlzaWJsZVN0cmluZztcbmV4cG9ydHMuY29tcGFyZVNjaGVtYSA9IGNvbXBhcmVTY2hlbWE7XG5leHBvcnRzLmZyb21CRVIgPSBmcm9tQkVSO1xuZXhwb3J0cy52ZXJpZnlTY2hlbWEgPSB2ZXJpZnlTY2hlbWE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/asn1js/build/index.js\n");

/***/ })

};
;