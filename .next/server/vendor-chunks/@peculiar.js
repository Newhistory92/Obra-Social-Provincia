"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar";
exports.ids = ["vendor-chunks/@peculiar"];
exports.modules = {

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data)\n            ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data)\n            : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQVc7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsd0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydC5qcz8xNzg1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Db252ZXJ0ID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IHB2dHN1dGlsc18xID0gcmVxdWlyZShcInB2dHN1dGlsc1wiKTtcbmNvbnN0IHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuY29uc3Qgc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcbmNsYXNzIEFzbkNvbnZlcnQge1xuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyXzEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUob2JqKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gcGFyc2VyXzEuQXNuUGFyc2VyLnBhcnNlKGRhdGEsIHRhcmdldCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1N0cmluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShkYXRhKVxuICAgICAgICAgICAgPyBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKVxuICAgICAgICAgICAgOiBBc25Db252ZXJ0LnNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgY29uc3QgYXNuID0gYXNuMWpzLmZyb21CRVIoYnVmKTtcbiAgICAgICAgaWYgKGFzbi5vZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZWNvZGUgQVNOLjEgZGF0YS4gJHthc24ucmVzdWx0LmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc24ucmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc25Db252ZXJ0ID0gQXNuQ29udmVydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value) => value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value) => {\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    },\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4\n        ? value.valueBlock.toString()\n        : value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Integer({ value: +value }),\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value) => value.valueBlock.valueDec,\n    toASN: (value) => new asn1js.Enumerated({ value }),\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.Integer({ valueHex: value }),\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value) => value.toBigInt(),\n    toASN: (value) => asn1js.Integer.fromBigInt(value),\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.BitString({ valueHex: value }),\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value) => value.valueBlock.toString(),\n    toASN: (value) => new asn1js.ObjectIdentifier({ value }),\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value) => value.valueBlock.value,\n    toASN: (value) => new asn1js.Boolean({ value }),\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value) => value.valueBlock.valueHexView,\n    toASN: (value) => new asn1js.OctetString({ valueHex: value }),\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value) => new index_1.OctetString(value.getValue()),\n    toASN: (value) => value.toASN(),\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value) => value.valueBlock.value,\n        toASN: (value) => new Asn1Type({ value }),\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.UTCTime({ valueDate: value }),\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value) => value.toDate(),\n    toASN: (value) => new asn1js.GeneralizedTime({ valueDate: value }),\n};\nexports.AsnNullConverter = {\n    fromASN: () => null,\n    toASN: () => {\n        return new asn1js.Null();\n    },\n};\nfunction defaultConverter(type) {\n    switch (type) {\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLG1DQUFtQyxHQUFHLDJCQUEyQixHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLGlDQUFpQyxHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QixHQUFHLGtDQUFrQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLDZCQUE2QixHQUFHLDhCQUE4QixHQUFHLDBDQUEwQyxHQUFHLCtCQUErQixHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLGlDQUFpQyxHQUFHLHNDQUFzQyxHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QjtBQUM3M0IsZUFBZSxtQkFBTyxDQUFDLDBEQUFRO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFlO0FBQ3ZDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZUFBZTtBQUMxRDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsMkNBQTJDLGlCQUFpQjtBQUM1RDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsbUNBQW1DO0FBQ25DLGlDQUFpQztBQUNqQyxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQjtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxtREFBbUQsa0JBQWtCO0FBQ3JFO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0ZXJzLmpzPzUwZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk51bGxDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciA9IGV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25WaXNpYmxlU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25UZWxldGV4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuQm1wU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlciA9IGV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25JbnRlZ2VyQmlnSW50Q29udmVydGVyID0gZXhwb3J0cy5Bc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkFueUNvbnZlcnRlciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vdHlwZXMvaW5kZXhcIik7XG5leHBvcnRzLkFzbkFueUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgYXNuMWpzLk51bGwgPyBudWxsIDogdmFsdWUudmFsdWVCZWZvcmVEZWNvZGVWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5OdWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXNuMWpzLmZyb21CRVIodmFsdWUpO1xuICAgICAgICBpZiAoc2NoZW1hLnJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNjaGVtYS5yZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEucmVzdWx0O1xuICAgIH0sXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcuYnl0ZUxlbmd0aCA+PSA0XG4gICAgICAgID8gdmFsdWUudmFsdWVCbG9jay50b1N0cmluZygpXG4gICAgICAgIDogdmFsdWUudmFsdWVCbG9jay52YWx1ZURlYyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkludGVnZXIoeyB2YWx1ZTogK3ZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVEZWMsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5FbnVtZXJhdGVkKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkludGVnZXIoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25JbnRlZ2VyQmlnSW50Q29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9CaWdJbnQoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBhc24xanMuSW50ZWdlci5mcm9tQmlnSW50KHZhbHVlKSxcbn07XG5leHBvcnRzLkFzbkJpdFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuQml0U3RyaW5nKHsgdmFsdWVIZXg6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudG9TdHJpbmcoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLk9iamVjdElkZW50aWZpZXIoeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkJvb2xlYW5Db252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuQm9vbGVhbih7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgdmFsdWVIZXg6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuQ29uc3RydWN0ZWRPY3RldFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IG5ldyBpbmRleF8xLk9jdGV0U3RyaW5nKHZhbHVlLmdldFZhbHVlKCkpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvQVNOKCksXG59O1xuZnVuY3Rpb24gY3JlYXRlU3RyaW5nQ29udmVydGVyKEFzbjFUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgICAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgQXNuMVR5cGUoeyB2YWx1ZSB9KSxcbiAgICB9O1xufVxuZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5VdGY4U3RyaW5nKTtcbmV4cG9ydHMuQXNuQm1wU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5CbXBTdHJpbmcpO1xuZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlVuaXZlcnNhbFN0cmluZyk7XG5leHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLk51bWVyaWNTdHJpbmcpO1xuZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlByaW50YWJsZVN0cmluZyk7XG5leHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlRlbGV0ZXhTdHJpbmcpO1xuZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVmlkZW90ZXhTdHJpbmcpO1xuZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLklBNVN0cmluZyk7XG5leHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkdyYXBoaWNTdHJpbmcpO1xuZXhwb3J0cy5Bc25WaXNpYmxlU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5WaXNpYmxlU3RyaW5nKTtcbmV4cG9ydHMuQXNuR2VuZXJhbFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuR2VuZXJhbFN0cmluZyk7XG5leHBvcnRzLkFzbkNoYXJhY3RlclN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuQ2hhcmFjdGVyU3RyaW5nKTtcbmV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvRGF0ZSgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuVVRDVGltZSh7IHZhbHVlRGF0ZTogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25HZW5lcmFsaXplZFRpbWVDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0RhdGUoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkdlbmVyYWxpemVkVGltZSh7IHZhbHVlRGF0ZTogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25OdWxsQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICgpID0+IG51bGwsXG4gICAgdG9BU046ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuTnVsbCgpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZGVmYXVsdENvbnZlcnRlcih0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQW55OlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQW55Q29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJpdFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5CbXBTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQm9vbGVhbjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJvb2xlYW5Db252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQ2hhcmFjdGVyU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkVudW1lcmF0ZWQ6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdlbmVyYWxTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdlbmVyYWxpemVkVGltZTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5HcmFwaGljU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5JQTVTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25JQTVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuSW50ZWdlcjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuTnVsbDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk51bGxDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuTnVtZXJpY1N0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuT2JqZWN0SWRlbnRpZmllcjpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk9iamVjdElkZW50aWZpZXJDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5QcmludGFibGVTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVGVsZXRleFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVVRDVGltZTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblVUQ1RpbWVDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVW5pdmVyc2FsU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlV0ZjhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25VdGY4U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlZpZGVvdGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVmlzaWJsZVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHRDb252ZXJ0ZXIgPSBkZWZhdWx0Q29udmVydGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options) => (target) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target)) {\n        schema = storage_1.schemaStorage.createDefault(target);\n        storage_1.schemaStorage.set(target, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target);\n    }\n    Object.assign(schema, options);\n};\nexports.AsnType = AsnType;\nconst AsnChoiceType = () => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Choice });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Set, ...options });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options) => (0, exports.AsnType)({ type: enums_1.AsnTypeTypes.Sequence, ...options });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options) => (target, propertyKey) => {\n    let schema;\n    if (!storage_1.schemaStorage.has(target.constructor)) {\n        schema = storage_1.schemaStorage.createDefault(target.constructor);\n        storage_1.schemaStorage.set(target.constructor, schema);\n    }\n    else {\n        schema = storage_1.schemaStorage.get(target.constructor);\n    }\n    const copyOptions = Object.assign({}, options);\n    if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n        const defaultConverter = converters.defaultConverter(options.type);\n        if (!defaultConverter) {\n            throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n        }\n        copyOptions.converter = defaultConverter;\n    }\n    schema.items[propertyKey] = copyOptions;\n};\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyx1QkFBdUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxlQUFlO0FBQ3hHLG1CQUFtQixtQkFBTyxDQUFDLHdGQUFjO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsbURBQW1ELG1DQUFtQztBQUN0RixxQkFBcUI7QUFDckIsdURBQXVELDRDQUE0QztBQUNuRyxrQkFBa0I7QUFDbEIsNERBQTRELGlEQUFpRDtBQUM3Ryx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZLE9BQU8sd0JBQXdCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZGVjb3JhdG9ycy5qcz9jYTI3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Qcm9wID0gZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBleHBvcnRzLkFzblNldFR5cGUgPSBleHBvcnRzLkFzbkNob2ljZVR5cGUgPSBleHBvcnRzLkFzblR5cGUgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jb25zdCBBc25UeXBlID0gKG9wdGlvbnMpID0+ICh0YXJnZXQpID0+IHtcbiAgICBsZXQgc2NoZW1hO1xuICAgIGlmICghc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY3JlYXRlRGVmYXVsdCh0YXJnZXQpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LCBzY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBvcHRpb25zKTtcbn07XG5leHBvcnRzLkFzblR5cGUgPSBBc25UeXBlO1xuY29uc3QgQXNuQ2hvaWNlVHlwZSA9ICgpID0+ICgwLCBleHBvcnRzLkFzblR5cGUpKHsgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pO1xuZXhwb3J0cy5Bc25DaG9pY2VUeXBlID0gQXNuQ2hvaWNlVHlwZTtcbmNvbnN0IEFzblNldFR5cGUgPSAob3B0aW9ucykgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQsIC4uLm9wdGlvbnMgfSk7XG5leHBvcnRzLkFzblNldFR5cGUgPSBBc25TZXRUeXBlO1xuY29uc3QgQXNuU2VxdWVuY2VUeXBlID0gKG9wdGlvbnMpID0+ICgwLCBleHBvcnRzLkFzblR5cGUpKHsgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2UsIC4uLm9wdGlvbnMgfSk7XG5leHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IEFzblNlcXVlbmNlVHlwZTtcbmNvbnN0IEFzblByb3AgPSAob3B0aW9ucykgPT4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcbiAgICBsZXQgc2NoZW1hO1xuICAgIGlmICghc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldC5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY3JlYXRlRGVmYXVsdCh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGNvcHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBjb3B5T3B0aW9ucy50eXBlID09PSBcIm51bWJlclwiICYmICFjb3B5T3B0aW9ucy5jb252ZXJ0ZXIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihvcHRpb25zLnR5cGUpO1xuICAgICAgICBpZiAoIWRlZmF1bHRDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkZWZhdWx0IGNvbnZlcnRlciBmb3IgcHJvcGVydHkgJyR7cHJvcGVydHlLZXl9JyBvZiAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvcHlPcHRpb25zLmNvbnZlcnRlciA9IGRlZmF1bHRDb252ZXJ0ZXI7XG4gICAgfVxuICAgIHNjaGVtYS5pdGVtc1twcm9wZXJ0eUtleV0gPSBjb3B5T3B0aW9ucztcbn07XG5leHBvcnRzLkFzblByb3AgPSBBc25Qcm9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function (AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes || (exports.AsnTypeTypes = AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function (AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes || (exports.AsnPropTypes = AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lbnVtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CLG9CQUFvQixvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CLG9CQUFvQixvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lbnVtcy5qcz9mMDEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyA9IHZvaWQgMDtcbnZhciBBc25UeXBlVHlwZXM7XG4oZnVuY3Rpb24gKEFzblR5cGVUeXBlcykge1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJTZXF1ZW5jZVwiXSA9IDBdID0gXCJTZXF1ZW5jZVwiO1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJTZXRcIl0gPSAxXSA9IFwiU2V0XCI7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIkNob2ljZVwiXSA9IDJdID0gXCJDaG9pY2VcIjtcbn0pKEFzblR5cGVUeXBlcyB8fCAoZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSBBc25UeXBlVHlwZXMgPSB7fSkpO1xudmFyIEFzblByb3BUeXBlcztcbihmdW5jdGlvbiAoQXNuUHJvcFR5cGVzKSB7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkFueVwiXSA9IDFdID0gXCJBbnlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDJdID0gXCJCb29sZWFuXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk9jdGV0U3RyaW5nXCJdID0gM10gPSBcIk9jdGV0U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJpdFN0cmluZ1wiXSA9IDRdID0gXCJCaXRTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiSW50ZWdlclwiXSA9IDVdID0gXCJJbnRlZ2VyXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkVudW1lcmF0ZWRcIl0gPSA2XSA9IFwiRW51bWVyYXRlZFwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJPYmplY3RJZGVudGlmaWVyXCJdID0gN10gPSBcIk9iamVjdElkZW50aWZpZXJcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVXRmOFN0cmluZ1wiXSA9IDhdID0gXCJVdGY4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJtcFN0cmluZ1wiXSA9IDldID0gXCJCbXBTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVW5pdmVyc2FsU3RyaW5nXCJdID0gMTBdID0gXCJVbml2ZXJzYWxTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiTnVtZXJpY1N0cmluZ1wiXSA9IDExXSA9IFwiTnVtZXJpY1N0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJQcmludGFibGVTdHJpbmdcIl0gPSAxMl0gPSBcIlByaW50YWJsZVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUZWxldGV4U3RyaW5nXCJdID0gMTNdID0gXCJUZWxldGV4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpZGVvdGV4U3RyaW5nXCJdID0gMTRdID0gXCJWaWRlb3RleFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJJQTVTdHJpbmdcIl0gPSAxNV0gPSBcIklBNVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHcmFwaGljU3RyaW5nXCJdID0gMTZdID0gXCJHcmFwaGljU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlZpc2libGVTdHJpbmdcIl0gPSAxN10gPSBcIlZpc2libGVTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR2VuZXJhbFN0cmluZ1wiXSA9IDE4XSA9IFwiR2VuZXJhbFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJDaGFyYWN0ZXJTdHJpbmdcIl0gPSAxOV0gPSBcIkNoYXJhY3RlclN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVVENUaW1lXCJdID0gMjBdID0gXCJVVENUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdlbmVyYWxpemVkVGltZVwiXSA9IDIxXSA9IFwiR2VuZXJhbGl6ZWRUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkRBVEVcIl0gPSAyMl0gPSBcIkRBVEVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVGltZU9mRGF5XCJdID0gMjNdID0gXCJUaW1lT2ZEYXlcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRGF0ZVRpbWVcIl0gPSAyNF0gPSBcIkRhdGVUaW1lXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkR1cmF0aW9uXCJdID0gMjVdID0gXCJEdXJhdGlvblwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUSU1FXCJdID0gMjZdID0gXCJUSU1FXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk51bGxcIl0gPSAyN10gPSBcIk51bGxcIjtcbn0pKEFzblByb3BUeXBlcyB8fCAoZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSBBc25Qcm9wVHlwZXMgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsMEZBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsNkdBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL2luZGV4LmpzP2JiZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hX3ZhbGlkYXRpb25cIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor() {\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvc2NoZW1hX3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2Vycm9ycy9zY2hlbWFfdmFsaWRhdGlvbi5qcz9mYmMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IFtdO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yID0gQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        }\n        else {\n            return isConvertible(target.prototype);\n        }\n    }\n    else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for (let i = 0; i < bytes1.byteLength; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9oZWxwZXIuanM/YTIzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gZXhwb3J0cy5pc1R5cGVPZkFycmF5ID0gZXhwb3J0cy5pc0NvbnZlcnRpYmxlID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNDb252ZXJ0aWJsZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJmdW5jdGlvblwiICYmIHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUudG9BU04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tQVNOKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gISEodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgPT09IFwib2JqZWN0XCIgJiYgXCJ0b0FTTlwiIGluIHRhcmdldCAmJiBcImZyb21BU05cIiBpbiB0YXJnZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNDb252ZXJ0aWJsZSA9IGlzQ29udmVydGlibGU7XG5mdW5jdGlvbiBpc1R5cGVPZkFycmF5KHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIGlmICgoKF9hID0gcHJvdG8gPT09IG51bGwgfHwgcHJvdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3RvLnByb3RvdHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN0cnVjdG9yKSA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1R5cGVPZkFycmF5KHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1R5cGVPZkFycmF5ID0gaXNUeXBlT2ZBcnJheTtcbmZ1bmN0aW9uIGlzQXJyYXlFcXVhbChieXRlczEsIGJ5dGVzMikge1xuICAgIGlmICghKGJ5dGVzMSAmJiBieXRlczIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzMS5ieXRlTGVuZ3RoICE9PSBieXRlczIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGIxID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMxKTtcbiAgICBjb25zdCBiMiA9IG5ldyBVaW50OEFycmF5KGJ5dGVzMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlczEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({ enumerable: true, get: function () { return decorators_1.AsnProp; } }));\nObject.defineProperty(exports, \"AsnType\", ({ enumerable: true, get: function () { return decorators_1.AsnType; } }));\nObject.defineProperty(exports, \"AsnChoiceType\", ({ enumerable: true, get: function () { return decorators_1.AsnChoiceType; } }));\nObject.defineProperty(exports, \"AsnSequenceType\", ({ enumerable: true, get: function () { return decorators_1.AsnSequenceType; } }));\nObject.defineProperty(exports, \"AsnSetType\", ({ enumerable: true, get: function () { return decorators_1.AsnSetType; } }));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({ enumerable: true, get: function () { return enums_1.AsnTypeTypes; } }));\nObject.defineProperty(exports, \"AsnPropTypes\", ({ enumerable: true, get: function () { return enums_1.AsnPropTypes; } }));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({ enumerable: true, get: function () { return parser_1.AsnParser; } }));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({ enumerable: true, get: function () { return serializer_1.AsnSerializer; } }));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUNsTSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBTztBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyx3RkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQywwRkFBZTtBQUM1QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILGlEQUFnRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM5SCxtREFBa0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbEksOENBQTZDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3hILGNBQWMsbUJBQU8sQ0FBQyw4RUFBUztBQUMvQixnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZILGVBQWUsbUJBQU8sQ0FBQyxnRkFBVTtBQUNqQyw2Q0FBNEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDbEgsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQWM7QUFDekMsaURBQWdELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzlILHFCQUFxQixtQkFBTyxDQUFDLHNGQUFVO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFXO0FBQ3hDLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaW5kZXguanM/ZWJhMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IGV4cG9ydHMuQXNuUGFyc2VyID0gZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyA9IGV4cG9ydHMuQXNuU2V0VHlwZSA9IGV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gZXhwb3J0cy5Bc25DaG9pY2VUeXBlID0gZXhwb3J0cy5Bc25UeXBlID0gZXhwb3J0cy5Bc25Qcm9wID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXMvaW5kZXhcIiksIGV4cG9ydHMpO1xudmFyIGRlY29yYXRvcnNfMSA9IHJlcXVpcmUoXCIuL2RlY29yYXRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25Qcm9wXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuUHJvcDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuQ2hvaWNlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzbkNob2ljZVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXF1ZW5jZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25TZXF1ZW5jZVR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuU2V0VHlwZTsgfSB9KTtcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25UeXBlVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuQXNuVHlwZVR5cGVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUHJvcFR5cGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLkFzblByb3BUeXBlczsgfSB9KTtcbnZhciBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3BhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuQXNuUGFyc2VyOyB9IH0pO1xudmFyIHNlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25TZXJpYWxpemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJpYWxpemVyXzEuQXNuU2VyaWFsaXplcjsgfSB9KTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vYmplY3RzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnZlcnRcIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []) {\n        if (typeof items === \"number\") {\n            super(items);\n        }\n        else {\n            super();\n            for (const item of items) {\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9vYmplY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL29iamVjdHMuanM/MTQzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuQXJyYXkgPSB2b2lkIDA7XG5jbGFzcyBBc25BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcyA9IFtdKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFzbkFycmF5ID0gQXNuQXJyYXk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber,\n                    },\n                    value: schema.schema.valueBlock.value,\n                });\n                for (const key in schema.items) {\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));\n                }\n                else {\n                    return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));\n                }\n            }\n            for (const key in schema.items) {\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : ((0, helper_1.isConvertible)(schemaItemType)\n                        ? new schemaItemType()\n                        : null);\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\"\n                                ? asn1js.Sequence\n                                : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element) => converter.fromASN(element));\n                        }\n                        else {\n                            res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));\n                        }\n                    }\n                    else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            }\n                            else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                }\n                else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));\n                    }\n                    else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        }\n        catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBYztBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyxrRkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxzRkFBc0YsYUFBYSxlQUFlLGdDQUFnQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRix3QkFBd0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3BhcnNlci5qcz83ZTc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25QYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNsYXNzIEFzblBhcnNlciB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBhc24xUGFyc2VkID0gYXNuMWpzLmZyb21CRVIoZGF0YSk7XG4gICAgICAgIGlmIChhc24xUGFyc2VkLnJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFzbjFQYXJzZWQucmVzdWx0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZyb21BU04oYXNuMVBhcnNlZC5yZXN1bHQsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQVNOKGFzbjFTY2hlbWEsIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZnJvbUFTTihhc24xU2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY2FjaGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRTY2hlbWEgPSBzY2hlbWEuc2NoZW1hO1xuICAgICAgICAgICAgaWYgKGFzbjFTY2hlbWEuY29uc3RydWN0b3IgPT09IGFzbjFqcy5Db25zdHJ1Y3RlZCAmJiBzY2hlbWEudHlwZSAhPT0gZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gbmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBhc24xU2NoZW1hLmlkQmxvY2sudGFnTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2NoZW1hLnNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXNuMVNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFzbjFDb21wYXJlZFNjaGVtYSA9IGFzbjFqcy5jb21wYXJlU2NoZW1hKHt9LCBhc24xU2NoZW1hLCB0YXJnZXRTY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCFhc24xQ29tcGFyZWRTY2hlbWEudmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yKGBEYXRhIGRvZXMgbm90IG1hdGNoIHRvICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hLiAke2FzbjFDb21wYXJlZFNjaGVtYS5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAoKDAsIGhlbHBlcl8xLmlzVHlwZU9mQXJyYXkpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShcInZhbHVlXCIgaW4gYXNuMVNjaGVtYS52YWx1ZUJsb2NrICYmIEFycmF5LmlzQXJyYXkoYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGl0ZW1zIGZyb20gdGhlIEFTTi4xIHBhcnNlZCB2YWx1ZS4gQVNOLjEgb2JqZWN0IGlzIG5vdCBjb25zdHJ1Y3RlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBzY2hlbWEuaXRlbVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIoaXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBhcnJheSBpdGVtIG9mICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5mcm9tKGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZnJvbShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsIChlbGVtZW50KSA9PiB0aGlzLmZyb21BU04oZWxlbWVudCwgaXRlbVR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc24xU2NoZW1hVmFsdWUgPSBhc24xQ29tcGFyZWRTY2hlbWEucmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFhc24xU2NoZW1hVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW0gPSBzY2hlbWEuaXRlbXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtVHlwZSA9IHNjaGVtYUl0ZW0udHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW1UeXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gKF9hID0gc2NoZW1hSXRlbS5jb252ZXJ0ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBzY2hlbWFJdGVtVHlwZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmVydGVyIGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IHNjaGVtYUl0ZW0ucmVwZWF0ZWQgPT09IFwic2VxdWVuY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IG5ldyBDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnZhbHVlQmxvY2sgPSBhc24xU2NoZW1hVmFsdWUudmFsdWVCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtQXNuID0gYXNuMWpzLmZyb21CRVIobmV3SXRlbS50b0JFUihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtQXNuLm9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgdGhlIGNoaWxkIGl0ZW0uICR7bmV3SXRlbUFzbi5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrICYmIEFycmF5LmlzQXJyYXkobmV3SXRlbUFzbi5yZXN1bHQudmFsdWVCbG9jay52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSBvYmplY3QgaXMgbm90IGNvbnN0cnVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbSh2YWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbShhc24xU2NoZW1hVmFsdWUsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIuZnJvbUFTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBhc24xU2NoZW1hVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXcgc2NoZW1hSXRlbVR5cGUoKS50b1NjaGVtYShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlTmFtZSA9IGVudW1zXzEuQXNuUHJvcFR5cGVzW3NjaGVtYUl0ZW1UeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGUgPSBhc24xanNbQXNuMVR5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBc24xVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0ICcke0FzbjFUeXBlTmFtZX0nIGNsYXNzIGZyb20gYXNuMWpzIG1vZHVsZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXcgQXNuMVR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbS52YWx1ZUJsb2NrID0gdmFsdWUudmFsdWVCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFzbjFqcy5mcm9tQkVSKG5ld0l0ZW0udG9CRVIoZmFsc2UpKS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IGNvbnZlcnRlci5mcm9tQVNOKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc24xU2NoZW1hVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBsaXN0IG9mIGl0ZW1zIGZyb20gdGhlIEFTTi4xIHBhcnNlZCB2YWx1ZS4gQVNOLjEgdmFsdWUgc2hvdWxkIGJlIGl0ZXJhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbShhc24xU2NoZW1hVmFsdWUsIChlbGVtZW50KSA9PiB0aGlzLmZyb21BU04oZWxlbWVudCwgc2NoZW1hSXRlbVR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gdGhpcy5mcm9tQVNOKGFzbjFTY2hlbWFWYWx1ZSwgc2NoZW1hSXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnNjaGVtYXMucHVzaCh0YXJnZXQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXNuUGFyc2VyID0gQXNuUGFyc2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor() {\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {},\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for (const key in schema.items) {\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof (item.type) === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({ name });\n            }\n            else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            }\n            else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({ name });\n                }\n                else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            }\n            else {\n                asn1Item = new asn1js.Any({ name });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\"\n                    ? asn1js.Set\n                    : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item,\n                        }),\n                    ],\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated\n                            ? asn1js.Constructed\n                            : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                        }));\n                    }\n                    else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated\n                            ? this.get(item.type, true).schema\n                            : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context,\n                            },\n                            value: value,\n                        }));\n                    }\n                }\n                else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context,\n                        },\n                        value: [asn1Item],\n                    }));\n                }\n            }\n            else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({ value: asn1Value, name: \"\" });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({ value: asn1Value, name: \"\" });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQ0FBa0M7QUFDeEY7QUFDQTtBQUNBLHVDQUF1QyxrQ0FBa0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsYUFBYTtBQUNuRjtBQUNBLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zY2hlbWEuanM/ZTRhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2NoZW1hU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcbmNsYXNzIEFzblNjaGVtYVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgaGFzKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5oYXModGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0KHRhcmdldCwgY2hlY2tTY2hlbWEgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgJyR7dGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lfScgdGFyZ2V0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrU2NoZW1hICYmICFzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAnJHt0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9JyBkb2Vzbid0IGNvbnRhaW4gQVNOLjEgc2NoZW1hLiBDYWxsICdBc25TY2hlbWFTdG9yYWdlLmNhY2hlJy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBjYWNoZSh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWEuc2NoZW1hID0gdGhpcy5jcmVhdGUodGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVEZWZhdWx0KHRhcmdldCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB7XG4gICAgICAgICAgICB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZSxcbiAgICAgICAgICAgIGl0ZW1zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgc2NoZW1hLml0ZW1zID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hLml0ZW1zLCBwYXJlbnRTY2hlbWEuaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNyZWF0ZSh0YXJnZXQsIHVzZU5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCkgfHwgdGhpcy5jcmVhdGVEZWZhdWx0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGFzbjFWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzY2hlbWEuaXRlbXNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1c2VOYW1lcyA/IGtleSA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgYXNuMUl0ZW07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGVOYW1lID0gZW51bXNfMS5Bc25Qcm9wVHlwZXNbaXRlbS50eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZSA9IGFzbjFqc1tBc24xVHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghQXNuMVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IEFTTjEgY2xhc3MgYnkgbmFtZSAnJHtBc24xVHlwZU5hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBBc24xVHlwZSh7IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGl0ZW0udHlwZSgpO1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gaW5zdGFuY2UudG9TY2hlbWEobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVNjaGVtYSA9IHRoaXMuZ2V0KGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1TY2hlbWEudHlwZSA9PT0gZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IGFzbjFqcy5BbnkoeyBuYW1lIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSB0aGlzLmNyZWF0ZShpdGVtLnR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgYXNuMWpzLkFueSh7IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25hbCA9ICEhaXRlbS5vcHRpb25hbCB8fCBpdGVtLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBpdGVtLnJlcGVhdGVkID09PSBcInNldFwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNldFxuICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGFzbjFqcy5SZXBlYXRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXNuMUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLmNvbnRleHQgIT09IG51bGwgJiYgaXRlbS5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gaXRlbS5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLkNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuUHJpbWl0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZShpdGVtLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZXBlYXRlZCA9ICEhaXRlbS5yZXBlYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICFpc1JlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdldChpdGVtLnR5cGUsIHRydWUpLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMUl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwidmFsdWVCbG9ja1wiIGluIHZhbHVlID8gdmFsdWUudmFsdWVCbG9jay52YWx1ZSA6IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogIWlzUmVwZWF0ZWQgPyBuYW1lIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2FzbjFJdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2goYXNuMUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuU2VxdWVuY2UoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuU2V0KHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkNob2ljZSh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgQVNOMSB0eXBlIGluIHVzZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xuICAgICAgICB0aGlzLml0ZW1zLnNldCh0YXJnZXQsIHNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5kUGFyZW50U2NoZW1hKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TY2hlbWFTdG9yYWdlID0gQXNuU2NoZW1hU3RvcmFnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o) => converter.toASN(o));\n            }\n            else {\n                asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, \"[]\", target, o));\n            }\n        }\n        else {\n            for (const key in schema.items) {\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined\n                    || schemaItem.defaultValue === objProp\n                    || (typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\"\n                        && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp)))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated\n                            && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                ...value,\n                            }));\n                        }\n                        else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context,\n                                },\n                                value: asn1Item.valueBlock.value,\n                            }));\n                        }\n                    }\n                    else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context,\n                            },\n                            value: [asn1Item],\n                        }));\n                    }\n                }\n                else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                }\n                else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch (schema.type) {\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({ value: asn1Value });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof (schemaItem.type) === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = converter.toASN(objProp);\n            }\n        }\n        else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element) => this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\"\n                    ? asn1js.Sequence\n                    : asn1js.Set;\n                asn1Item = new Container({\n                    value: items,\n                });\n            }\n            else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0ZBQWM7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsa0ZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx1QkFBdUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsSUFBSSxvQ0FBb0MsdUNBQXVDLGFBQWEsWUFBWTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zZXJpYWxpemVyLmpzP2Y2MDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNlcmlhbGl6ZXIgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jbGFzcyBBc25TZXJpYWxpemVyIHtcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgYXNuMWpzLkJhc2VCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai50b0JFUihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BU04ob2JqKS50b0JFUihmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FTTihvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvQVNOKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyIDEgc2hvdWxkIGJlIHR5cGUgb2YgT2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmouY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jYWNoZSh0YXJnZXQpO1xuICAgICAgICBsZXQgYXNuMVZhbHVlID0gW107XG4gICAgICAgIGlmIChzY2hlbWEuaXRlbVR5cGUpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAxIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLml0ZW1UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKHNjaGVtYS5pdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBhcnJheSBpdGVtIG9mICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IG9iai5tYXAoKG8pID0+IGNvbnZlcnRlci50b0FTTihvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xVmFsdWUgPSBvYmoubWFwKChvKSA9PiB0aGlzLnRvQXNuSXRlbSh7IHR5cGU6IHNjaGVtYS5pdGVtVHlwZSB9LCBcIltdXCIsIHRhcmdldCwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialByb3AgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob2JqUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIHx8IHNjaGVtYUl0ZW0uZGVmYXVsdFZhbHVlID09PSBvYmpQcm9wXG4gICAgICAgICAgICAgICAgICAgIHx8ICh0eXBlb2Ygc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9ialByb3AgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICgwLCBoZWxwZXJfMS5pc0FycmF5RXF1YWwpKHRoaXMuc2VyaWFsaXplKHNjaGVtYUl0ZW0uZGVmYXVsdFZhbHVlKSwgdGhpcy5zZXJpYWxpemUob2JqUHJvcCkpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuMUl0ZW0gPSBBc25TZXJpYWxpemVyLnRvQXNuSXRlbShzY2hlbWFJdGVtLCBrZXksIHRhcmdldCwgb2JqUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLmNvbnRleHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0uaW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hSXRlbS5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0eXBlb2Ygc2NoZW1hSXRlbS50eXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtLnR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudmFsdWVIZXggPSBhc24xSXRlbSBpbnN0YW5jZW9mIGFzbjFqcy5OdWxsID8gYXNuMUl0ZW0udmFsdWVCZWZvcmVEZWNvZGVWaWV3IDogYXNuMUl0ZW0udmFsdWVCbG9jay50b0JFUigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuUHJpbWl0aXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHNjaGVtYUl0ZW0ub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBzY2hlbWFJdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFzbjFJdGVtLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHNjaGVtYUl0ZW0ub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBzY2hlbWFJdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2FzbjFJdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IGFzbjFWYWx1ZS5jb25jYXQoYXNuMUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2goYXNuMUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNuU2NoZW1hO1xuICAgICAgICBzd2l0Y2ggKHNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIGFzblNjaGVtYSA9IG5ldyBhc24xanMuU2VxdWVuY2UoeyB2YWx1ZTogYXNuMVZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQ6XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gbmV3IGFzbjFqcy5TZXQoeyB2YWx1ZTogYXNuMVZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2U6XG4gICAgICAgICAgICAgICAgaWYgKCFhc24xVmFsdWVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgJyR7dGFyZ2V0Lm5hbWV9JyBoYXMgd3JvbmcgZGF0YS4gQ2hvaWNlIGNhbm5vdCBiZSBlbXB0eS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gYXNuMVZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc25TY2hlbWE7XG4gICAgfVxuICAgIHN0YXRpYyB0b0Fzbkl0ZW0oc2NoZW1hSXRlbSwga2V5LCB0YXJnZXQsIG9ialByb3ApIHtcbiAgICAgICAgbGV0IGFzbjFJdGVtO1xuICAgICAgICBpZiAodHlwZW9mIChzY2hlbWFJdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBzY2hlbWFJdGVtLmNvbnZlcnRlcjtcbiAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAnJHtrZXl9JyBkb2Vzbid0IGhhdmUgY29udmVydGVyIGZvciB0eXBlICR7ZW51bXNfMS5Bc25Qcm9wVHlwZXNbc2NoZW1hSXRlbS50eXBlXX0gaW4gc2NoZW1hICcke3RhcmdldC5uYW1lfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ29ialByb3AnIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG9ialByb3AsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIudG9BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IHNjaGVtYUl0ZW0ucmVwZWF0ZWQgPT09IFwic2VxdWVuY2VcIlxuICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXQ7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBjb252ZXJ0ZXIudG9BU04ob2JqUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpQcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICdvYmpQcm9wJyBzaG91bGQgYmUgdHlwZSBvZiBBcnJheS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShvYmpQcm9wLCAoZWxlbWVudCkgPT4gdGhpcy50b0FTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IHRoaXMudG9BU04ob2JqUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzbjFJdGVtO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IEFzblNlcmlhbGl6ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBVTtBQUNuQyxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zdG9yYWdlLmpzP2NmZGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjaGVtYVN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYVwiKTtcbmV4cG9ydHMuc2NoZW1hU3RvcmFnZSA9IG5ldyBzY2hlbWFfMS5Bc25TY2hlbWFTdG9yYWdlKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0) {\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            }\n            else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            }\n            else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({ unusedBits: this.unusedBits, valueHex: this.value });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({ name });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray) {\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = (bits.length + 7) >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while (index < octetSize) {\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9iaXRfc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixlQUFlLG1CQUFPLENBQUMsMERBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsZ0VBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtREFBbUQ7QUFDekY7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2JpdF9zdHJpbmcuanM/ZDgxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQml0U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IHB2dHN1dGlsc18xID0gcmVxdWlyZShcInB2dHN1dGlsc1wiKTtcbmNsYXNzIEJpdFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB1bnVzZWRCaXRzID0gMCkge1xuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSB1bnVzZWRCaXRzO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiAncGFyYW1zJyBhcmd1bWVudCBmb3IgQml0U3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21BU04oYXNuKSB7XG4gICAgICAgIGlmICghKGFzbiBpbnN0YW5jZW9mIGFzbjFqcy5CaXRTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2FzbicgaXMgbm90IGluc3RhbmNlIG9mIEFTTi4xIEJpdFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSBhc24udmFsdWVCbG9jay51bnVzZWRCaXRzO1xuICAgICAgICB0aGlzLnZhbHVlID0gYXNuLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0FTTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQml0U3RyaW5nKHsgdW51c2VkQml0czogdGhpcy51bnVzZWRCaXRzLCB2YWx1ZUhleDogdGhpcy52YWx1ZSB9KTtcbiAgICB9XG4gICAgdG9TY2hlbWEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyBuYW1lIH0pO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IG9jdGV0IG9mIHVpbnRBcnJheSkge1xuICAgICAgICAgICAgcmVzICs9IG9jdGV0LnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSByZXMuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh0aGlzLnVudXNlZEJpdHMpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSh0aGlzLnVudXNlZEJpdHMpLnBhZFN0YXJ0KHRoaXMudW51c2VkQml0cywgXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChyZXMsIDIpO1xuICAgIH1cbiAgICBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBiaXRzID0gdmFsdWUudG9TdHJpbmcoMik7XG4gICAgICAgIGNvbnN0IG9jdGV0U2l6ZSA9IChiaXRzLmxlbmd0aCArIDcpID4+IDM7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IChvY3RldFNpemUgPDwgMykgLSBiaXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2N0ZXRzID0gbmV3IFVpbnQ4QXJyYXkob2N0ZXRTaXplKTtcbiAgICAgICAgYml0cyA9IGJpdHMucGFkU3RhcnQob2N0ZXRTaXplIDw8IDMsIFwiMFwiKS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb2N0ZXRTaXplKSB7XG4gICAgICAgICAgICBvY3RldHNbaW5kZXhdID0gcGFyc2VJbnQoYml0cy5zbGljZShpbmRleCA8PCAzLCAoaW5kZXggPDwgMykgKyA4KSwgMik7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBvY3RldHMuYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0U3RyaW5nID0gQml0U3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBTztBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyw4RkFBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxrR0FBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9pbmRleC5qcz9iYzM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdF9zdHJpbmdcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2N0ZXRfc3RyaW5nXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    constructor(param) {\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        }\n        else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            }\n            else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            }\n            else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({ valueHex: this.buffer });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({ name });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9vY3RldF9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGVBQWUsbUJBQU8sQ0FBQywwREFBUTtBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUI7QUFDL0Q7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9vY3RldF9zdHJpbmcuanM/NjJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2N0ZXRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY2xhc3MgT2N0ZXRTdHJpbmcge1xuICAgIGdldCBieXRlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGJ5dGVPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXJhbSkge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21BU04oYXNuKSB7XG4gICAgICAgIGlmICghKGFzbiBpbnN0YW5jZW9mIGFzbjFqcy5PY3RldFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYXNuJyBpcyBub3QgaW5zdGFuY2Ugb2YgQVNOLjEgT2N0ZXRTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvQVNOKCkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5PY3RldFN0cmluZyh7IHZhbHVlSGV4OiB0aGlzLmJ1ZmZlciB9KTtcbiAgICB9XG4gICAgdG9TY2hlbWEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5PY3RldFN0cmluZyh7IG5hbWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5PY3RldFN0cmluZyA9IE9jdGV0U3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/json-schema/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@peculiar/json-schema/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nclass JsonError extends Error {\r\n    constructor(message, innerError) {\r\n        super(innerError\r\n            ? `${message}. See the inner exception for more details.`\r\n            : message);\r\n        this.message = message;\r\n        this.innerError = innerError;\r\n    }\r\n}\n\nclass TransformError extends JsonError {\r\n    constructor(schema, message, innerError) {\r\n        super(message, innerError);\r\n        this.schema = schema;\r\n    }\r\n}\n\nclass ParserError extends TransformError {\r\n    constructor(schema, message, innerError) {\r\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\r\n    }\r\n}\n\nclass ValidationError extends JsonError {\r\n}\n\nclass SerializerError extends JsonError {\r\n    constructor(schemaName, message, innerError) {\r\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\r\n        this.schemaName = schemaName;\r\n    }\r\n}\n\nclass KeyError extends ParserError {\r\n    constructor(schema, keys, errors = {}) {\r\n        super(schema, \"Some keys doesn't match to schema\");\r\n        this.keys = keys;\r\n        this.errors = errors;\r\n    }\r\n}\n\n(function (JsonPropTypes) {\r\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\r\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\r\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\r\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\r\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\n\nfunction checkType(value, type) {\r\n    switch (type) {\r\n        case exports.JsonPropTypes.Boolean:\r\n            return typeof value === \"boolean\";\r\n        case exports.JsonPropTypes.Number:\r\n            return typeof value === \"number\";\r\n        case exports.JsonPropTypes.String:\r\n            return typeof value === \"string\";\r\n    }\r\n    return true;\r\n}\r\nfunction throwIfTypeIsWrong(value, type) {\r\n    if (!checkType(value, type)) {\r\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\r\n    }\r\n}\r\nfunction isConvertible(target) {\r\n    if (target && target.prototype) {\r\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\r\n            return true;\r\n        }\r\n        else {\r\n            return isConvertible(target.prototype);\r\n        }\r\n    }\r\n    else {\r\n        return !!(target && target.toJSON && target.fromJSON);\r\n    }\r\n}\n\nclass JsonSchemaStorage {\r\n    constructor() {\r\n        this.items = new Map();\r\n    }\r\n    has(target) {\r\n        return this.items.has(target) || !!this.findParentSchema(target);\r\n    }\r\n    get(target) {\r\n        const schema = this.items.get(target) || this.findParentSchema(target);\r\n        if (!schema) {\r\n            throw new Error(\"Cannot get schema for current target\");\r\n        }\r\n        return schema;\r\n    }\r\n    create(target) {\r\n        const schema = { names: {} };\r\n        const parentSchema = this.findParentSchema(target);\r\n        if (parentSchema) {\r\n            Object.assign(schema, parentSchema);\r\n            schema.names = {};\r\n            for (const name in parentSchema.names) {\r\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\r\n            }\r\n        }\r\n        schema.target = target;\r\n        return schema;\r\n    }\r\n    set(target, schema) {\r\n        this.items.set(target, schema);\r\n        return this;\r\n    }\r\n    findParentSchema(target) {\r\n        const parent = target.__proto__;\r\n        if (parent) {\r\n            const schema = this.items.get(parent);\r\n            return schema || this.findParentSchema(parent);\r\n        }\r\n        return null;\r\n    }\r\n}\n\nconst DEFAULT_SCHEMA = \"default\";\r\nconst schemaStorage = new JsonSchemaStorage();\n\nclass PatternValidation {\r\n    constructor(pattern) {\r\n        this.pattern = new RegExp(pattern);\r\n    }\r\n    validate(value) {\r\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\r\n        if (typeof value !== \"string\") {\r\n            throw new ValidationError(\"Incoming value must be string\");\r\n        }\r\n        if (!pattern.exec(value)) {\r\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\r\n        }\r\n    }\r\n}\n\nclass InclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min <= value && value <= this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\r\n        }\r\n    }\r\n}\n\nclass ExclusiveValidation {\r\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\r\n        if (!(this.min < value && value < this.max)) {\r\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\r\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\r\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\r\n        }\r\n    }\r\n}\n\nclass LengthValidation {\r\n    constructor(length, minLength, maxLength) {\r\n        this.length = length;\r\n        this.minLength = minLength;\r\n        this.maxLength = maxLength;\r\n    }\r\n    validate(value) {\r\n        if (this.length !== undefined) {\r\n            if (value.length !== this.length) {\r\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\r\n            }\r\n            return;\r\n        }\r\n        if (this.minLength !== undefined) {\r\n            if (value.length < this.minLength) {\r\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\r\n            }\r\n        }\r\n        if (this.maxLength !== undefined) {\r\n            if (value.length > this.maxLength) {\r\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\r\n            }\r\n        }\r\n    }\r\n}\n\nclass EnumerationValidation {\r\n    constructor(enumeration) {\r\n        this.enumeration = enumeration;\r\n    }\r\n    validate(value) {\r\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\r\n        if (!this.enumeration.includes(value)) {\r\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `'${v}'`).join(\", \")}`);\r\n        }\r\n    }\r\n}\n\nclass JsonTransform {\r\n    static checkValues(data, schemaItem) {\r\n        const values = Array.isArray(data) ? data : [data];\r\n        for (const value of values) {\r\n            for (const validation of schemaItem.validations) {\r\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\r\n                    validation.validate(data);\r\n                }\r\n                else {\r\n                    validation.validate(value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    static checkTypes(value, schemaItem) {\r\n        if (schemaItem.repeated && !Array.isArray(value)) {\r\n            throw new TypeError(\"Value must be Array\");\r\n        }\r\n        if (typeof schemaItem.type === \"number\") {\r\n            const values = Array.isArray(value) ? value : [value];\r\n            for (const v of values) {\r\n                throwIfTypeIsWrong(v, schemaItem.type);\r\n            }\r\n        }\r\n    }\r\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\r\n        return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\r\n    }\r\n}\n\nclass JsonSerializer extends JsonTransform {\r\n    static serialize(obj, options, replacer, space) {\r\n        const json = this.toJSON(obj, options);\r\n        return JSON.stringify(json, replacer, space);\r\n    }\r\n    static toJSON(obj, options = {}) {\r\n        let res;\r\n        let targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        if (isConvertible(obj)) {\r\n            return obj.toJSON();\r\n        }\r\n        if (Array.isArray(obj)) {\r\n            res = [];\r\n            for (const item of obj) {\r\n                res.push(this.toJSON(item, options));\r\n            }\r\n        }\r\n        else if (typeof obj === \"object\") {\r\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\r\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\r\n            }\r\n            targetSchema = (targetSchema || obj.constructor);\r\n            if (schemaStorage.has(targetSchema)) {\r\n                const schema = schemaStorage.get(targetSchema);\r\n                res = {};\r\n                const namedSchema = this.getSchemaByName(schema, schemaName);\r\n                for (const key in namedSchema) {\r\n                    try {\r\n                        const item = namedSchema[key];\r\n                        const objItem = obj[key];\r\n                        let value;\r\n                        if ((item.optional && objItem === undefined)\r\n                            || (item.defaultValue !== undefined && objItem === item.defaultValue)) {\r\n                            continue;\r\n                        }\r\n                        if (!item.optional && objItem === undefined) {\r\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\r\n                        }\r\n                        if (typeof item.type === \"number\") {\r\n                            if (item.converter) {\r\n                                if (item.repeated) {\r\n                                    value = objItem.map((el) => item.converter.toJSON(el, obj));\r\n                                }\r\n                                else {\r\n                                    value = item.converter.toJSON(objItem, obj);\r\n                                }\r\n                            }\r\n                            else {\r\n                                value = objItem;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (item.repeated) {\r\n                                value = objItem.map((el) => this.toJSON(el, { schemaName }));\r\n                            }\r\n                            else {\r\n                                value = this.toJSON(objItem, { schemaName });\r\n                            }\r\n                        }\r\n                        this.checkTypes(value, item);\r\n                        this.checkValues(value, item);\r\n                        res[item.name || key] = value;\r\n                    }\r\n                    catch (e) {\r\n                        if (e instanceof SerializerError) {\r\n                            throw e;\r\n                        }\r\n                        else {\r\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                res = {};\r\n                for (const key in obj) {\r\n                    res[key] = this.toJSON(obj[key], { schemaName });\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res = obj;\r\n        }\r\n        return res;\r\n    }\r\n}\n\nclass JsonParser extends JsonTransform {\r\n    static parse(data, options) {\r\n        const obj = JSON.parse(data);\r\n        return this.fromJSON(obj, options);\r\n    }\r\n    static fromJSON(target, options) {\r\n        const targetSchema = options.targetSchema;\r\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\r\n        const obj = new targetSchema();\r\n        if (isConvertible(obj)) {\r\n            return obj.fromJSON(target);\r\n        }\r\n        const schema = schemaStorage.get(targetSchema);\r\n        const namedSchema = this.getSchemaByName(schema, schemaName);\r\n        const keyErrors = {};\r\n        if (options.strictProperty && !Array.isArray(target)) {\r\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\r\n        }\r\n        for (const key in namedSchema) {\r\n            try {\r\n                const item = namedSchema[key];\r\n                const name = item.name || key;\r\n                const value = target[name];\r\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\r\n                    continue;\r\n                }\r\n                if (!item.optional && value === undefined) {\r\n                    throw new ParserError(schema, `Property '${name}' is required.`);\r\n                }\r\n                this.checkTypes(value, item);\r\n                this.checkValues(value, item);\r\n                if (typeof (item.type) === \"number\") {\r\n                    if (item.converter) {\r\n                        if (item.repeated) {\r\n                            obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\r\n                        }\r\n                        else {\r\n                            obj[key] = item.converter.fromJSON(value, obj);\r\n                        }\r\n                    }\r\n                    else {\r\n                        obj[key] = value;\r\n                    }\r\n                }\r\n                else {\r\n                    const newOptions = {\r\n                        ...options,\r\n                        targetSchema: item.type,\r\n                        schemaName,\r\n                    };\r\n                    if (item.repeated) {\r\n                        obj[key] = value.map((el) => this.fromJSON(el, newOptions));\r\n                    }\r\n                    else {\r\n                        obj[key] = this.fromJSON(value, newOptions);\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (!(e instanceof ParserError)) {\r\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\r\n                }\r\n                if (options.strictAllKeys) {\r\n                    keyErrors[key] = e;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        const keys = Object.keys(keyErrors);\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys, keyErrors);\r\n        }\r\n        return obj;\r\n    }\r\n    static checkStrictProperty(target, namedSchema, schema) {\r\n        const jsonProps = Object.keys(target);\r\n        const schemaProps = Object.keys(namedSchema);\r\n        const keys = [];\r\n        for (const key of jsonProps) {\r\n            if (schemaProps.indexOf(key) === -1) {\r\n                keys.push(key);\r\n            }\r\n        }\r\n        if (keys.length) {\r\n            throw new KeyError(schema, keys);\r\n        }\r\n    }\r\n}\n\nfunction getValidations(item) {\r\n    const validations = [];\r\n    if (item.pattern) {\r\n        validations.push(new PatternValidation(item.pattern));\r\n    }\r\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\r\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\r\n        }\r\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\r\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\r\n        }\r\n        if (item.enumeration !== undefined) {\r\n            validations.push(new EnumerationValidation(item.enumeration));\r\n        }\r\n    }\r\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\r\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\r\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\r\n        }\r\n    }\r\n    return validations;\r\n}\r\nconst JsonProp = (options = {}) => (target, propertyKey) => {\r\n    const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\r\n    let schema;\r\n    if (!schemaStorage.has(target.constructor)) {\r\n        schema = schemaStorage.create(target.constructor);\r\n        schemaStorage.set(target.constructor, schema);\r\n    }\r\n    else {\r\n        schema = schemaStorage.get(target.constructor);\r\n        if (schema.target !== target.constructor) {\r\n            schema = schemaStorage.create(target.constructor);\r\n            schemaStorage.set(target.constructor, schema);\r\n        }\r\n    }\r\n    const defaultSchema = {\r\n        type: exports.JsonPropTypes.Any,\r\n        validations: [],\r\n    };\r\n    const copyOptions = Object.assign(defaultSchema, options);\r\n    copyOptions.validations = getValidations(copyOptions);\r\n    if (typeof copyOptions.type !== \"number\") {\r\n        if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\r\n            throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\r\n        }\r\n    }\r\n    let schemaNames;\r\n    if (Array.isArray(options.schema)) {\r\n        schemaNames = options.schema;\r\n    }\r\n    else {\r\n        schemaNames = [options.schema || DEFAULT_SCHEMA];\r\n    }\r\n    for (const schemaName of schemaNames) {\r\n        if (!schema.names[schemaName]) {\r\n            schema.names[schemaName] = {};\r\n        }\r\n        const namedSchema = schema.names[schemaName];\r\n        namedSchema[propertyKey] = copyOptions;\r\n    }\r\n};\n\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2pzb24tc2NoZW1hL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsbUJBQW1CLFlBQVksUUFBUTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLFlBQVksUUFBUTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIscUJBQXFCLEtBQUs7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxJQUFJLEdBQUcsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsSUFBSSxHQUFHLElBQUk7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsZUFBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdDQUFnQyxFQUFFLGVBQWU7QUFDL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLElBQUk7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsWUFBWTtBQUMxRjtBQUNBO0FBQ0EsK0RBQStELFlBQVk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixJQUFJLGNBQWMsVUFBVTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELElBQUksY0FBYyxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixnREFBZ0QsYUFBYSxjQUFjLHlCQUF5QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvanNvbi1zY2hlbWEvYnVpbGQvaW5kZXguanM/MWU3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyMCwgUGVjdWxpYXIgVmVudHVyZXMsIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBKc29uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoaW5uZXJFcnJvclxyXG4gICAgICAgICAgICA/IGAke21lc3NhZ2V9LiBTZWUgdGhlIGlubmVyIGV4Y2VwdGlvbiBmb3IgbW9yZSBkZXRhaWxzLmBcclxuICAgICAgICAgICAgOiBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuaW5uZXJFcnJvciA9IGlubmVyRXJyb3I7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgVHJhbnNmb3JtRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUGFyc2VyRXJyb3IgZXh0ZW5kcyBUcmFuc2Zvcm1FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihzY2hlbWEsIGBKU09OIGRvZXNuJ3QgbWF0Y2ggdG8gJyR7c2NoZW1hLnRhcmdldC5uYW1lfScgc2NoZW1hLiAke21lc3NhZ2V9YCwgaW5uZXJFcnJvcik7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxufVxuXG5jbGFzcyBTZXJpYWxpemVyRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hTmFtZSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKGBDYW5ub3Qgc2VyaWFsaXplIGJ5ICcke3NjaGVtYU5hbWV9JyBzY2hlbWEuICR7bWVzc2FnZX1gLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFOYW1lO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEtleUVycm9yIGV4dGVuZHMgUGFyc2VyRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBrZXlzLCBlcnJvcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHNjaGVtYSwgXCJTb21lIGtleXMgZG9lc24ndCBtYXRjaCB0byBzY2hlbWFcIik7XHJcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxufVxuXG4oZnVuY3Rpb24gKEpzb25Qcm9wVHlwZXMpIHtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIkFueVwiXSA9IDBdID0gXCJBbnlcIjtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIkJvb2xlYW5cIl0gPSAxXSA9IFwiQm9vbGVhblwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiTnVtYmVyXCJdID0gMl0gPSBcIk51bWJlclwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiU3RyaW5nXCJdID0gM10gPSBcIlN0cmluZ1wiO1xyXG59KShleHBvcnRzLkpzb25Qcm9wVHlwZXMgfHwgKGV4cG9ydHMuSnNvblByb3BUeXBlcyA9IHt9KSk7XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQm9vbGVhbjpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuTnVtYmVyOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLlN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKCFjaGVja1R5cGUodmFsdWUsIHR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVmFsdWUgbXVzdCBiZSAke2V4cG9ydHMuSnNvblByb3BUeXBlc1t0eXBlXX1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0NvbnZlcnRpYmxlKHRhcmdldCkge1xyXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUudG9KU09OICYmIHRhcmdldC5wcm90b3R5cGUuZnJvbUpTT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNDb252ZXJ0aWJsZSh0YXJnZXQucHJvdG90eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gISEodGFyZ2V0ICYmIHRhcmdldC50b0pTT04gJiYgdGFyZ2V0LmZyb21KU09OKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uU2NoZW1hU3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgaGFzKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyh0YXJnZXQpIHx8ICEhdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBnZXQodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIXNjaGVtYSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgY3VycmVudCB0YXJnZXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0geyBuYW1lczoge30gfTtcclxuICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgICAgICBpZiAocGFyZW50U2NoZW1hKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBwYXJlbnRTY2hlbWEpO1xyXG4gICAgICAgICAgICBzY2hlbWEubmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHBhcmVudFNjaGVtYS5uYW1lcykge1xyXG4gICAgICAgICAgICAgICAgc2NoZW1hLm5hbWVzW25hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50U2NoZW1hLm5hbWVzW25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzY2hlbWEudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9XHJcbiAgICBzZXQodGFyZ2V0LCBzY2hlbWEpIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnNldCh0YXJnZXQsIHNjaGVtYSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBmaW5kUGFyZW50U2NoZW1hKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRhcmdldC5fX3Byb3RvX187XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldChwYXJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYShwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG5jb25zdCBERUZBVUxUX1NDSEVNQSA9IFwiZGVmYXVsdFwiO1xyXG5jb25zdCBzY2hlbWFTdG9yYWdlID0gbmV3IEpzb25TY2hlbWFTdG9yYWdlKCk7XG5cbmNsYXNzIFBhdHRlcm5WYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcclxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCh0aGlzLnBhdHRlcm4uc291cmNlLCB0aGlzLnBhdHRlcm4uZmxhZ3MpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkluY29taW5nIHZhbHVlIG11c3QgYmUgc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhdHRlcm4uZXhlYyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBwYXR0ZXJuICcke3BhdHRlcm4udG9TdHJpbmcoKX0nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEluY2x1c2l2ZVZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluID0gTnVtYmVyLk1JTl9WQUxVRSwgbWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gWyR7bWlufSwke21heH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEV4Y2x1c2l2ZVZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluID0gTnVtYmVyLk1JTl9WQUxVRSwgbWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluIDwgdmFsdWUgJiYgdmFsdWUgPCB0aGlzLm1heCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW4gPT09IE51bWJlci5NSU5fVkFMVUUgPyBcIk1JTlwiIDogdGhpcy5taW47XHJcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4ID09PSBOdW1iZXIuTUFYX1ZBTFVFID8gXCJNQVhcIiA6IHRoaXMubWF4O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIGRpYXBhc29uICgke21pbn0sJHttYXh9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBMZW5ndGhWYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IG1pbkxlbmd0aDtcclxuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIGV4YWN0bHkgJHt0aGlzLmxlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgdGhpcy5taW5MZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIG1vcmUgdGhhbiAke3RoaXMubWluTGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIGxlc3MgdGhhbiAke3RoaXMubWF4TGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBFbnVtZXJhdGlvblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZW51bWVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLmVudW1lcmF0aW9uID0gZW51bWVyYXRpb247XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLlN0cmluZyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVudW1lcmF0aW9uLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBtdXN0IGJlIG9uZSBvZiAke3RoaXMuZW51bWVyYXRpb24ubWFwKCh2KSA9PiBgJyR7dn0nYCkuam9pbihcIiwgXCIpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uVHJhbnNmb3JtIHtcclxuICAgIHN0YXRpYyBjaGVja1ZhbHVlcyhkYXRhLCBzY2hlbWFJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0aW9uIG9mIHNjaGVtYUl0ZW0udmFsaWRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uIGluc3RhbmNlb2YgTGVuZ3RoVmFsaWRhdGlvbiAmJiBzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24udmFsaWRhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNoZWNrVHlwZXModmFsdWUsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbHVlIG11c3QgYmUgQXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbS50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmVHlwZUlzV3Jvbmcodiwgc2NoZW1hSXRlbS50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTY2hlbWFCeU5hbWUoc2NoZW1hLCBuYW1lID0gREVGQVVMVF9TQ0hFTUEpIHtcclxuICAgICAgICByZXR1cm4geyAuLi5zY2hlbWEubmFtZXNbREVGQVVMVF9TQ0hFTUFdLCAuLi5zY2hlbWEubmFtZXNbbmFtZV0gfTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uU2VyaWFsaXplciBleHRlbmRzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmosIG9wdGlvbnMsIHJlcGxhY2VyLCBzcGFjZSkge1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB0aGlzLnRvSlNPTihvYmosIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uLCByZXBsYWNlciwgc3BhY2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRvSlNPTihvYmosIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGxldCByZXM7XHJcbiAgICAgICAgbGV0IHRhcmdldFNjaGVtYSA9IG9wdGlvbnMudGFyZ2V0U2NoZW1hO1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYU5hbWUgPSBvcHRpb25zLnNjaGVtYU5hbWUgfHwgREVGQVVMVF9TQ0hFTUE7XHJcbiAgICAgICAgaWYgKGlzQ29udmVydGlibGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnRvSlNPTihpdGVtLCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0U2NoZW1hICYmICFzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXRTY2hlbWEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvbkVycm9yKFwiQ2Fubm90IGdldCBzY2hlbWEgZm9yIGB0YXJnZXRTY2hlbWFgIHBhcmFtXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldFNjaGVtYSA9ICh0YXJnZXRTY2hlbWEgfHwgb2JqLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldFNjaGVtYSk7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVkU2NoZW1hID0gdGhpcy5nZXRTY2hlbWFCeU5hbWUoc2NoZW1hLCBzY2hlbWFOYW1lKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWVkU2NoZW1hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG5hbWVkU2NoZW1hW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iakl0ZW0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGl0ZW0ub3B0aW9uYWwgJiYgb2JqSXRlbSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqSXRlbSA9PT0gaXRlbS5kZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgb2JqSXRlbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplckVycm9yKHRhcmdldFNjaGVtYS5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbS5tYXAoKGVsKSA9PiBpdGVtLmNvbnZlcnRlci50b0pTT04oZWwsIG9iaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLmNvbnZlcnRlci50b0pTT04ob2JqSXRlbSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iakl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbS5tYXAoKGVsKSA9PiB0aGlzLnRvSlNPTihlbCwgeyBzY2hlbWFOYW1lIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50b0pTT04ob2JqSXRlbSwgeyBzY2hlbWFOYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tUeXBlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaXRlbS5uYW1lIHx8IGtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTZXJpYWxpemVyRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplckVycm9yKHNjaGVtYS50YXJnZXQubmFtZSwgYFByb3BlcnR5ICcke2tleX0nIGlzIHdyb25nLiAke2UubWVzc2FnZX1gLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSB0aGlzLnRvSlNPTihvYmpba2V5XSwgeyBzY2hlbWFOYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSnNvblBhcnNlciBleHRlbmRzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04odGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBjb25zdCBvYmogPSBuZXcgdGFyZ2V0U2NoZW1hKCk7XHJcbiAgICAgICAgaWYgKGlzQ29udmVydGlibGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmZyb21KU09OKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGtleUVycm9ycyA9IHt9O1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdFByb3BlcnR5ICYmICFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgSnNvblBhcnNlci5jaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWVkU2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm5hbWUgfHwga2V5O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAoaXRlbS5vcHRpb25hbCB8fCBpdGVtLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLm9wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3Ioc2NoZW1hLCBgUHJvcGVydHkgJyR7bmFtZX0nIGlzIHJlcXVpcmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaXRlbS50eXBlKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5tYXAoKGVsKSA9PiBpdGVtLmNvbnZlcnRlci5mcm9tSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGl0ZW0uY29udmVydGVyLmZyb21KU09OKHZhbHVlLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNjaGVtYTogaXRlbS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5tYXAoKGVsKSA9PiB0aGlzLmZyb21KU09OKGVsLCBuZXdPcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHRoaXMuZnJvbUpTT04odmFsdWUsIG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFBhcnNlckVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgUGFyc2VyRXJyb3Ioc2NoZW1hLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0QWxsS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleUVycm9yc1trZXldID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGtleUVycm9ycyk7XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMsIGtleUVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tTdHJpY3RQcm9wZXJ0eSh0YXJnZXQsIG5hbWVkU2NoZW1hLCBzY2hlbWEpIHtcclxuICAgICAgICBjb25zdCBqc29uUHJvcHMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYVByb3BzID0gT2JqZWN0LmtleXMobmFtZWRTY2hlbWEpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBqc29uUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5RXJyb3Ioc2NoZW1hLCBrZXlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbnMoaXRlbSkge1xyXG4gICAgY29uc3QgdmFsaWRhdGlvbnMgPSBbXTtcclxuICAgIGlmIChpdGVtLnBhdHRlcm4pIHtcclxuICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBQYXR0ZXJuVmFsaWRhdGlvbihpdGVtLnBhdHRlcm4pKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIgfHwgaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQW55KSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubWluSW5jbHVzaXZlICE9PSB1bmRlZmluZWQgfHwgaXRlbS5tYXhJbmNsdXNpdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBJbmNsdXNpdmVWYWxpZGF0aW9uKGl0ZW0ubWluSW5jbHVzaXZlLCBpdGVtLm1heEluY2x1c2l2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5taW5FeGNsdXNpdmUgIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heEV4Y2x1c2l2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEV4Y2x1c2l2ZVZhbGlkYXRpb24oaXRlbS5taW5FeGNsdXNpdmUsIGl0ZW0ubWF4RXhjbHVzaXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmVudW1lcmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgRW51bWVyYXRpb25WYWxpZGF0aW9uKGl0ZW0uZW51bWVyYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nIHx8IGl0ZW0ucmVwZWF0ZWQgfHwgaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQW55KSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSB1bmRlZmluZWQgfHwgaXRlbS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IExlbmd0aFZhbGlkYXRpb24oaXRlbS5sZW5ndGgsIGl0ZW0ubWluTGVuZ3RoLCBpdGVtLm1heExlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWxpZGF0aW9ucztcclxufVxyXG5jb25zdCBKc29uUHJvcCA9IChvcHRpb25zID0ge30pID0+ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQ2Fubm90IHNldCB0eXBlIGZvciAke3Byb3BlcnR5S2V5fSBwcm9wZXJ0eSBvZiAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBzY2hlbWFgO1xyXG4gICAgbGV0IHNjaGVtYTtcclxuICAgIGlmICghc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoc2NoZW1hLnRhcmdldCAhPT0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIHNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldC5jb25zdHJ1Y3Rvciwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0U2NoZW1hID0ge1xyXG4gICAgICAgIHR5cGU6IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnksXHJcbiAgICAgICAgdmFsaWRhdGlvbnM6IFtdLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvcHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0U2NoZW1hLCBvcHRpb25zKTtcclxuICAgIGNvcHlPcHRpb25zLnZhbGlkYXRpb25zID0gZ2V0VmFsaWRhdGlvbnMoY29weU9wdGlvbnMpO1xyXG4gICAgaWYgKHR5cGVvZiBjb3B5T3B0aW9ucy50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgaWYgKCFzY2hlbWFTdG9yYWdlLmhhcyhjb3B5T3B0aW9ucy50eXBlKSAmJiAhaXNDb252ZXJ0aWJsZShjb3B5T3B0aW9ucy50eXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfS4gQXNzaWduaW5nIHR5cGUgZG9lc24ndCBoYXZlIHNjaGVtYS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgc2NoZW1hTmFtZXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnNjaGVtYSkpIHtcclxuICAgICAgICBzY2hlbWFOYW1lcyA9IG9wdGlvbnMuc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hTmFtZXMgPSBbb3B0aW9ucy5zY2hlbWEgfHwgREVGQVVMVF9TQ0hFTUFdO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIHNjaGVtYU5hbWVzKSB7XHJcbiAgICAgICAgaWYgKCFzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV0pIHtcclxuICAgICAgICAgICAgc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWVkU2NoZW1hID0gc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdO1xyXG4gICAgICAgIG5hbWVkU2NoZW1hW3Byb3BlcnR5S2V5XSA9IGNvcHlPcHRpb25zO1xyXG4gICAgfVxyXG59O1xuXG5leHBvcnRzLkpzb25FcnJvciA9IEpzb25FcnJvcjtcbmV4cG9ydHMuSnNvblBhcnNlciA9IEpzb25QYXJzZXI7XG5leHBvcnRzLkpzb25Qcm9wID0gSnNvblByb3A7XG5leHBvcnRzLkpzb25TZXJpYWxpemVyID0gSnNvblNlcmlhbGl6ZXI7XG5leHBvcnRzLktleUVycm9yID0gS2V5RXJyb3I7XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5leHBvcnRzLlNlcmlhbGl6ZXJFcnJvciA9IFNlcmlhbGl6ZXJFcnJvcjtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IgPSBUcmFuc2Zvcm1FcnJvcjtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\nvar core = __webpack_require__(/*! webcrypto-core */ \"(ssr)/./node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.js\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(ssr)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar core__namespace = /*#__PURE__*/_interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/_interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/_interopNamespaceDefault(process);\n\nconst JsonBase64UrlConverter = {\r\n    fromJSON: (value) => Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\r\n    toJSON: (value) => pvtsutils.Convert.ToBase64Url(value),\r\n};\n\nclass CryptoKey extends core__namespace.CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.data = Buffer.alloc(0);\r\n        this.algorithm = { name: \"\" };\r\n        this.extractable = false;\r\n        this.type = \"secret\";\r\n        this.usages = [];\r\n        this.kty = \"oct\";\r\n        this.alg = \"\";\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"ext\", type: jsonSchema.JsonPropTypes.Boolean, optional: true })\r\n], CryptoKey.prototype, \"extractable\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"key_ops\", type: jsonSchema.JsonPropTypes.String, repeated: true, optional: true })\r\n], CryptoKey.prototype, \"usages\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String })\r\n], CryptoKey.prototype, \"kty\", void 0);\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, optional: true })\r\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.kty = \"oct\";\r\n        this.type = \"secret\";\r\n    }\r\n}\n\nclass AsymmetricKey extends CryptoKey {\r\n}\n\nclass AesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return `A${this.algorithm.length}CBC`;\r\n            case \"AES-CTR\":\r\n                return `A${this.algorithm.length}CTR`;\r\n            case \"AES-GCM\":\r\n                return `A${this.algorithm.length}GCM`;\r\n            case \"AES-KW\":\r\n                return `A${this.algorithm.length}KW`;\r\n            case \"AES-CMAC\":\r\n                return `A${this.algorithm.length}CMAC`;\r\n            case \"AES-ECB\":\r\n                return `A${this.algorithm.length}ECB`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], AesCryptoKey.prototype, \"data\", void 0);\n\nconst keyStorage = new WeakMap();\r\nfunction getCryptoKey(key) {\r\n    const res = keyStorage.get(key);\r\n    if (!res) {\r\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\r\n    }\r\n    return res;\r\n}\r\nfunction setCryptoKey(value) {\r\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\r\n    Object.freeze(key);\r\n    keyStorage.set(key, value);\r\n    return key;\r\n}\n\nclass AesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new AesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new AesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.algorithm.length = key.data.length << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        switch (key.algorithm.length) {\r\n            case 128:\r\n            case 192:\r\n            case 256:\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\r\n        }\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof AesCryptoKey)) {\r\n            throw new Error(\"key: Is not AesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"AES-CBC\":\r\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\r\n            case \"AES-CTR\":\r\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\r\n            case \"AES-GCM\":\r\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\r\n            case \"AES-KW\":\r\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\r\n            case \"AES-ECB\":\r\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptAesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesCTR(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesCTR(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesGCM(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\r\n            authTagLength: (algorithm.tagLength || 128) >> 3,\r\n        });\r\n        if (algorithm.additionalData) {\r\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final(), cipher.getAuthTag()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesGCM(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\r\n        const tagLength = (algorithm.tagLength || 128) >> 3;\r\n        const enc = data.slice(0, data.length - tagLength);\r\n        const tag = data.slice(data.length - tagLength);\r\n        if (algorithm.additionalData) {\r\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\r\n        }\r\n        decipher.setAuthTag(tag);\r\n        let dec = decipher.update(enc);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesKW(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    static async decryptAesKW(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptAesECB(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptAesECB(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\r\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nconst zero = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\r\nconst rb = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\r\nconst blockSize = 16;\r\nfunction bitShiftLeft(buffer) {\r\n    const shifted = Buffer.alloc(buffer.length);\r\n    const last = buffer.length - 1;\r\n    for (let index = 0; index < last; index++) {\r\n        shifted[index] = buffer[index] << 1;\r\n        if (buffer[index + 1] & 0x80) {\r\n            shifted[index] += 0x01;\r\n        }\r\n    }\r\n    shifted[last] = buffer[last] << 1;\r\n    return shifted;\r\n}\r\nfunction xor(a, b) {\r\n    const length = Math.min(a.length, b.length);\r\n    const output = Buffer.alloc(length);\r\n    for (let index = 0; index < length; index++) {\r\n        output[index] = a[index] ^ b[index];\r\n    }\r\n    return output;\r\n}\r\nfunction aes(key, message) {\r\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\r\n    const result = cipher.update(message);\r\n    cipher.final();\r\n    return result;\r\n}\r\nfunction getMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = start + blockSize;\r\n    message.copy(block, 0, start, end);\r\n    return block;\r\n}\r\nfunction getPaddedMessageBlock(message, blockIndex) {\r\n    const block = Buffer.alloc(blockSize);\r\n    const start = blockIndex * blockSize;\r\n    const end = message.length;\r\n    block.fill(0);\r\n    message.copy(block, 0, start, end);\r\n    block[end - start] = 0x80;\r\n    return block;\r\n}\r\nfunction generateSubkeys(key) {\r\n    const l = aes(key, zero);\r\n    let subkey1 = bitShiftLeft(l);\r\n    if (l[0] & 0x80) {\r\n        subkey1 = xor(subkey1, rb);\r\n    }\r\n    let subkey2 = bitShiftLeft(subkey1);\r\n    if (subkey1[0] & 0x80) {\r\n        subkey2 = xor(subkey2, rb);\r\n    }\r\n    return { subkey1, subkey2 };\r\n}\r\nfunction aesCmac(key, message) {\r\n    const subkeys = generateSubkeys(key);\r\n    let blockCount = Math.ceil(message.length / blockSize);\r\n    let lastBlockCompleteFlag;\r\n    let lastBlock;\r\n    if (blockCount === 0) {\r\n        blockCount = 1;\r\n        lastBlockCompleteFlag = false;\r\n    }\r\n    else {\r\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\r\n    }\r\n    const lastBlockIndex = blockCount - 1;\r\n    if (lastBlockCompleteFlag) {\r\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\r\n    }\r\n    else {\r\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\r\n    }\r\n    let x = zero;\r\n    let y;\r\n    for (let index = 0; index < lastBlockIndex; index++) {\r\n        y = xor(x, getMessageBlock(message, index));\r\n        x = aes(key, y);\r\n    }\r\n    y = xor(lastBlock, x);\r\n    return aes(key, y);\r\n}\r\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\r\n        return new Uint8Array(result).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const signature2 = await this.sign(algorithm, key, data);\r\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesKwProvider extends core__namespace.AesKwProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await AesCrypto.generateKey({\r\n            name: this.name,\r\n            length: algorithm.length,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return AesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\r\n        return setCryptoKey(res);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesCryptoKey extends SymmetricKey {\r\n    get alg() {\r\n        switch (this.algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return `DES-CBC`;\r\n            case \"DES-EDE3-CBC\":\r\n                return `3DES-CBC`;\r\n            default:\r\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\r\n        }\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const key = new DesCryptoKey();\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(algorithm.length >> 3);\r\n        return key;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"raw\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new DesCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = algorithm;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        if (!(key instanceof DesCryptoKey)) {\r\n            throw new Error(\"key: Is not DesCryptoKey\");\r\n        }\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"DES-CBC\":\r\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\r\n            case \"DES-EDE3-CBC\":\r\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encryptDesCBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesCBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    static async encryptDesEDE3CBC(algorithm, key, data) {\r\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\r\n        let enc = cipher.update(data);\r\n        enc = Buffer.concat([enc, cipher.final()]);\r\n        const res = new Uint8Array(enc).buffer;\r\n        return res;\r\n    }\r\n    static async decryptDesEDE3CBC(algorithm, key, data) {\r\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\r\n        let dec = decipher.update(data);\r\n        dec = Buffer.concat([dec, decipher.final()]);\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n}\n\nclass DesCbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 64;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.keySizeBits = 192;\r\n        this.ivSize = 8;\r\n        this.name = \"DES-EDE3-CBC\";\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.generateKey({\r\n            name: this.name,\r\n            length: this.keySizeBits,\r\n        }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return DesCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\r\n        if (key.data.length !== (this.keySizeBits >> 3)) {\r\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\r\n        }\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\r\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\r\n        }\r\n    }\r\n}\n\nfunction getJwkAlgorithm(algorithm) {\r\n    switch (algorithm.name.toUpperCase()) {\r\n        case \"RSA-OAEP\": {\r\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\r\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\r\n        }\r\n        case \"RSASSA-PKCS1-V1_5\":\r\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PSS\":\r\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\r\n        case \"RSA-PKCS1\":\r\n            return `RS1`;\r\n        default:\r\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n    }\r\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"RSA\",\r\n            alg: getJwkAlgorithm(this.algorithm),\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n    }\r\n}\n\nclass RsaCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new RsaPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new RsaPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const publicExponent = Buffer.concat([\r\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\r\n            Buffer.from(algorithm.publicExponent),\r\n        ]).readInt32BE(0);\r\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\r\n            modulusLength: algorithm.modulusLength,\r\n            publicExponent,\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.RsaPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.signRsa(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-PSS\":\r\n            case \"RSASSA-PKCS1-V1_5\":\r\n                return this.verifySSA(algorithm, key, data, signature);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async encrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.encryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static async decrypt(algorithm, key, data) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"RSA-OAEP\":\r\n                return this.decryptOAEP(algorithm, key, data);\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = null;\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = null;\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new RsaPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\r\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getCryptoAlgorithm(alg) {\r\n        switch (alg.hash.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"RSA-SHA1\";\r\n            case \"SHA-256\":\r\n                return \"RSA-SHA256\";\r\n            case \"SHA-384\":\r\n                return \"RSA-SHA384\";\r\n            case \"SHA-512\":\r\n                return \"RSA-SHA512\";\r\n            case \"SHA3-256\":\r\n                return \"RSA-SHA3-256\";\r\n            case \"SHA3-384\":\r\n                return \"RSA-SHA3-384\";\r\n            case \"SHA3-512\":\r\n                return \"RSA-SHA3-512\";\r\n            default:\r\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\r\n        }\r\n    }\r\n    static signRsa(algorithm, key, data) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const signature = signer.sign(options);\r\n        return new Uint8Array(signature).buffer;\r\n    }\r\n    static verifySSA(algorithm, key, data, signature) {\r\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\r\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\r\n            options.saltLength = algorithm.saltLength;\r\n        }\r\n        const ok = signer.verify(options, signature);\r\n        return ok;\r\n    }\r\n    static encryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\r\n    }\r\n    static decryptOAEP(algorithm, key, data) {\r\n        const options = {\r\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\r\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\r\n        };\r\n        if (algorithm.label) ;\r\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\r\n    }\r\n}\r\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\r\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShaCrypto {\r\n    static size(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return 160;\r\n            case \"SHA-256\":\r\n            case \"SHA3-256\":\r\n                return 256;\r\n            case \"SHA-384\":\r\n            case \"SHA3-384\":\r\n                return 384;\r\n            case \"SHA-512\":\r\n            case \"SHA3-512\":\r\n                return 512;\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static getAlgorithmName(algorithm) {\r\n        switch (algorithm.name.toUpperCase()) {\r\n            case \"SHA-1\":\r\n                return \"sha1\";\r\n            case \"SHA-256\":\r\n                return \"sha256\";\r\n            case \"SHA-384\":\r\n                return \"sha384\";\r\n            case \"SHA-512\":\r\n                return \"sha512\";\r\n            case \"SHA3-256\":\r\n                return \"sha3-256\";\r\n            case \"SHA3-384\":\r\n                return \"sha3-384\";\r\n            case \"SHA3-512\":\r\n                return \"sha3-512\";\r\n            default:\r\n                throw new Error(\"Unrecognized name\");\r\n        }\r\n    }\r\n    static digest(algorithm, data) {\r\n        const hashAlg = this.getAlgorithmName(algorithm);\r\n        const hash = crypto.createHash(hashAlg)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const dataView = new Uint8Array(data);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = dataView.byteLength;\r\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\r\n        if (dataLength > keySize - 2 * hashSize - 2) {\r\n            throw new Error(\"Data too large\");\r\n        }\r\n        const message = new Uint8Array(keySize);\r\n        const seed = message.subarray(1, hashSize + 1);\r\n        const dataBlock = message.subarray(hashSize + 1);\r\n        dataBlock.set(dataView, hashSize + psLength + 1);\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        dataBlock.set(labelHash, 0);\r\n        dataBlock[hashSize + psLength] = 1;\r\n        crypto.randomFillSync(seed);\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const pkcs0 = crypto.publicEncrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(message));\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const internalKey = getCryptoKey(key);\r\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\r\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\r\n        const dataLength = data.byteLength;\r\n        if (dataLength !== keySize) {\r\n            throw new Error(\"Bad data\");\r\n        }\r\n        if (!internalKey.pem) {\r\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        let pkcs0 = crypto.privateDecrypt({\r\n            key: internalKey.pem,\r\n            padding: crypto.constants.RSA_NO_PADDING,\r\n        }, Buffer.from(data));\r\n        const z = pkcs0[0];\r\n        const seed = pkcs0.subarray(1, hashSize + 1);\r\n        const dataBlock = pkcs0.subarray(hashSize + 1);\r\n        if (z !== 0) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\r\n        for (let i = 0; i < seed.length; i++) {\r\n            seed[i] ^= seedMask[i];\r\n        }\r\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\r\n        for (let i = 0; i < dataBlock.length; i++) {\r\n            dataBlock[i] ^= dataBlockMask[i];\r\n        }\r\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\r\n            .update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\r\n            .digest();\r\n        for (let i = 0; i < hashSize; i++) {\r\n            if (labelHash[i] !== dataBlock[i]) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        let psEnd = hashSize;\r\n        for (; psEnd < dataBlock.length; psEnd++) {\r\n            const psz = dataBlock[psEnd];\r\n            if (psz === 1) {\r\n                break;\r\n            }\r\n            if (psz !== 0) {\r\n                throw new Error(\"Decryption failed\");\r\n            }\r\n        }\r\n        if (psEnd === dataBlock.length) {\r\n            throw new Error(\"Decryption failed\");\r\n        }\r\n        pkcs0 = dataBlock.subarray(psEnd + 1);\r\n        return new Uint8Array(pkcs0).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    mgf1(algorithm, seed, length = 0) {\r\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\r\n        const mask = new Uint8Array(length);\r\n        const counter = new Uint8Array(4);\r\n        const chunks = Math.ceil(length / hashSize);\r\n        for (let i = 0; i < chunks; i++) {\r\n            counter[0] = i >>> 24;\r\n            counter[1] = (i >>> 16) & 255;\r\n            counter[2] = (i >>> 8) & 255;\r\n            counter[3] = i & 255;\r\n            const submask = mask.subarray(i * hashSize);\r\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\"))\r\n                .update(seed)\r\n                .update(counter)\r\n                .digest();\r\n            if (chunk.length > submask.length) {\r\n                chunk = chunk.subarray(0, submask.length);\r\n            }\r\n            submask.set(chunk);\r\n        }\r\n        return mask;\r\n    }\r\n}\n\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"RSAES-PKCS1-v1_5\";\r\n        this.usages = {\r\n            publicKey: [\"encrypt\", \"wrapKey\"],\r\n            privateKey: [\"decrypt\", \"unwrapKey\"],\r\n        };\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await RsaCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    checkGenerateKeyParams(algorithm) {\r\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\r\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\r\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\r\n        }\r\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\r\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\r\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\r\n        }\r\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\r\n        switch (algorithm.modulusLength) {\r\n            case 1024:\r\n            case 2048:\r\n            case 4096:\r\n                break;\r\n            default:\r\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\r\n        }\r\n    }\r\n    async onEncrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(enc).buffer;\r\n    }\r\n    async onDecrypt(algorithm, key, data) {\r\n        const options = this.toCryptoOptions(key);\r\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\r\n        return new Uint8Array(dec).buffer;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\r\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\r\n        }\r\n    }\r\n    toCryptoOptions(key) {\r\n        const type = key.type.toUpperCase();\r\n        return {\r\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\r\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING,\r\n        };\r\n    }\r\n}\n\nconst namedOIDs = {\r\n    \"1.2.840.10045.3.1.7\": \"P-256\",\r\n    \"P-256\": \"1.2.840.10045.3.1.7\",\r\n    \"1.3.132.0.34\": \"P-384\",\r\n    \"P-384\": \"1.3.132.0.34\",\r\n    \"1.3.132.0.35\": \"P-521\",\r\n    \"P-521\": \"1.3.132.0.35\",\r\n    \"1.3.132.0.10\": \"K-256\",\r\n    \"K-256\": \"1.3.132.0.10\",\r\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\r\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\r\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\r\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\r\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\r\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\r\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\r\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\r\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\r\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\r\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\r\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\r\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\r\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\r\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\r\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\r\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\r\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\r\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\r\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\r\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\r\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\r\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\r\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\r\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\r\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\r\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\r\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\",\r\n};\r\nfunction getOidByNamedCurve$1(namedCurve) {\r\n    const oid = namedOIDs[namedCurve];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EcPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EcPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"EC\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\r\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass Sha1Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-1\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-256\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-384\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.name = \"SHA3-512\";\r\n        this.usages = [];\r\n    }\r\n    async onDigest(algorithm, data) {\r\n        return ShaCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass EcCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EcPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EcPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const keys = crypto.generateKeyPairSync(\"ec\", {\r\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createSign(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = signer.sign(options);\r\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\r\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\r\n        return signatureRaw.buffer;\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\r\n        const signer = crypto.createVerify(cryptoAlg);\r\n        signer.update(Buffer.from(data));\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\r\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\r\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\r\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\r\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\r\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\r\n        const ok = signer.verify(options, ecSignatureRaw);\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\r\n        const ecdh = crypto.createECDH(cryptoAlg);\r\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\r\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\r\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\r\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\r\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\r\n        if (length === null) {\r\n            return bits;\r\n        }\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.EcPublicKey });\r\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\r\n                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\r\n                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static assertKeyParameters(parameters, namedCurve) {\r\n        if (!parameters) {\r\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\r\n        }\r\n        let namedCurveIdentifier = \"\";\r\n        try {\r\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\r\n        }\r\n        catch (e) {\r\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\r\n        }\r\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\r\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\r\n        }\r\n    }\r\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\r\n        const key = new EcPrivateKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\r\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\r\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\r\n        keyInfo.publicKey = asnKey.value;\r\n        const key = new EcPublicKey();\r\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static getOpenSSLNamedCurve(curve) {\r\n        switch (curve.toUpperCase()) {\r\n            case \"P-256\":\r\n                return \"prime256v1\";\r\n            case \"K-256\":\r\n                return \"secp256k1\";\r\n            case \"P-384\":\r\n                return \"secp384r1\";\r\n            case \"P-521\":\r\n                return \"secp521r1\";\r\n            default:\r\n                return curve;\r\n        }\r\n    }\r\n}\r\nEcCrypto.publicKeyUsages = [\"verify\"];\r\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n        this.hashAlgorithms = [\r\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\r\n            \"shake128\", \"shake256\",\r\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\r\n        ];\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass EcdhProvider extends core__namespace.EcdhProvider {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.namedCurves = core__namespace.EcCurves.names;\r\n    }\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EcCrypto.generateKey({\r\n            ...algorithm,\r\n            name: this.name,\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EcCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        const internalKey = getCryptoKey(key);\r\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\r\n            throw new TypeError(\"key: Is not EC CryptoKey\");\r\n        }\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n}\n\nconst edOIDs = {\r\n    [core__namespace.asn1.idEd448]: \"Ed448\",\r\n    \"ed448\": core__namespace.asn1.idEd448,\r\n    [core__namespace.asn1.idX448]: \"X448\",\r\n    \"x448\": core__namespace.asn1.idX448,\r\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\r\n    \"ed25519\": core__namespace.asn1.idEd25519,\r\n    [core__namespace.asn1.idX25519]: \"X25519\",\r\n    \"x25519\": core__namespace.asn1.idX25519,\r\n};\r\nfunction getOidByNamedCurve(namedCurve) {\r\n    const oid = edOIDs[namedCurve.toLowerCase()];\r\n    if (!oid) {\r\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\r\n    }\r\n    return oid;\r\n}\n\nclass EdPrivateKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"private\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\r\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\r\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        const key = jsonSchema.JsonParser.fromJSON(json, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdPublicKey extends AsymmetricKey {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"public\";\r\n    }\r\n    getKey() {\r\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\r\n        return keyInfo.publicKey;\r\n    }\r\n    toJSON() {\r\n        const key = this.getKey();\r\n        const json = {\r\n            kty: \"OKP\",\r\n            crv: this.algorithm.namedCurve,\r\n            key_ops: this.usages,\r\n            ext: this.extractable,\r\n        };\r\n        return Object.assign(json, {\r\n            x: pvtsutils.Convert.ToBase64Url(key)\r\n        });\r\n    }\r\n    fromJSON(json) {\r\n        if (!json.crv) {\r\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\r\n        }\r\n        if (!json.x) {\r\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\r\n        }\r\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\r\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\r\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\r\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\r\n        return this;\r\n    }\r\n}\n\nclass EdCrypto {\r\n    static async generateKey(algorithm, extractable, keyUsages) {\r\n        const privateKey = new EdPrivateKey();\r\n        privateKey.algorithm = algorithm;\r\n        privateKey.extractable = extractable;\r\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\r\n        const publicKey = new EdPublicKey();\r\n        publicKey.algorithm = algorithm;\r\n        publicKey.extractable = true;\r\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\r\n        const type = algorithm.namedCurve.toLowerCase();\r\n        const keys = crypto.generateKeyPairSync(type, {\r\n            publicKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"spki\",\r\n            },\r\n            privateKeyEncoding: {\r\n                format: \"der\",\r\n                type: \"pkcs8\",\r\n            },\r\n        });\r\n        privateKey.data = keys.privateKey;\r\n        publicKey.data = keys.publicKey;\r\n        const res = {\r\n            privateKey,\r\n            publicKey,\r\n        };\r\n        return res;\r\n    }\r\n    static async sign(algorithm, key, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const signature = crypto.sign(null, Buffer.from(data), options);\r\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\r\n    }\r\n    static async verify(algorithm, key, signature, data) {\r\n        if (!key.pem) {\r\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\r\n        }\r\n        const options = {\r\n            key: key.pem,\r\n        };\r\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\r\n        return ok;\r\n    }\r\n    static async deriveBits(algorithm, baseKey, length) {\r\n        const publicKey = crypto.createPublicKey({\r\n            key: algorithm.public.data,\r\n            format: \"der\",\r\n            type: \"spki\",\r\n        });\r\n        const privateKey = crypto.createPrivateKey({\r\n            key: baseKey.data,\r\n            format: \"der\",\r\n            type: \"pkcs8\",\r\n        });\r\n        const bits = crypto.diffieHellman({\r\n            publicKey,\r\n            privateKey,\r\n        });\r\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\r\n    }\r\n    static async exportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(key);\r\n            case \"pkcs8\":\r\n            case \"spki\":\r\n                return new Uint8Array(key.data).buffer;\r\n            case \"raw\": {\r\n                const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\r\n                return publicKeyInfo.publicKey;\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\": {\r\n                const jwk = keyData;\r\n                if (jwk.d) {\r\n                    const asnKey = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: core__namespace.asn1.CurvePrivateKey });\r\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n                }\r\n                else {\r\n                    if (!jwk.x) {\r\n                        throw new TypeError(\"keyData: Cannot get required 'x' filed\");\r\n                    }\r\n                    return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\r\n                }\r\n            }\r\n            case \"raw\": {\r\n                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"spki\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\r\n                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\r\n            }\r\n            case \"pkcs8\": {\r\n                const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\r\n                const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\r\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\r\n            }\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\r\n        }\r\n    }\r\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPrivateKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\r\n        const key = new EdPublicKey();\r\n        key.fromJSON({\r\n            crv: algorithm.namedCurve,\r\n            x: pvtsutils.Convert.ToBase64Url(asnKey),\r\n        });\r\n        key.algorithm = Object.assign({}, algorithm);\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return key;\r\n    }\r\n}\r\nEdCrypto.publicKeyUsages = [\"verify\"];\r\nEdCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\"),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const keys = await EdCrypto.generateKey({\r\n            name: this.name,\r\n            namedCurve: algorithm.namedCurve.toUpperCase(),\r\n        }, extractable, keyUsages);\r\n        return {\r\n            privateKey: setCryptoKey(keys.privateKey),\r\n            publicKey: setCryptoKey(keys.publicKey),\r\n        };\r\n    }\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\r\n        return bits;\r\n    }\r\n    async onExportKey(format, key) {\r\n        return EdCrypto.exportKey(format, getCryptoKey(key));\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\r\n        return setCryptoKey(key);\r\n    }\r\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\r\n}\n\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\r\n    async onDeriveBits(algorithm, baseKey, length) {\r\n        return new Promise((resolve, reject) => {\r\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\r\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\r\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\r\n                if (err) {\r\n                    reject(err);\r\n                }\r\n                else {\r\n                    resolve(new Uint8Array(derivedBits).buffer);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format === \"raw\") {\r\n            const key = new PbkdfCryptoKey();\r\n            key.data = Buffer.from(keyData);\r\n            key.algorithm = { name: this.name };\r\n            key.extractable = false;\r\n            key.usages = keyUsages;\r\n            return setCryptoKey(key);\r\n        }\r\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HmacCryptoKey extends CryptoKey {\r\n    get alg() {\r\n        const hash = this.algorithm.hash.name.toUpperCase();\r\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\r\n    }\r\n    set alg(value) {\r\n    }\r\n}\r\ntslib.__decorate([\r\n    jsonSchema.JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\r\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends core__namespace.HmacProvider {\r\n    async onGenerateKey(algorithm, extractable, keyUsages) {\r\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\r\n        const key = new HmacCryptoKey();\r\n        key.algorithm = {\r\n            ...algorithm,\r\n            length,\r\n            name: this.name,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        key.data = crypto.randomBytes(length >> 3);\r\n        return setCryptoKey(key);\r\n    }\r\n    async onSign(algorithm, key, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hmac).buffer;\r\n    }\r\n    async onVerify(algorithm, key, signature, data) {\r\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\r\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\r\n            .update(Buffer.from(data)).digest();\r\n        return hmac.compare(Buffer.from(signature)) === 0;\r\n    }\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        let key;\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                key = jsonSchema.JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\r\n                break;\r\n            case \"raw\":\r\n                key = new HmacCryptoKey();\r\n                key.data = Buffer.from(keyData);\r\n                break;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n        key.algorithm = {\r\n            hash: { name: algorithm.hash.name },\r\n            name: this.name,\r\n            length: key.data.length << 3,\r\n        };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onExportKey(format, key) {\r\n        switch (format.toLowerCase()) {\r\n            case \"jwk\":\r\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\r\n            case \"raw\":\r\n                return new Uint8Array(getCryptoKey(key).data).buffer;\r\n            default:\r\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\r\n        }\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass HkdfCryptoKey extends CryptoKey {\r\n}\n\nclass HkdfProvider extends core__namespace.HkdfProvider {\r\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\r\n        if (format.toLowerCase() !== \"raw\") {\r\n            throw new core__namespace.OperationError(\"Operation not supported\");\r\n        }\r\n        const key = new HkdfCryptoKey();\r\n        key.data = Buffer.from(keyData);\r\n        key.algorithm = { name: this.name };\r\n        key.extractable = extractable;\r\n        key.usages = keyUsages;\r\n        return setCryptoKey(key);\r\n    }\r\n    async onDeriveBits(params, baseKey, length) {\r\n        const hash = params.hash.name.replace(\"-\", \"\");\r\n        const hashLength = crypto.createHash(hash).digest().length;\r\n        const byteLength = length / 8;\r\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\r\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt))\r\n            .update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data))\r\n            .digest();\r\n        const blocks = [Buffer.alloc(0)];\r\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\r\n        for (let i = 1; i < blockCount; ++i) {\r\n            blocks.push(crypto.createHmac(hash, PRK)\r\n                .update(Buffer.concat([blocks[i - 1], info, Buffer.from([i])]))\r\n                .digest());\r\n        }\r\n        return Buffer.concat(blocks).slice(0, byteLength);\r\n    }\r\n    checkCryptoKey(key, keyUsage) {\r\n        super.checkCryptoKey(key, keyUsage);\r\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\r\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\r\n        }\r\n    }\r\n}\n\nclass ShakeCrypto {\r\n    static digest(algorithm, data) {\r\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })\r\n            .update(Buffer.from(data)).digest();\r\n        return new Uint8Array(hash).buffer;\r\n    }\r\n}\n\nclass Shake128Provider extends core__namespace.Shake128Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass Shake256Provider extends core__namespace.Shake256Provider {\r\n    async onDigest(algorithm, data) {\r\n        return ShakeCrypto.digest(algorithm, data);\r\n    }\r\n}\n\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\r\n    constructor() {\r\n        var _a;\r\n        super();\r\n        this.providers.set(new AesCbcProvider());\r\n        this.providers.set(new AesCtrProvider());\r\n        this.providers.set(new AesGcmProvider());\r\n        this.providers.set(new AesCmacProvider());\r\n        this.providers.set(new AesKwProvider());\r\n        this.providers.set(new AesEcbProvider());\r\n        this.providers.set(new DesCbcProvider());\r\n        this.providers.set(new DesEde3CbcProvider());\r\n        this.providers.set(new RsaSsaProvider());\r\n        this.providers.set(new RsaPssProvider());\r\n        this.providers.set(new RsaOaepProvider());\r\n        this.providers.set(new RsaEsProvider());\r\n        this.providers.set(new EcdsaProvider());\r\n        this.providers.set(new EcdhProvider());\r\n        this.providers.set(new Sha1Provider());\r\n        this.providers.set(new Sha256Provider());\r\n        this.providers.set(new Sha384Provider());\r\n        this.providers.set(new Sha512Provider());\r\n        this.providers.set(new Pbkdf2Provider());\r\n        this.providers.set(new HmacProvider());\r\n        this.providers.set(new HkdfProvider());\r\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\r\n            this.providers.set(new Shake128Provider());\r\n            this.providers.set(new Shake256Provider());\r\n        }\r\n        const hashes = crypto__namespace.getHashes();\r\n        if (hashes.includes(\"sha3-256\")) {\r\n            this.providers.set(new Sha3256Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-384\")) {\r\n            this.providers.set(new Sha3384Provider());\r\n        }\r\n        if (hashes.includes(\"sha3-512\")) {\r\n            this.providers.set(new Sha3512Provider());\r\n        }\r\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\r\n            this.providers.set(new EdDsaProvider());\r\n            this.providers.set(new EcdhEsProvider());\r\n        }\r\n    }\r\n}\n\nclass Crypto extends core__namespace.Crypto {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.subtle = new SubtleCrypto();\r\n    }\r\n    getRandomValues(array) {\r\n        if (!ArrayBuffer.isView(array)) {\r\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\r\n        }\r\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\r\n        crypto.randomFillSync(buffer);\r\n        return array;\r\n    }\r\n}\n\nObject.defineProperty(exports, \"CryptoKey\", ({\n  enumerable: true,\n  get: function () { return core.CryptoKey; }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxtRkFBZ0I7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsc0RBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ2hELGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1Qjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIscUVBQXFFO0FBQy9GO0FBQ0E7QUFDQSwwQkFBMEIsd0ZBQXdGO0FBQ2xIO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsdURBQXVEO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDRCQUE0QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QscUJBQXFCO0FBQ3pFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0JBQWdCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHNCQUFzQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNEJBQTRCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQ0FBMkM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJDQUEyQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscUJBQXFCLE9BQU8sT0FBTztBQUNqRTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBLHdCQUF3QixzQ0FBc0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsa0RBQWtEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaURBQWlEO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsa0RBQWtEO0FBQy9IO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpREFBaUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNEJBQTRCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLCtCQUErQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsK0JBQStCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG9DQUFvQztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG9DQUFvQztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrQkFBK0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwrQkFBK0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU0sWUFBWSwwQ0FBMEMsYUFBYSxNQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVztBQUNyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpREFBaUQ7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGdEQUFnRDtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDRCQUE0QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDRCQUE0QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxpREFBaUQ7QUFDOUg7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGdEQUFnRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxvREFBb0Q7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNEJBQTRCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxvREFBb0Q7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtCQUErQjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0RBQXNEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSwrQkFBK0I7QUFDL0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZCQUE2QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUUsZ0NBQWdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1QztBQUNBLHFCQUFxQjtBQUNyQixDQUFDLEVBQUM7QUFDRixjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci93ZWJjcnlwdG8vYnVpbGQvd2ViY3J5cHRvLmpzPzU4MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViY3J5cHRvLWNvcmUnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2VzcycpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBqc29uU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2pzb24tc2NoZW1hJyk7XG52YXIgcHZ0c3V0aWxzID0gcmVxdWlyZSgncHZ0c3V0aWxzJyk7XG52YXIgYXNuMVNjaGVtYSA9IHJlcXVpcmUoJ0BwZWN1bGlhci9hc24xLXNjaGVtYScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbi5kZWZhdWx0ID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb3JlX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGNvcmUpO1xudmFyIGNyeXB0b19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChjcnlwdG8pO1xudmFyIHByb2Nlc3NfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQocHJvY2Vzcyk7XG5cbmNvbnN0IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgPSB7XHJcbiAgICBmcm9tSlNPTjogKHZhbHVlKSA9PiBCdWZmZXIuZnJvbShwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKHZhbHVlKSksXHJcbiAgICB0b0pTT046ICh2YWx1ZSkgPT4gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodmFsdWUpLFxyXG59O1xuXG5jbGFzcyBDcnlwdG9LZXkgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xyXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0geyBuYW1lOiBcIlwiIH07XHJcbiAgICAgICAgdGhpcy5leHRyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwic2VjcmV0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmt0eSA9IFwib2N0XCI7XHJcbiAgICAgICAgdGhpcy5hbGcgPSBcIlwiO1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZXh0XCIsIHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5Cb29sZWFuLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImV4dHJhY3RhYmxlXCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia2V5X29wc1wiLCB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nLCByZXBlYXRlZDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfSlcclxuXSwgQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJ1c2FnZXNcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZyB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImt0eVwiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImFsZ1wiLCB2b2lkIDApO1xuXG5jbGFzcyBTeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmt0eSA9IFwib2N0XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBBc3ltbWV0cmljS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBBZXNDcnlwdG9LZXkgZXh0ZW5kcyBTeW1tZXRyaWNLZXkge1xyXG4gICAgZ2V0IGFsZygpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q0JDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNUUmA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtR0NNXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1HQ01gO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1LV2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ01BQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q01BQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1FQ0JgO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5BbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIEFlc0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jb25zdCBrZXlTdG9yYWdlID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gZ2V0Q3J5cHRvS2V5KGtleSkge1xyXG4gICAgY29uc3QgcmVzID0ga2V5U3RvcmFnZS5nZXQoa2V5KTtcclxuICAgIGlmICghcmVzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcIkNhbm5vdCBnZXQgQ3J5cHRvS2V5IGZyb20gc2VjdXJlIHN0b3JhZ2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHNldENyeXB0b0tleSh2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5ID0gY29yZV9fbmFtZXNwYWNlLkNyeXB0b0tleS5jcmVhdGUodmFsdWUuYWxnb3JpdGhtLCB2YWx1ZS50eXBlLCB2YWx1ZS5leHRyYWN0YWJsZSwgdmFsdWUudXNhZ2VzKTtcclxuICAgIE9iamVjdC5mcmVlemUoa2V5KTtcclxuICAgIGtleVN0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIGtleTtcclxufVxuXG5jbGFzcyBBZXNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBBZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYWxnb3JpdGhtLmxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IEFlc0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgQWVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubGVuZ3RoID0ga2V5LmRhdGEubGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTI4OlxyXG4gICAgICAgICAgICBjYXNlIDE5MjpcclxuICAgICAgICAgICAgY2FzZSAyNTY6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBJcyB3cm9uZyBrZXkgbGVuZ3RoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY3RyYCwga2V5LmRhdGEsIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5jb3VudGVyKSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLmNvdW50ZXIpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZ2NtYCwga2V5LmRhdGEsIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5pdiksIHtcclxuICAgICAgICAgICAgYXV0aFRhZ0xlbmd0aDogKGFsZ29yaXRobS50YWdMZW5ndGggfHwgMTI4KSA+PiAzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgY2lwaGVyLnNldEFBRChCdWZmZXIuZnJvbShhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKSwgY2lwaGVyLmdldEF1dGhUYWcoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgY29uc3QgdGFnTGVuZ3RoID0gKGFsZ29yaXRobS50YWdMZW5ndGggfHwgMTI4KSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGVuYyA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSB0YWdMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IGRhdGEuc2xpY2UoZGF0YS5sZW5ndGggLSB0YWdMZW5ndGgpO1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QUFEKEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWNpcGhlci5zZXRBdXRoVGFnKHRhZyk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShlbmMpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGlkLWFlcyR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LXdyYXBgLCBrZXkuZGF0YSwgdGhpcy5BRVNfS1dfSVYpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgaWQtYWVzJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0td3JhcGAsIGtleS5kYXRhLCB0aGlzLkFFU19LV19JVik7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWVjYmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheSgwKSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1lY2JgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoMCkpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG59XHJcbkFlc0NyeXB0by5BRVNfS1dfSVYgPSBCdWZmZXIuZnJvbShcIkE2QTZBNkE2QTZBNkE2QTZcIiwgXCJoZXhcIik7XG5cbmNsYXNzIEFlc0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0NiY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgemVybyA9IEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbmNvbnN0IHJiID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEzNV0pO1xyXG5jb25zdCBibG9ja1NpemUgPSAxNjtcclxuZnVuY3Rpb24gYml0U2hpZnRMZWZ0KGJ1ZmZlcikge1xyXG4gICAgY29uc3Qgc2hpZnRlZCA9IEJ1ZmZlci5hbGxvYyhidWZmZXIubGVuZ3RoKTtcclxuICAgIGNvbnN0IGxhc3QgPSBidWZmZXIubGVuZ3RoIC0gMTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0OyBpbmRleCsrKSB7XHJcbiAgICAgICAgc2hpZnRlZFtpbmRleF0gPSBidWZmZXJbaW5kZXhdIDw8IDE7XHJcbiAgICAgICAgaWYgKGJ1ZmZlcltpbmRleCArIDFdICYgMHg4MCkge1xyXG4gICAgICAgICAgICBzaGlmdGVkW2luZGV4XSArPSAweDAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNoaWZ0ZWRbbGFzdF0gPSBidWZmZXJbbGFzdF0gPDwgMTtcclxuICAgIHJldHVybiBzaGlmdGVkO1xyXG59XHJcbmZ1bmN0aW9uIHhvcihhLCBiKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgb3V0cHV0W2luZGV4XSA9IGFbaW5kZXhdIF4gYltpbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbmZ1bmN0aW9uIGFlcyhrZXksIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0b19fbmFtZXNwYWNlLmNyZWF0ZUNpcGhlcml2KGBhZXMke2tleS5sZW5ndGggPDwgM31gLCBrZXksIHplcm8pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gY2lwaGVyLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIGNpcGhlci5maW5hbCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgYmxvY2tJbmRleCkge1xyXG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcclxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgYmxvY2tTaXplO1xyXG4gICAgbWVzc2FnZS5jb3B5KGJsb2NrLCAwLCBzdGFydCwgZW5kKTtcclxuICAgIHJldHVybiBibG9jaztcclxufVxyXG5mdW5jdGlvbiBnZXRQYWRkZWRNZXNzYWdlQmxvY2sobWVzc2FnZSwgYmxvY2tJbmRleCkge1xyXG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcclxuICAgIGNvbnN0IGVuZCA9IG1lc3NhZ2UubGVuZ3RoO1xyXG4gICAgYmxvY2suZmlsbCgwKTtcclxuICAgIG1lc3NhZ2UuY29weShibG9jaywgMCwgc3RhcnQsIGVuZCk7XHJcbiAgICBibG9ja1tlbmQgLSBzdGFydF0gPSAweDgwO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlU3Via2V5cyhrZXkpIHtcclxuICAgIGNvbnN0IGwgPSBhZXMoa2V5LCB6ZXJvKTtcclxuICAgIGxldCBzdWJrZXkxID0gYml0U2hpZnRMZWZ0KGwpO1xyXG4gICAgaWYgKGxbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgc3Via2V5MSA9IHhvcihzdWJrZXkxLCByYik7XHJcbiAgICB9XHJcbiAgICBsZXQgc3Via2V5MiA9IGJpdFNoaWZ0TGVmdChzdWJrZXkxKTtcclxuICAgIGlmIChzdWJrZXkxWzBdICYgMHg4MCkge1xyXG4gICAgICAgIHN1YmtleTIgPSB4b3Ioc3Via2V5MiwgcmIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgc3Via2V5MSwgc3Via2V5MiB9O1xyXG59XHJcbmZ1bmN0aW9uIGFlc0NtYWMoa2V5LCBtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBzdWJrZXlzID0gZ2VuZXJhdGVTdWJrZXlzKGtleSk7XHJcbiAgICBsZXQgYmxvY2tDb3VudCA9IE1hdGguY2VpbChtZXNzYWdlLmxlbmd0aCAvIGJsb2NrU2l6ZSk7XHJcbiAgICBsZXQgbGFzdEJsb2NrQ29tcGxldGVGbGFnO1xyXG4gICAgbGV0IGxhc3RCbG9jaztcclxuICAgIGlmIChibG9ja0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgYmxvY2tDb3VudCA9IDE7XHJcbiAgICAgICAgbGFzdEJsb2NrQ29tcGxldGVGbGFnID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSAobWVzc2FnZS5sZW5ndGggJSBibG9ja1NpemUgPT09IDApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFzdEJsb2NrSW5kZXggPSBibG9ja0NvdW50IC0gMTtcclxuICAgIGlmIChsYXN0QmxvY2tDb21wbGV0ZUZsYWcpIHtcclxuICAgICAgICBsYXN0QmxvY2sgPSB4b3IoZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGxhc3RCbG9ja0luZGV4KSwgc3Via2V5cy5zdWJrZXkxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRQYWRkZWRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHggPSB6ZXJvO1xyXG4gICAgbGV0IHk7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGFzdEJsb2NrSW5kZXg7IGluZGV4KyspIHtcclxuICAgICAgICB5ID0geG9yKHgsIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBpbmRleCkpO1xyXG4gICAgICAgIHggPSBhZXMoa2V5LCB5KTtcclxuICAgIH1cclxuICAgIHkgPSB4b3IobGFzdEJsb2NrLCB4KTtcclxuICAgIHJldHVybiBhZXMoa2V5LCB5KTtcclxufVxyXG5jbGFzcyBBZXNDbWFjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ21hY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYWVzQ21hYyhnZXRDcnlwdG9LZXkoa2V5KS5kYXRhLCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZTIgPSBhd2FpdCB0aGlzLnNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWduYXR1cmUpLmNvbXBhcmUoQnVmZmVyLmZyb20oc2lnbmF0dXJlMikpID09PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0N0clByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0N0clByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzR2NtUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzR2NtUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNLd1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0t3UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNFY2JQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNFY2JQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIERlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYERFUy1DQkNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYDNERVMtQ0JDYDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQWxnb3JpdGhtRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBEZXNDcnlwdG9LZXkucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblxuY2xhc3MgRGVzQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRGVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGFsZ29yaXRobS5sZW5ndGggPj4gMyk7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IERlc0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgRGVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBkZXMtY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBkZXMtY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBkZXMtZWRlMy1jYmNgLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBkZXMtZWRlMy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRGVzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmtleVNpemVCaXRzID0gNjQ7XHJcbiAgICAgICAgdGhpcy5pdlNpemUgPSA4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiREVTLUNCQ1wiO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IHRoaXMubmFtZSwgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIGlmIChrZXkuZGF0YS5sZW5ndGggIT09ICh0aGlzLmtleVNpemVCaXRzID4+IDMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBXcm9uZyBrZXkgc2l6ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIERlc0VkZTNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5EZXNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSAxOTI7XHJcbiAgICAgICAgdGhpcy5pdlNpemUgPSA4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiREVTLUVERTMtQ0JDXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgaWYgKGtleS5kYXRhLmxlbmd0aCAhPT0gKHRoaXMua2V5U2l6ZUJpdHMgPj4gMykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0SndrQWxnb3JpdGhtKGFsZ29yaXRobSkge1xyXG4gICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgbWRTaXplID0gLyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBgUlNBLU9BRVAke21kU2l6ZSAhPT0gXCIxXCIgPyBgLSR7bWRTaXplfWAgOiBcIlwifWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYFJTJHsvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXX1gO1xyXG4gICAgICAgIGNhc2UgXCJSU0EtUFNTXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUFMkey8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdfWA7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1QS0NTMVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYFJTMWA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHJpdmF0ZUtleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInByaXZhdGVcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiUlNBXCIsXHJcbiAgICAgICAgICAgIGFsZzogZ2V0SndrQWxnb3JpdGhtKHRoaXMuYWxnb3JpdGhtKSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYVB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnB1YmxpY0tleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJSU0FcIixcclxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYUNyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBSc2FQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcclxuICAgICAgICBwdWJsaWNLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHB1YmxpY0tleS5leHRyYWN0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0V4cG9uZW50ID0gQnVmZmVyLmNvbmNhdChbXHJcbiAgICAgICAgICAgIEJ1ZmZlci5hbGxvYyg0IC0gYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50LmJ5dGVMZW5ndGgsIDApLFxyXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShhbGdvcml0aG0ucHVibGljRXhwb25lbnQpLFxyXG4gICAgICAgIF0pLnJlYWRJbnQzMkJFKDApO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBjcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYyhcInJzYVwiLCB7XHJcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoLFxyXG4gICAgICAgICAgICBwdWJsaWNFeHBvbmVudCxcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtUFNTXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnblJzYShhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXNuS2V5LnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPSBhc25LZXkubW9kdWx1cy5ieXRlTGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUnNhUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXNuS2V5LnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPSBhc25LZXkubW9kdWx1cy5ieXRlTGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldENyeXB0b0FsZ29yaXRobShhbGcpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZy5oYXNoLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEExXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBNTEyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtNTEyXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtLmhhc2g6IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBzaWduUnNhKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRDcnlwdG9BbGdvcml0aG0oa2V5LmFsZ29yaXRobSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJSU0EtUFNTXCIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wYWRkaW5nID0gY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkc7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2FsdExlbmd0aCA9IGFsZ29yaXRobS5zYWx0TGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZXIuc2lnbihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdmVyaWZ5U1NBKGFsZ29yaXRobSwga2V5LCBkYXRhLCBzaWduYXR1cmUpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlJTQS1QU1NcIikge1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcclxuICAgICAgICAgICAgb3B0aW9ucy5zYWx0TGVuZ3RoID0gYWxnb3JpdGhtLnNhbHRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBzaWduYXR1cmUpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbmNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9PQUVQX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsKSA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5wdWJsaWNFbmNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVjcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9PQUVQX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsKSA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5wcml2YXRlRGVjcnlwdChvcHRpb25zLCBkYXRhKSkuYnVmZmVyO1xyXG4gICAgfVxyXG59XHJcblJzYUNyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIiwgXCJlbmNyeXB0XCIsIFwid3JhcEtleVwiXTtcclxuUnNhQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXTtcblxuY2xhc3MgUnNhU3NhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhU3NhUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHNzUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhUHNzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBzaXplKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxNjA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI1NjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMzg0O1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiA1MTI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGExXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEyNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhNTEyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy0yNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtNTEyXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2hBbGcgPSB0aGlzLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaGFzaEFsZylcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhhc2gpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FPYWVwUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhT2FlcFByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcclxuICAgICAgICBjb25zdCBrZXlTaXplID0gTWF0aC5jZWlsKGludGVybmFsS2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcHNMZW5ndGggPSBrZXlTaXplIC0gZGF0YUxlbmd0aCAtIDIgKiBoYXNoU2l6ZSAtIDI7XHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGggPiBrZXlTaXplIC0gMiAqIGhhc2hTaXplIC0gMikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHRvbyBsYXJnZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGtleVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHNlZWQgPSBtZXNzYWdlLnN1YmFycmF5KDEsIGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gbWVzc2FnZS5zdWJhcnJheShoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGRhdGFCbG9jay5zZXQoZGF0YVZpZXcsIGhhc2hTaXplICsgcHNMZW5ndGggKyAxKTtcclxuICAgICAgICBjb25zdCBsYWJlbEhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGFsZ29yaXRobS5sYWJlbCB8fCBuZXcgVWludDhBcnJheSgwKSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBkYXRhQmxvY2suc2V0KGxhYmVsSGFzaCwgMCk7XHJcbiAgICAgICAgZGF0YUJsb2NrW2hhc2hTaXplICsgcHNMZW5ndGhdID0gMTtcclxuICAgICAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoc2VlZCk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgc2VlZCwgZGF0YUJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhQmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YUJsb2NrW2ldIF49IGRhdGFCbG9ja01hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZWRNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBkYXRhQmxvY2ssIHNlZWQubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZFtpXSBePSBzZWVkTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbnRlcm5hbEtleS5wZW0pIHtcclxuICAgICAgICAgICAgaW50ZXJuYWxLZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtpbnRlcm5hbEtleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBrY3MwID0gY3J5cHRvLnB1YmxpY0VuY3J5cHQoe1xyXG4gICAgICAgICAgICBrZXk6IGludGVybmFsS2V5LnBlbSxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfTk9fUEFERElORyxcclxuICAgICAgICB9LCBCdWZmZXIuZnJvbShtZXNzYWdlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBrY3MwKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCkgPj4gMztcclxuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmIChkYXRhTGVuZ3RoICE9PSBrZXlTaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBkYXRhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtpbnRlcm5hbEtleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGtjczAgPSBjcnlwdG8ucHJpdmF0ZURlY3J5cHQoe1xyXG4gICAgICAgICAgICBrZXk6IGludGVybmFsS2V5LnBlbSxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfTk9fUEFERElORyxcclxuICAgICAgICB9LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgY29uc3QgeiA9IHBrY3MwWzBdO1xyXG4gICAgICAgIGNvbnN0IHNlZWQgPSBwa2NzMC5zdWJhcnJheSgxLCBoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFCbG9jayA9IHBrY3MwLnN1YmFycmF5KGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgaWYgKHogIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZWRNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBkYXRhQmxvY2ssIHNlZWQubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZFtpXSBePSBzZWVkTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgc2VlZCwgZGF0YUJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhQmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YUJsb2NrW2ldIF49IGRhdGFCbG9ja01hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYWxnb3JpdGhtLmxhYmVsIHx8IG5ldyBVaW50OEFycmF5KDApKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGFiZWxIYXNoW2ldICE9PSBkYXRhQmxvY2tbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwc0VuZCA9IGhhc2hTaXplO1xyXG4gICAgICAgIGZvciAoOyBwc0VuZCA8IGRhdGFCbG9jay5sZW5ndGg7IHBzRW5kKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHN6ID0gZGF0YUJsb2NrW3BzRW5kXTtcclxuICAgICAgICAgICAgaWYgKHBzeiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBzeiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBzRW5kID09PSBkYXRhQmxvY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwa2NzMCA9IGRhdGFCbG9jay5zdWJhcnJheShwc0VuZCArIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwa2NzMCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtZ2YxKGFsZ29yaXRobSwgc2VlZCwgbGVuZ3RoID0gMCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoYWxnb3JpdGhtKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgICAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaFNpemUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcclxuICAgICAgICAgICAgY291bnRlclswXSA9IGkgPj4+IDI0O1xyXG4gICAgICAgICAgICBjb3VudGVyWzFdID0gKGkgPj4+IDE2KSAmIDI1NTtcclxuICAgICAgICAgICAgY291bnRlclsyXSA9IChpID4+PiA4KSAmIDI1NTtcclxuICAgICAgICAgICAgY291bnRlclszXSA9IGkgJiAyNTU7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1hc2sgPSBtYXNrLnN1YmFycmF5KGkgKiBoYXNoU2l6ZSk7XHJcbiAgICAgICAgICAgIGxldCBjaHVuayA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobS5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShjb3VudGVyKVxyXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gc3VibWFzay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkoMCwgc3VibWFzay5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1Ym1hc2suc2V0KGNodW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hc2s7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhRXNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBRVMtUEtDUzEtdjFfNVwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdLFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNFeHBvbmVudFwiKTtcclxuICAgICAgICBpZiAoIShhbGdvcml0aG0ucHVibGljRXhwb25lbnQgJiYgYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNaXNzaW5nIG9yIG5vdCBhIFVpbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YmxpY0V4cG9uZW50ID0gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjQoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBpZiAoIShwdWJsaWNFeHBvbmVudCA9PT0gXCJBdz09XCIgfHwgcHVibGljRXhwb25lbnQgPT09IFwiQVFBQlwiKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE11c3QgYmUgWzNdIG9yIFsxLDAsMV1cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJtb2R1bHVzTGVuZ3RoXCIpO1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMDI0OlxyXG4gICAgICAgICAgICBjYXNlIDIwNDg6XHJcbiAgICAgICAgICAgIGNhc2UgNDA5NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1vZHVsdXNMZW5ndGg6IE11c3QgYmUgMTAyNCwgMjA0OCwgb3IgNDA5NlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcclxuICAgICAgICBjb25zdCBlbmMgPSBjcnlwdG9fX25hbWVzcGFjZS5wdWJsaWNFbmNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcclxuICAgICAgICBjb25zdCBkZWMgPSBjcnlwdG9fX25hbWVzcGFjZS5wcml2YXRlRGVjcnlwdChvcHRpb25zLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0NyeXB0b09wdGlvbnMoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGtleS50eXBlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiAke3R5cGV9IEtFWS0tLS0tXFxuJHtnZXRDcnlwdG9LZXkoa2V5KS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EICR7dHlwZX0gS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG9fX25hbWVzcGFjZS5jb25zdGFudHMuUlNBX1BLQ1MxX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYW1lZE9JRHMgPSB7XHJcbiAgICBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjogXCJQLTI1NlwiLFxyXG4gICAgXCJQLTI1NlwiOiBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIixcclxuICAgIFwiMS4zLjEzMi4wLjM0XCI6IFwiUC0zODRcIixcclxuICAgIFwiUC0zODRcIjogXCIxLjMuMTMyLjAuMzRcIixcclxuICAgIFwiMS4zLjEzMi4wLjM1XCI6IFwiUC01MjFcIixcclxuICAgIFwiUC01MjFcIjogXCIxLjMuMTMyLjAuMzVcIixcclxuICAgIFwiMS4zLjEzMi4wLjEwXCI6IFwiSy0yNTZcIixcclxuICAgIFwiSy0yNTZcIjogXCIxLjMuMTMyLjAuMTBcIixcclxuICAgIFwiYnJhaW5wb29sUDE2MHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjFcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjFcIjogXCJicmFpbnBvb2xQMTYwcjFcIixcclxuICAgIFwiYnJhaW5wb29sUDE2MHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjJcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjJcIjogXCJicmFpbnBvb2xQMTYwdDFcIixcclxuICAgIFwiYnJhaW5wb29sUDE5MnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjNcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjNcIjogXCJicmFpbnBvb2xQMTkycjFcIixcclxuICAgIFwiYnJhaW5wb29sUDE5MnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjRcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjRcIjogXCJicmFpbnBvb2xQMTkydDFcIixcclxuICAgIFwiYnJhaW5wb29sUDIyNHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjVcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjVcIjogXCJicmFpbnBvb2xQMjI0cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDIyNHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjZcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjZcIjogXCJicmFpbnBvb2xQMjI0dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDI1NnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjdcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjdcIjogXCJicmFpbnBvb2xQMjU2cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDI1NnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjhcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjhcIjogXCJicmFpbnBvb2xQMjU2dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDMyMHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjlcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjlcIjogXCJicmFpbnBvb2xQMzIwcjFcIixcclxuICAgIFwiYnJhaW5wb29sUDMyMHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMFwiOiBcImJyYWlucG9vbFAzMjB0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzg0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTFcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjExXCI6IFwiYnJhaW5wb29sUDM4NHIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzODR0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTJcIjogXCJicmFpbnBvb2xQMzg0dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDUxMnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xM1wiOiBcImJyYWlucG9vbFA1MTJyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQNTEydDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTRcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjE0XCI6IFwiYnJhaW5wb29sUDUxMnQxXCIsXHJcbn07XHJcbmZ1bmN0aW9uIGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKG5hbWVkQ3VydmUpIHtcclxuICAgIGNvbnN0IG9pZCA9IG5hbWVkT0lEc1tuYW1lZEN1cnZlXTtcclxuICAgIGlmICghb2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGNvbnZlcnQgV2ViQ3J5cHRvIG5hbWVkIGN1cnZlICcke25hbWVkQ3VydmV9JyB0byBPSURgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvaWQ7XHJcbn1cblxuY2xhc3MgRWNQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIkVDXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGpzb24uY3J2KSkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY1B1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkoa2V5SW5mby5wdWJsaWNLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIkVDXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoanNvbi5jcnYpKSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIudG9BU04oa2V5KS52YWx1ZUhleDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGExUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0xXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0yNTZcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzODRQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTM4NFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTUxMlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtNTEyXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzI1NlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTI1NlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTMzODRQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy0zODRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzNTEyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtNTEyXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgRWNQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwiZWNcIiwge1xyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiB0aGlzLmdldE9wZW5TU0xOYW1lZEN1cnZlKGFsZ29yaXRobS5uYW1lZEN1cnZlKSxcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoc2lnbmF0dXJlLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY0RzYVNpZ25hdHVyZSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlUmF3ID0gY29yZV9fbmFtZXNwYWNlLkVjVXRpbHMuZW5jb2RlU2lnbmF0dXJlKGVjU2lnbmF0dXJlLCBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMuZ2V0KGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkuc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZVJhdy5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY0RzYVNpZ25hdHVyZSgpO1xyXG4gICAgICAgIGNvbnN0IG5hbWVkQ3VydmUgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMuZ2V0KGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlUG9pbnQgPSBjb3JlX19uYW1lc3BhY2UuRWNVdGlscy5kZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBuYW1lZEN1cnZlLnNpemUpO1xyXG4gICAgICAgIGVjU2lnbmF0dXJlLnIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlUG9pbnQucik7XHJcbiAgICAgICAgZWNTaWduYXR1cmUucyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5zKTtcclxuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZVJhdyA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoZWNTaWduYXR1cmUpKTtcclxuICAgICAgICBjb25zdCBvayA9IHNpZ25lci52ZXJpZnkob3B0aW9ucywgZWNTaWduYXR1cmVSYXcpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRPcGVuU1NMTmFtZWRDdXJ2ZShiYXNlS2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBjb25zdCBlY2RoID0gY3J5cHRvLmNyZWF0ZUVDREgoY3J5cHRvQWxnKTtcclxuICAgICAgICBjb25zdCBhc25Qcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYmFzZUtleS5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgY29uc3QgYXNuRWNQcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYXNuUHJpdmF0ZUtleS5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkpO1xyXG4gICAgICAgIGVjZGguc2V0UHJpdmF0ZUtleShCdWZmZXIuZnJvbShhc25FY1ByaXZhdGVLZXkucHJpdmF0ZUtleSkpO1xyXG4gICAgICAgIGNvbnN0IGFzblB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGFsZ29yaXRobS5wdWJsaWMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGVjZGguY29tcHV0ZVNlY3JldChCdWZmZXIuZnJvbShhc25QdWJsaWNLZXkucHVibGljS2V5KSk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydEtleVBhcmFtZXRlcnMoa2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydEtleVBhcmFtZXRlcnMoa2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMsIGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzc2VydEtleVBhcmFtZXRlcnMocGFyYW1ldGVycywgbmFtZWRDdXJ2ZSkge1xyXG4gICAgICAgIGlmICghcGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gZG9lc24ndCBoYXZlIHJlcXVpcmVkIHBhcmFtZXRlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuYW1lZEN1cnZlSWRlbnRpZmllciA9IFwiXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZUlkZW50aWZpZXIgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShwYXJhbWV0ZXJzLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9FcnJvcihcIkNhbm5vdCByZWFkIGtleSBpbmZvIHBhcmFtZXRlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRPaWRCeU5hbWVkQ3VydmUkMShuYW1lZEN1cnZlKSAhPT0gbmFtZWRDdXJ2ZUlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9FcnJvcihcIktleSBpbmZvIHBhcmFtZXRlciBkb2Vzbid0IG1hdGNoIHRvIG5hbWVkIGN1cnZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGFsZ29yaXRobS5uYW1lZEN1cnZlKSkpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWNQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xyXG4gICAgICAgIGNvbnN0IG5hbWVkQ3VydmUgPSBnZXRPaWRCeU5hbWVkQ3VydmUkMShhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIobmFtZWRDdXJ2ZSkpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuS2V5LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldE9wZW5TU0xOYW1lZEN1cnZlKGN1cnZlKSB7XHJcbiAgICAgICAgc3dpdGNoIChjdXJ2ZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicHJpbWUyNTZ2MVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiSy0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3AyNTZrMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiUC0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3AzODRyMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiUC01MjFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3A1MjFyMVwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnZlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5FY0NyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIl07XHJcbkVjQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcblxuY2xhc3MgRWNkc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RzYVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5uYW1lcztcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVjQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFY0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBFQyBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjZGhQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLm5hbWVzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVjQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1ByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1B1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgRWNDcnlwdG8uZGVyaXZlQml0cyh7IC4uLmFsZ29yaXRobSwgcHVibGljOiBnZXRDcnlwdG9LZXkoYWxnb3JpdGhtLnB1YmxpYykgfSwgZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLCBsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGVkT0lEcyA9IHtcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkNDQ4XTogXCJFZDQ0OFwiLFxyXG4gICAgXCJlZDQ0OFwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkNDQ4LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkWDQ0OF06IFwiWDQ0OFwiLFxyXG4gICAgXCJ4NDQ4XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkWDQ0OCxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkMjU1MTldOiBcIkVkMjU1MTlcIixcclxuICAgIFwiZWQyNTUxOVwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkMjU1MTksXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYMjU1MTldOiBcIlgyNTUxOVwiLFxyXG4gICAgXCJ4MjU1MTlcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYMjU1MTksXHJcbn07XHJcbmZ1bmN0aW9uIGdldE9pZEJ5TmFtZWRDdXJ2ZShuYW1lZEN1cnZlKSB7XHJcbiAgICBjb25zdCBvaWQgPSBlZE9JRHNbbmFtZWRDdXJ2ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIGlmICghb2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGNvbnZlcnQgV2ViQ3J5cHRvIG5hbWVkIGN1cnZlICcke25hbWVkQ3VydmV9JyB0byBPSURgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvaWQ7XHJcbn1cblxuY2xhc3MgRWRQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIk9LUFwiLFxyXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWRQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4ga2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIHtcclxuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoa2V5KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFqc29uLngpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBwcm9wZXJ0eSBmcm9tIEpXSy4gUHJvcGVydHkgJ3gnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZShqc29uLmNydik7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWRDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFZFB1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGFsZ29yaXRobS5uYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKHR5cGUsIHtcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGNyeXB0by5zaWduKG51bGwsIEJ1ZmZlci5mcm9tKGRhdGEpLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgb2sgPSBjcnlwdG8udmVyaWZ5KG51bGwsIEJ1ZmZlci5mcm9tKGRhdGEpLCBvcHRpb25zLCBCdWZmZXIuZnJvbShzaWduYXR1cmUpKTtcclxuICAgICAgICByZXR1cm4gb2s7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0by5jcmVhdGVQdWJsaWNLZXkoe1xyXG4gICAgICAgICAgICBrZXk6IGFsZ29yaXRobS5wdWJsaWMuZGF0YSxcclxuICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoe1xyXG4gICAgICAgICAgICBrZXk6IGJhc2VLZXkuZGF0YSxcclxuICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGNyeXB0by5kaWZmaWVIZWxsbWFuKHtcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaXRzKS5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoID4+IDMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleS5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNLZXlJbmZvLnB1YmxpY0tleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsIHBrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWp3ay54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBDYW5ub3QgZ2V0IHJlcXVpcmVkICd4JyBmaWxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoandrLngpLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVkUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIGtleS5mcm9tSlNPTih7XHJcbiAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGQ6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGFzbktleS5kKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVkUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmZyb21KU09OKHtcclxuICAgICAgICAgICAgY3J2OiBhbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYXNuS2V5KSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbn1cclxuRWRDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xyXG5FZENyeXB0by5wcml2YXRlS2V5VXNhZ2VzID0gW1wic2lnblwiLCBcImRlcml2ZUtleVwiLCBcImRlcml2ZUJpdHNcIl07XG5cbmNsYXNzIEVkRHNhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRWREc2FQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFZENyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogYWxnb3JpdGhtLm5hbWVkQ3VydmUucmVwbGFjZSgvXmVkL2ksIFwiRWRcIiksXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFZENyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY2RoRXNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RoRXNQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFZENyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9VcHBlckNhc2UoKSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgRWRDcnlwdG8uZGVyaXZlQml0cyh7IC4uLmFsZ29yaXRobSwgcHVibGljOiBnZXRDcnlwdG9LZXkoYWxnb3JpdGhtLnB1YmxpYykgfSwgZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLCBsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFZENyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQYmtkZkNyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbn1cblxuY2xhc3MgUGJrZGYyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUGJrZGYyUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihhbGdvcml0aG0uc2FsdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICBjcnlwdG8ucGJrZGYyKGdldENyeXB0b0tleShiYXNlS2V5KS5kYXRhLCBCdWZmZXIuZnJvbShzYWx0KSwgYWxnb3JpdGhtLml0ZXJhdGlvbnMsIGxlbmd0aCA+PiAzLCBoYXNoLCAoZXJyLCBkZXJpdmVkQml0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShkZXJpdmVkQml0cykuYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicmF3XCIpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IFBia2RmQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgIGtleS5hbGdvcml0aG0gPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xyXG4gICAgICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdyYXcnXCIpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgUGJrZGZDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBQQktERiBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEhtYWNDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG4gICAgZ2V0IGFsZygpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5hbGdvcml0aG0uaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGBIUyR7aGFzaC5yZXBsYWNlKFwiU0hBLVwiLCBcIlwiKX1gO1xyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgSG1hY0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jbGFzcyBIbWFjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuSG1hY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKGFsZ29yaXRobS5sZW5ndGggfHwgdGhpcy5nZXREZWZhdWx0TGVuZ3RoKGFsZ29yaXRobS5oYXNoLm5hbWUpKSA+PiAzIDw8IDM7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhtYWNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0ge1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGggPj4gMyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoY3J5cHRvQWxnLCBnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaG1hYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGtleS5hbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyeXB0b0FsZywgZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSlcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIGhtYWMuY29tcGFyZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogSG1hY0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgSG1hY0NyeXB0b0tleSgpO1xyXG4gICAgICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHtcclxuICAgICAgICAgICAgaGFzaDogeyBuYW1lOiBhbGdvcml0aG0uaGFzaC5uYW1lIH0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBrZXkuZGF0YS5sZW5ndGggPDwgMyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhtYWNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBITUFDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSGtkZkNyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbn1cblxuY2xhc3MgSGtkZlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkhrZGZQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSAhPT0gXCJyYXdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBIa2RmQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0geyBuYW1lOiB0aGlzLm5hbWUgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhwYXJhbXMsIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBwYXJhbXMuaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBjcnlwdG8uY3JlYXRlSGFzaChoYXNoKS5kaWdlc3QoKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGxlbmd0aCAvIDg7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwYXJhbXMuaW5mbyk7XHJcbiAgICAgICAgY29uc3QgUFJLID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaCwgY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy5zYWx0KSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW0J1ZmZlci5hbGxvYygwKV07XHJcbiAgICAgICAgY29uc3QgYmxvY2tDb3VudCA9IE1hdGguY2VpbChieXRlTGVuZ3RoIC8gaGFzaExlbmd0aCkgKyAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyeXB0by5jcmVhdGVIbWFjKGhhc2gsIFBSSylcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmNvbmNhdChbYmxvY2tzW2kgLSAxXSwgaW5mbywgQnVmZmVyLmZyb20oW2ldKV0pKVxyXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmxvY2tzKS5zbGljZSgwLCBieXRlTGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhrZGZDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBIS0RGIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2VDcnlwdG8ge1xyXG4gICAgc3RhdGljIGRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSwgeyBvdXRwdXRMZW5ndGg6IGFsZ29yaXRobS5sZW5ndGggfSlcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhhc2gpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZTEyOFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlNoYWtlMTI4UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYWtlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU2hha2UyNTZQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hha2VDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU3VidGxlQ3J5cHRvIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlN1YnRsZUNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ3RyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNHY21Qcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NtYWNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0t3UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNFY2JQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IERlc0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzRWRlM0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhU3NhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FQc3NQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYU9hZXBQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYUVzUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RzYVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMjU2UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzODRQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTUxMlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUGJrZGYyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBIbWFjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBIa2RmUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1ham9yVmVyc2lvbiA9IChfYSA9IC9edihcXGQrKS8uZXhlYyhwcm9jZXNzX19uYW1lc3BhY2UudmVyc2lvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcclxuICAgICAgICBpZiAobm9kZU1ham9yVmVyc2lvbiAmJiBwYXJzZUludChub2RlTWFqb3JWZXJzaW9uLCAxMCkgPj0gMTIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGFrZTEyOFByb3ZpZGVyKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMjU2UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc2hlcyA9IGNyeXB0b19fbmFtZXNwYWNlLmdldEhhc2hlcygpO1xyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTI1NlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTMyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtMzg0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzM4NFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy01MTJcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzNTEyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlTWFqb3JWZXJzaW9uICYmIHBhcnNlSW50KG5vZGVNYWpvclZlcnNpb24sIDEwKSA+PSAxNCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVkRHNhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaEVzUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIENyeXB0byBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5DcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnN1YnRsZSA9IG5ldyBTdWJ0bGVDcnlwdG8oKTtcclxuICAgIH1cclxuICAgIGdldFJhbmRvbVZhbHVlcyhhcnJheSkge1xyXG4gICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFJhbmRvbVZhbHVlcycgb24gJ0NyeXB0byc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdBcnJheUJ1ZmZlclZpZXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhidWZmZXIpO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NyeXB0b0tleScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlLkNyeXB0b0tleTsgfVxufSk7XG5leHBvcnRzLkNyeXB0byA9IENyeXB0bztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNqRix3QkFBd0I7QUFDeEI7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVPO0FBQ1A7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBOztBQUVPO0FBQ1Asa0NBQWtDO0FBQ2xDOztBQUVPO0FBQ1AsdUJBQXVCLHVGQUF1RjtBQUM5RztBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSw4Q0FBOEMseUZBQXlGO0FBQ3ZJLDhEQUE4RCwyQ0FBMkM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0EsNENBQTRDLHlFQUF5RTtBQUNySDs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCwwQkFBMEIsK0RBQStELGlCQUFpQjtBQUMxRztBQUNBLGtDQUFrQyxNQUFNLCtCQUErQixZQUFZO0FBQ25GLGlDQUFpQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3RGLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQLFlBQVksNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN0RyxlQUFlLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN0SixxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxpQ0FBaUMsU0FBUztBQUMxQyxpQ0FBaUMsV0FBVyxVQUFVO0FBQ3RELHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EsNEdBQTRHLE9BQU87QUFDbkgsK0VBQStFLGlCQUFpQjtBQUNoRyx1REFBdUQsZ0JBQWdCLFFBQVE7QUFDL0UsNkNBQTZDLGdCQUFnQixnQkFBZ0I7QUFDN0U7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFFBQVEsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUNwRCxrQ0FBa0MsU0FBUztBQUMzQztBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUCwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1AsZ0RBQWdELFFBQVE7QUFDeEQsdUNBQXVDLFFBQVE7QUFDL0MsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBOztBQUVPO0FBQ1AsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsdUZBQXVGLGNBQWM7QUFDcEgscUJBQXFCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3JJLDBCQUEwQixNQUFNLGlCQUFpQixZQUFZO0FBQzdELHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQjs7QUFFTztBQUNQO0FBQ0EsZUFBZSw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUMxSSx3QkFBd0IsNkJBQTZCLG9CQUFvQix1Q0FBdUMsa0JBQWtCO0FBQ2xJOztBQUVPO0FBQ1A7QUFDQTtBQUNBLHlHQUF5Ryx1RkFBdUYsY0FBYztBQUM5TSxxQkFBcUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDM0osMkNBQTJDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ2xIOztBQUVPO0FBQ1AsK0JBQStCLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUM5RjtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRSxDQUFDO0FBQ0Q7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLDJDQUEyQztBQUMzQzs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBOEM7QUFDbkU7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxTQUFTLGdCQUFnQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYubWpzP2E0Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZTtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKGVudi5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxuICBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcbiAgX19kaXNwb3NlUmVzb3VyY2VzLFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@peculiar/asn1-schema/node_modules/tslib/tslib.es6.mjs\n");

/***/ })

};
;