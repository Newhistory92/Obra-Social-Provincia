"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webcrypto-core";
exports.ids = ["vendor-chunks/webcrypto-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/webcrypto-core/build/webcrypto-core.js":
/*!*************************************************************!*\
  !*** ./node_modules/webcrypto-core/build/webcrypto-core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar asn1 = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar asn1__namespace = /*#__PURE__*/ _interopNamespaceDefault(asn1);\nclass CryptoError extends Error {\n}\nclass AlgorithmError extends CryptoError {\n}\nclass UnsupportedOperationError extends CryptoError {\n    constructor(methodName){\n        super(`Unsupported operation: ${methodName ? `${methodName}` : \"\"}`);\n    }\n}\nclass OperationError extends CryptoError {\n}\nclass RequiredPropertyError extends CryptoError {\n    constructor(propName){\n        super(`${propName}: Missing required property`);\n    }\n}\nclass PemConverter {\n    static toArrayBuffer(pem) {\n        const base64 = pem.replace(/-{5}(BEGIN|END) .*-{5}/g, \"\").replace(\"\\r\", \"\").replace(\"\\n\", \"\");\n        return pvtsutils.Convert.FromBase64(base64);\n    }\n    static toUint8Array(pem) {\n        const bytes = this.toArrayBuffer(pem);\n        return new Uint8Array(bytes);\n    }\n    static fromBufferSource(buffer, tag) {\n        const base64 = pvtsutils.Convert.ToBase64(buffer);\n        let sliced;\n        let offset = 0;\n        const rows = [];\n        while(offset < base64.length){\n            sliced = base64.slice(offset, offset + 64);\n            if (sliced.length) {\n                rows.push(sliced);\n            } else {\n                break;\n            }\n            offset += 64;\n        }\n        const upperCaseTag = tag.toUpperCase();\n        return `-----BEGIN ${upperCaseTag}-----\\n${rows.join(\"\\n\")}\\n-----END ${upperCaseTag}-----`;\n    }\n    static isPEM(data) {\n        return /-----BEGIN .+-----[A-Za-z0-9+/+=\\s\\n]+-----END .+-----/i.test(data);\n    }\n    static getTagName(pem) {\n        if (!this.isPEM(pem)) {\n            throw new Error(\"Bad parameter. Incoming data is not right PEM\");\n        }\n        const res = /-----BEGIN (.+)-----/.exec(pem);\n        if (!res) {\n            throw new Error(\"Cannot get tag from PEM\");\n        }\n        return res[1];\n    }\n    static hasTagName(pem, tagName) {\n        const tag = this.getTagName(pem);\n        return tagName.toLowerCase() === tag.toLowerCase();\n    }\n    static isCertificate(pem) {\n        return this.hasTagName(pem, \"certificate\");\n    }\n    static isCertificateRequest(pem) {\n        return this.hasTagName(pem, \"certificate request\");\n    }\n    static isCRL(pem) {\n        return this.hasTagName(pem, \"x509 crl\");\n    }\n    static isPublicKey(pem) {\n        return this.hasTagName(pem, \"public key\");\n    }\n}\nfunction isJWK(data) {\n    return typeof data === \"object\" && \"kty\" in data;\n}\nclass ProviderCrypto {\n    async digest(...args) {\n        this.checkDigest.apply(this, args);\n        return this.onDigest.apply(this, args);\n    }\n    checkDigest(algorithm, _data) {\n        this.checkAlgorithmName(algorithm);\n    }\n    async onDigest(_algorithm, _data) {\n        throw new UnsupportedOperationError(\"digest\");\n    }\n    async generateKey(...args) {\n        this.checkGenerateKey.apply(this, args);\n        return this.onGenerateKey.apply(this, args);\n    }\n    checkGenerateKey(algorithm, _extractable, keyUsages, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkGenerateKeyParams(algorithm);\n        if (!(keyUsages && keyUsages.length)) {\n            throw new TypeError(`Usages cannot be empty when creating a key.`);\n        }\n        let allowedUsages;\n        if (Array.isArray(this.usages)) {\n            allowedUsages = this.usages;\n        } else {\n            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n        }\n        this.checkKeyUsages(keyUsages, allowedUsages);\n    }\n    checkGenerateKeyParams(_algorithm) {}\n    async onGenerateKey(_algorithm, _extractable, _keyUsages, ..._args) {\n        throw new UnsupportedOperationError(\"generateKey\");\n    }\n    async sign(...args) {\n        this.checkSign.apply(this, args);\n        return this.onSign.apply(this, args);\n    }\n    checkSign(algorithm, key, _data, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"sign\");\n    }\n    async onSign(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"sign\");\n    }\n    async verify(...args) {\n        this.checkVerify.apply(this, args);\n        return this.onVerify.apply(this, args);\n    }\n    checkVerify(algorithm, key, _signature, _data, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"verify\");\n    }\n    async onVerify(_algorithm, _key, _signature, _data, ..._args) {\n        throw new UnsupportedOperationError(\"verify\");\n    }\n    async encrypt(...args) {\n        this.checkEncrypt.apply(this, args);\n        return this.onEncrypt.apply(this, args);\n    }\n    checkEncrypt(algorithm, key, _data, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"encrypt\" : void 0);\n    }\n    async onEncrypt(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"encrypt\");\n    }\n    async decrypt(...args) {\n        this.checkDecrypt.apply(this, args);\n        return this.onDecrypt.apply(this, args);\n    }\n    checkDecrypt(algorithm, key, _data, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"decrypt\" : void 0);\n    }\n    async onDecrypt(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"decrypt\");\n    }\n    async deriveBits(...args) {\n        this.checkDeriveBits.apply(this, args);\n        return this.onDeriveBits.apply(this, args);\n    }\n    checkDeriveBits(algorithm, baseKey, length, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(baseKey, options.keyUsage ? \"deriveBits\" : void 0);\n        if (length % 8 !== 0) {\n            throw new OperationError(\"length: Is not multiple of 8\");\n        }\n    }\n    async onDeriveBits(_algorithm, _baseKey, _length, ..._args) {\n        throw new UnsupportedOperationError(\"deriveBits\");\n    }\n    async exportKey(...args) {\n        this.checkExportKey.apply(this, args);\n        return this.onExportKey.apply(this, args);\n    }\n    checkExportKey(format, key, ..._args) {\n        this.checkKeyFormat(format);\n        this.checkCryptoKey(key);\n        if (!key.extractable) {\n            throw new CryptoError(\"key: Is not extractable\");\n        }\n    }\n    async onExportKey(_format, _key, ..._args) {\n        throw new UnsupportedOperationError(\"exportKey\");\n    }\n    async importKey(...args) {\n        this.checkImportKey.apply(this, args);\n        return this.onImportKey.apply(this, args);\n    }\n    checkImportKey(format, keyData, algorithm, _extractable, keyUsages, ..._args) {\n        this.checkKeyFormat(format);\n        this.checkKeyData(format, keyData);\n        this.checkAlgorithmName(algorithm);\n        this.checkImportParams(algorithm);\n        if (Array.isArray(this.usages)) {\n            this.checkKeyUsages(keyUsages, this.usages);\n        }\n    }\n    async onImportKey(_format, _keyData, _algorithm, _extractable, _keyUsages, ..._args) {\n        throw new UnsupportedOperationError(\"importKey\");\n    }\n    checkAlgorithmName(algorithm) {\n        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n    }\n    checkAlgorithmParams(_algorithm) {}\n    checkDerivedKeyParams(_algorithm) {}\n    checkKeyUsages(usages, allowed) {\n        for (const usage of usages){\n            if (allowed.indexOf(usage) === -1) {\n                throw new TypeError(\"Cannot create a key using the specified key usages\");\n            }\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        this.checkAlgorithmName(key.algorithm);\n        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n            throw new CryptoError(`key does not match that of operation`);\n        }\n    }\n    checkRequiredProperty(data, propName) {\n        if (!(propName in data)) {\n            throw new RequiredPropertyError(propName);\n        }\n    }\n    checkHashAlgorithm(algorithm, hashAlgorithms) {\n        for (const item of hashAlgorithms){\n            if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(\", \")}`);\n    }\n    checkImportParams(_algorithm) {}\n    checkKeyFormat(format) {\n        switch(format){\n            case \"raw\":\n            case \"pkcs8\":\n            case \"spki\":\n            case \"jwk\":\n                break;\n            default:\n                throw new TypeError(\"format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'\");\n        }\n    }\n    checkKeyData(format, keyData) {\n        if (!keyData) {\n            throw new TypeError(\"keyData: Cannot be empty on empty on key importing\");\n        }\n        if (format === \"jwk\") {\n            if (!isJWK(keyData)) {\n                throw new TypeError(\"keyData: Is not JsonWebToken\");\n            }\n        } else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {\n            throw new TypeError(\"keyData: Is not ArrayBufferView or ArrayBuffer\");\n        }\n    }\n    prepareData(data) {\n        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n    }\n}\nclass AesProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        switch(algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new TypeError(\"length: Must be 128, 192, or 256\");\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass AesCbcProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CBC\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n    }\n}\nclass AesCmacProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CMAC\";\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesCtrProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-CTR\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"counter\");\n        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n            throw new TypeError(\"counter: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.counter.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\nclass AesEcbProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-ECB\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass AesGcmProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-GCM\";\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength < 1) {\n            throw new OperationError(\"iv: Must have length more than 0 and less than 2^64 - 1\");\n        }\n        if (!(\"tagLength\" in algorithm)) {\n            algorithm.tagLength = 128;\n        }\n        switch(algorithm.tagLength){\n            case 32:\n            case 64:\n            case 96:\n            case 104:\n            case 112:\n            case 120:\n            case 128:\n                break;\n            default:\n                throw new OperationError(\"tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128\");\n        }\n    }\n}\nclass AesKwProvider extends AesProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"AES-KW\";\n        this.usages = [\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n}\nclass DesProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [\n            \"encrypt\",\n            \"decrypt\",\n            \"wrapKey\",\n            \"unwrapKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        if (this.ivSize) {\n            this.checkRequiredProperty(algorithm, \"iv\");\n            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n                throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n            }\n            if (algorithm.iv.byteLength !== this.ivSize) {\n                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n            }\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        if (algorithm.length !== this.keySizeBits) {\n            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\nclass RsaProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {\n            throw new TypeError(\"The modulus length must be a multiple of 8 bits and >= 256 and <= 16384\");\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass RsaSsaProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSASSA-PKCS1-v1_5\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n}\nclass RsaPssProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-PSS\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"saltLength\");\n        if (typeof algorithm.saltLength !== \"number\") {\n            throw new TypeError(\"saltLength: Is not a Number\");\n        }\n        if (algorithm.saltLength < 0) {\n            throw new RangeError(\"saltLength: Must be positive number\");\n        }\n    }\n}\nclass RsaOaepProvider extends RsaProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSA-OAEP\";\n        this.usages = {\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ],\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ]\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n            throw new TypeError(\"label: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n}\nclass EllipticProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"namedCurve\");\n        this.checkNamedCurve(algorithm.namedCurve);\n    }\n    checkNamedCurve(namedCurve) {\n        for (const item of this.namedCurves){\n            if (item.toLowerCase() === namedCurve.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(\", \")}`);\n    }\n}\nclass EcdsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDSA\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nconst KEY_TYPES = [\n    \"secret\",\n    \"private\",\n    \"public\"\n];\nclass CryptoKey {\n    static create(algorithm, type, extractable, usages) {\n        const key = new this();\n        key.algorithm = algorithm;\n        key.type = type;\n        key.extractable = extractable;\n        key.usages = usages;\n        return key;\n    }\n    static isKeyType(data) {\n        return KEY_TYPES.indexOf(data) !== -1;\n    }\n    get [Symbol.toStringTag]() {\n        return \"CryptoKey\";\n    }\n}\nclass EcdhProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH\";\n        this.usages = {\n            privateKey: [\n                \"deriveBits\",\n                \"deriveKey\"\n            ],\n            publicKey: []\n        };\n        this.namedCurves = [\n            \"P-256\",\n            \"P-384\",\n            \"P-521\",\n            \"K-256\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"public\");\n        if (!(algorithm.public instanceof CryptoKey)) {\n            throw new TypeError(\"public: Is not a CryptoKey\");\n        }\n        if (algorithm.public.type !== \"public\") {\n            throw new OperationError(\"public: Is not a public key\");\n        }\n        if (algorithm.public.algorithm.name !== this.name) {\n            throw new OperationError(`public: Is not ${this.name} key`);\n        }\n    }\n}\nclass EcdhEsProvider extends EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"ECDH-ES\";\n        this.namedCurves = [\n            \"X25519\",\n            \"X448\"\n        ];\n    }\n}\nclass EdDsaProvider extends EllipticProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"EdDSA\";\n        this.usages = {\n            privateKey: [\n                \"sign\"\n            ],\n            publicKey: [\n                \"verify\"\n            ]\n        };\n        this.namedCurves = [\n            \"Ed25519\",\n            \"Ed448\"\n        ];\n    }\n}\nlet ObjectIdentifier = class ObjectIdentifier {\n    constructor(value){\n        if (value) {\n            this.value = value;\n        }\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], ObjectIdentifier.prototype, \"value\", void 0);\nObjectIdentifier = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], ObjectIdentifier);\nclass AlgorithmIdentifier {\n    constructor(params){\n        Object.assign(this, params);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier\n    })\n], AlgorithmIdentifier.prototype, \"algorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], AlgorithmIdentifier.prototype, \"parameters\", void 0);\nclass PrivateKeyInfo {\n    constructor(){\n        this.version = 0;\n        this.privateKeyAlgorithm = new AlgorithmIdentifier();\n        this.privateKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer\n    })\n], PrivateKeyInfo.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PrivateKeyInfo.prototype, \"privateKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], PrivateKeyInfo.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], PrivateKeyInfo.prototype, \"attributes\", void 0);\nclass PublicKeyInfo {\n    constructor(){\n        this.publicKeyAlgorithm = new AlgorithmIdentifier();\n        this.publicKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: AlgorithmIdentifier\n    })\n], PublicKeyInfo.prototype, \"publicKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], PublicKeyInfo.prototype, \"publicKey\", void 0);\nconst JsonBase64UrlArrayBufferConverter = {\n    fromJSON: (value)=>pvtsutils.Convert.FromBase64Url(value),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(new Uint8Array(value))\n};\nconst AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>{\n        const valueHex = value.valueBlock.valueHex;\n        return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;\n    },\n    toASN: (value)=>{\n        const valueHex = new Uint8Array(value)[0] > 127 ? pvtsutils.combine(new Uint8Array([\n            0\n        ]).buffer, value) : value;\n        return new asn1__namespace.Integer({\n            valueHex\n        });\n    }\n};\nvar index$3 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,\n    JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter\n});\nclass RsaPrivateKey {\n    constructor(){\n        this.version = 0;\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n        this.privateExponent = new ArrayBuffer(0);\n        this.prime1 = new ArrayBuffer(0);\n        this.prime2 = new ArrayBuffer(0);\n        this.exponent1 = new ArrayBuffer(0);\n        this.exponent2 = new ArrayBuffer(0);\n        this.coefficient = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], RsaPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"publicExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"d\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"privateExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"p\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"q\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"prime2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dp\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"dq\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"exponent2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"qi\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPrivateKey.prototype, \"coefficient\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], RsaPrivateKey.prototype, \"otherPrimeInfos\", void 0);\nclass RsaPublicKey {\n    constructor(){\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"n\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerArrayBufferConverter\n    }),\n    jsonSchema.JsonProp({\n        name: \"e\",\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], RsaPublicKey.prototype, \"publicExponent\", void 0);\nlet EcPublicKey = class EcPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        let bytes = new Uint8Array(this.value);\n        if (bytes[0] !== 0x04) {\n            throw new CryptoError(\"Wrong ECPoint. Current version supports only Uncompressed (0x04) point\");\n        }\n        bytes = new Uint8Array(this.value.slice(1));\n        const size = bytes.length / 2;\n        const offset = 0;\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        if (!(\"y\" in json)) {\n            throw new Error(\"y: Missing required property\");\n        }\n        const x = pvtsutils.Convert.FromBase64Url(json.x);\n        const y = pvtsutils.Convert.FromBase64Url(json.y);\n        const value = pvtsutils.combine(new Uint8Array([\n            0x04\n        ]).buffer, x, y);\n        this.value = new Uint8Array(value).buffer;\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPublicKey.prototype, \"value\", void 0);\nEcPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EcPublicKey);\nclass EcPrivateKey {\n    constructor(){\n        this.version = 1;\n        this.privateKey = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!(\"d\" in json)) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);\n        if (\"x\" in json) {\n            const publicKey = new EcPublicKey();\n            publicKey.fromJSON(json);\n            const asn = asn1Schema.AsnSerializer.toASN(publicKey);\n            if (\"valueHex\" in asn.valueBlock) {\n                this.publicKey = asn.valueBlock.valueHex;\n            }\n        }\n        return this;\n    }\n    toJSON() {\n        const jwk = {};\n        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);\n        if (this.publicKey) {\n            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n        }\n        return jwk;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: asn1Schema.AsnIntegerConverter\n    })\n], EcPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EcPrivateKey.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 0,\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"parameters\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], EcPrivateKey.prototype, \"publicKey\", void 0);\nconst AsnIntegerWithoutPaddingConverter = {\n    fromASN: (value)=>{\n        const bytes = new Uint8Array(value.valueBlock.valueHex);\n        return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;\n    },\n    toASN: (value)=>{\n        const bytes = new Uint8Array(value);\n        if (bytes[0] > 127) {\n            const newValue = new Uint8Array(bytes.length + 1);\n            newValue.set(bytes, 1);\n            return new asn1__namespace.Integer({\n                valueHex: newValue.buffer\n            });\n        }\n        return new asn1__namespace.Integer({\n            valueHex: value\n        });\n    }\n};\nvar index$2 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter\n});\nclass EcUtils {\n    static decodePoint(data, pointSize) {\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length === 0 || view[0] !== 4) {\n            throw new Error(\"Only uncompressed point format supported\");\n        }\n        const n = (view.length - 1) / 2;\n        if (n !== Math.ceil(pointSize / 8)) {\n            throw new Error(\"Point does not match field size\");\n        }\n        const xb = view.slice(1, n + 1);\n        const yb = view.slice(n + 1, n + 1 + n);\n        return {\n            x: xb,\n            y: yb\n        };\n    }\n    static encodePoint(point, pointSize) {\n        const size = Math.ceil(pointSize / 8);\n        if (point.x.byteLength !== size || point.y.byteLength !== size) {\n            throw new Error(\"X,Y coordinates don't match point size criteria\");\n        }\n        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);\n        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);\n        const res = new Uint8Array(size * 2 + 1);\n        res[0] = 4;\n        res.set(x, 1);\n        res.set(y, size + 1);\n        return res;\n    }\n    static getSize(pointSize) {\n        return Math.ceil(pointSize / 8);\n    }\n    static encodeSignature(signature, pointSize) {\n        const size = this.getSize(pointSize);\n        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);\n        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);\n        const res = new Uint8Array(size * 2);\n        res.set(this.padStart(r, size));\n        res.set(this.padStart(s, size), size);\n        return res;\n    }\n    static decodeSignature(data, pointSize) {\n        const size = this.getSize(pointSize);\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length !== size * 2) {\n            throw new Error(\"Incorrect size of the signature\");\n        }\n        const r = view.slice(0, size);\n        const s = view.slice(size);\n        return {\n            r: this.trimStart(r),\n            s: this.trimStart(s)\n        };\n    }\n    static trimStart(data) {\n        let i = 0;\n        while(i < data.length - 1 && data[i] === 0){\n            i++;\n        }\n        if (i === 0) {\n            return data;\n        }\n        return data.slice(i, data.length);\n    }\n    static padStart(data, size) {\n        if (size === data.length) {\n            return data;\n        }\n        const res = new Uint8Array(size);\n        res.set(data, size - data.length);\n        return res;\n    }\n}\nclass EcDsaSignature {\n    constructor(){\n        this.r = new ArrayBuffer(0);\n        this.s = new ArrayBuffer(0);\n    }\n    static fromWebCryptoSignature(value) {\n        const pointSize = value.byteLength / 2;\n        const point = EcUtils.decodeSignature(value, pointSize * 8);\n        const ecSignature = new EcDsaSignature();\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);\n        return ecSignature;\n    }\n    toWebCryptoSignature(pointSize) {\n        pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;\n        const signature = EcUtils.encodeSignature(this, pointSize);\n        return signature.buffer;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"r\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Integer,\n        converter: AsnIntegerWithoutPaddingConverter\n    })\n], EcDsaSignature.prototype, \"s\", void 0);\nclass OneAsymmetricKey extends PrivateKeyInfo {\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        context: 1,\n        implicit: true,\n        type: asn1Schema.AsnPropTypes.BitString,\n        optional: true\n    })\n], OneAsymmetricKey.prototype, \"publicKey\", void 0);\nlet EdPrivateKey = class EdPrivateKey {\n    constructor(){\n        this.value = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!json.d) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.d);\n        return this;\n    }\n    toJSON() {\n        const jwk = {\n            d: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return jwk;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    })\n], EdPrivateKey.prototype, \"value\", void 0);\nEdPrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPrivateKey);\nlet EdPublicKey = class EdPublicKey {\n    constructor(value){\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(this.value)\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.x);\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.BitString\n    })\n], EdPublicKey.prototype, \"value\", void 0);\nEdPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], EdPublicKey);\nlet CurvePrivateKey = class CurvePrivateKey {\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.OctetString\n    }),\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        converter: JsonBase64UrlArrayBufferConverter\n    })\n], CurvePrivateKey.prototype, \"d\", void 0);\nCurvePrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({\n        type: asn1Schema.AsnTypeTypes.Choice\n    })\n], CurvePrivateKey);\nconst idSecp256r1 = \"1.2.840.10045.3.1.7\";\nconst idEllipticCurve = \"1.3.132.0\";\nconst idSecp384r1 = `${idEllipticCurve}.34`;\nconst idSecp521r1 = `${idEllipticCurve}.35`;\nconst idSecp256k1 = `${idEllipticCurve}.10`;\nconst idVersionOne = \"1.3.36.3.3.2.8.1.1\";\nconst idBrainpoolP160r1 = `${idVersionOne}.1`;\nconst idBrainpoolP160t1 = `${idVersionOne}.2`;\nconst idBrainpoolP192r1 = `${idVersionOne}.3`;\nconst idBrainpoolP192t1 = `${idVersionOne}.4`;\nconst idBrainpoolP224r1 = `${idVersionOne}.5`;\nconst idBrainpoolP224t1 = `${idVersionOne}.6`;\nconst idBrainpoolP256r1 = `${idVersionOne}.7`;\nconst idBrainpoolP256t1 = `${idVersionOne}.8`;\nconst idBrainpoolP320r1 = `${idVersionOne}.9`;\nconst idBrainpoolP320t1 = `${idVersionOne}.10`;\nconst idBrainpoolP384r1 = `${idVersionOne}.11`;\nconst idBrainpoolP384t1 = `${idVersionOne}.12`;\nconst idBrainpoolP512r1 = `${idVersionOne}.13`;\nconst idBrainpoolP512t1 = `${idVersionOne}.14`;\nconst idX25519 = \"1.3.101.110\";\nconst idX448 = \"1.3.101.111\";\nconst idEd25519 = \"1.3.101.112\";\nconst idEd448 = \"1.3.101.113\";\nvar index$1 = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    AlgorithmIdentifier: AlgorithmIdentifier,\n    get CurvePrivateKey () {\n        return CurvePrivateKey;\n    },\n    EcDsaSignature: EcDsaSignature,\n    EcPrivateKey: EcPrivateKey,\n    get EcPublicKey () {\n        return EcPublicKey;\n    },\n    get EdPrivateKey () {\n        return EdPrivateKey;\n    },\n    get EdPublicKey () {\n        return EdPublicKey;\n    },\n    get ObjectIdentifier () {\n        return ObjectIdentifier;\n    },\n    OneAsymmetricKey: OneAsymmetricKey,\n    PrivateKeyInfo: PrivateKeyInfo,\n    PublicKeyInfo: PublicKeyInfo,\n    RsaPrivateKey: RsaPrivateKey,\n    RsaPublicKey: RsaPublicKey,\n    converters: index$2,\n    idBrainpoolP160r1: idBrainpoolP160r1,\n    idBrainpoolP160t1: idBrainpoolP160t1,\n    idBrainpoolP192r1: idBrainpoolP192r1,\n    idBrainpoolP192t1: idBrainpoolP192t1,\n    idBrainpoolP224r1: idBrainpoolP224r1,\n    idBrainpoolP224t1: idBrainpoolP224t1,\n    idBrainpoolP256r1: idBrainpoolP256r1,\n    idBrainpoolP256t1: idBrainpoolP256t1,\n    idBrainpoolP320r1: idBrainpoolP320r1,\n    idBrainpoolP320t1: idBrainpoolP320t1,\n    idBrainpoolP384r1: idBrainpoolP384r1,\n    idBrainpoolP384t1: idBrainpoolP384t1,\n    idBrainpoolP512r1: idBrainpoolP512r1,\n    idBrainpoolP512t1: idBrainpoolP512t1,\n    idEd25519: idEd25519,\n    idEd448: idEd448,\n    idEllipticCurve: idEllipticCurve,\n    idSecp256k1: idSecp256k1,\n    idSecp256r1: idSecp256r1,\n    idSecp384r1: idSecp384r1,\n    idSecp521r1: idSecp521r1,\n    idVersionOne: idVersionOne,\n    idX25519: idX25519,\n    idX448: idX448\n});\nclass EcCurves {\n    constructor(){}\n    static register(item) {\n        const oid = new ObjectIdentifier();\n        oid.value = item.id;\n        const raw = asn1Schema.AsnConvert.serialize(oid);\n        this.items.push({\n            ...item,\n            raw\n        });\n        this.names.push(item.name);\n    }\n    static find(nameOrId) {\n        nameOrId = nameOrId.toUpperCase();\n        for (const item of this.items){\n            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n                return item;\n            }\n        }\n        return null;\n    }\n    static get(nameOrId) {\n        const res = this.find(nameOrId);\n        if (!res) {\n            throw new Error(`Unsupported EC named curve '${nameOrId}'`);\n        }\n        return res;\n    }\n}\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({\n    name: \"P-256\",\n    id: idSecp256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"P-384\",\n    id: idSecp384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"P-521\",\n    id: idSecp521r1,\n    size: 521\n});\nEcCurves.register({\n    name: \"K-256\",\n    id: idSecp256k1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP160r1\",\n    id: idBrainpoolP160r1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP160t1\",\n    id: idBrainpoolP160t1,\n    size: 160\n});\nEcCurves.register({\n    name: \"brainpoolP192r1\",\n    id: idBrainpoolP192r1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP192t1\",\n    id: idBrainpoolP192t1,\n    size: 192\n});\nEcCurves.register({\n    name: \"brainpoolP224r1\",\n    id: idBrainpoolP224r1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP224t1\",\n    id: idBrainpoolP224t1,\n    size: 224\n});\nEcCurves.register({\n    name: \"brainpoolP256r1\",\n    id: idBrainpoolP256r1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP256t1\",\n    id: idBrainpoolP256t1,\n    size: 256\n});\nEcCurves.register({\n    name: \"brainpoolP320r1\",\n    id: idBrainpoolP320r1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP320t1\",\n    id: idBrainpoolP320t1,\n    size: 320\n});\nEcCurves.register({\n    name: \"brainpoolP384r1\",\n    id: idBrainpoolP384r1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP384t1\",\n    id: idBrainpoolP384t1,\n    size: 384\n});\nEcCurves.register({\n    name: \"brainpoolP512r1\",\n    id: idBrainpoolP512r1,\n    size: 512\n});\nEcCurves.register({\n    name: \"brainpoolP512t1\",\n    id: idBrainpoolP512t1,\n    size: 512\n});\nclass HmacProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HMAC\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"sign\",\n            \"verify\"\n        ];\n    }\n    getDefaultLength(algName) {\n        switch(algName.toUpperCase()){\n            case \"SHA-1\":\n            case \"SHA-256\":\n            case \"SHA-384\":\n            case \"SHA-512\":\n                return 512;\n            default:\n                throw new Error(`Unknown algorithm name '${algName}'`);\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        if (\"length\" in algorithm) {\n            if (typeof algorithm.length !== \"number\") {\n                throw new TypeError(\"length: Is not a Number\");\n            }\n            if (algorithm.length < 1) {\n                throw new RangeError(\"length: Number is out of range\");\n            }\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\nclass Pbkdf2Provider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"PBKDF2\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveBits\",\n            \"deriveKey\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"iterations\");\n        if (typeof algorithm.iterations !== \"number\") {\n            throw new TypeError(\"iterations: Is not a Number\");\n        }\n        if (algorithm.iterations < 1) {\n            throw new TypeError(\"iterations: Is less than 1\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass HkdfProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"HKDF\";\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\"\n        ];\n        this.usages = [\n            \"deriveKey\",\n            \"deriveBits\"\n        ];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"info\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\nclass ShakeProvider extends ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.usages = [];\n        this.defaultLength = 0;\n    }\n    digest(...args) {\n        args[0] = {\n            length: this.defaultLength,\n            ...args[0]\n        };\n        return super.digest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        super.checkDigest(algorithm, data);\n        const length = algorithm.length || 0;\n        if (typeof length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (length < 0) {\n            throw new TypeError(\"length: Is negative\");\n        }\n    }\n}\nclass Shake128Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake128\";\n        this.defaultLength = 16;\n    }\n}\nclass Shake256Provider extends ShakeProvider {\n    constructor(){\n        super(...arguments);\n        this.name = \"shake256\";\n        this.defaultLength = 32;\n    }\n}\nclass Crypto {\n    get [Symbol.toStringTag]() {\n        return \"Crypto\";\n    }\n    randomUUID() {\n        const b = this.getRandomValues(new Uint8Array(16));\n        b[6] = b[6] & 0x0f | 0x40;\n        b[8] = b[8] & 0x3f | 0x80;\n        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();\n        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n}\nclass ProviderStorage {\n    constructor(){\n        this.items = {};\n    }\n    get(algorithmName) {\n        return this.items[algorithmName.toLowerCase()] || null;\n    }\n    set(provider) {\n        this.items[provider.name.toLowerCase()] = provider;\n    }\n    removeAt(algorithmName) {\n        const provider = this.get(algorithmName.toLowerCase());\n        if (provider) {\n            delete this.items[algorithmName];\n        }\n        return provider;\n    }\n    has(name) {\n        return !!this.get(name);\n    }\n    get length() {\n        return Object.keys(this.items).length;\n    }\n    get algorithms() {\n        const algorithms = [];\n        for(const key in this.items){\n            const provider = this.items[key];\n            algorithms.push(provider.name);\n        }\n        return algorithms.sort();\n    }\n}\nclass SubtleCrypto {\n    constructor(){\n        this.providers = new ProviderStorage();\n    }\n    static isHashedAlgorithm(data) {\n        return data && typeof data === \"object\" && \"name\" in data && \"hash\" in data ? true : false;\n    }\n    get [Symbol.toStringTag]() {\n        return \"SubtleCrypto\";\n    }\n    async digest(...args) {\n        this.checkRequiredArguments(args, 2, \"digest\");\n        const [algorithm, data, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n        return result;\n    }\n    async generateKey(...args) {\n        this.checkRequiredArguments(args, 3, \"generateKey\");\n        const [algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.generateKey({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n        return result;\n    }\n    async sign(...args) {\n        this.checkRequiredArguments(args, 3, \"sign\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.sign({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, ...params);\n        return result;\n    }\n    async verify(...args) {\n        this.checkRequiredArguments(args, 4, \"verify\");\n        const [algorithm, key, signature, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.verify({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedSignature, preparedData, ...params);\n        return result;\n    }\n    async encrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"encrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async decrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"decrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, key, preparedData, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveBits(...args) {\n        this.checkRequiredArguments(args, 3, \"deriveBits\");\n        const [algorithm, baseKey, length, ...params] = args;\n        this.checkCryptoKey(baseKey);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, length, {\n            keyUsage: true\n        }, ...params);\n        return result;\n    }\n    async deriveKey(...args) {\n        this.checkRequiredArguments(args, 5, \"deriveKey\");\n        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n        const importProvider = this.getProvider(preparedDerivedKeyType.name);\n        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        provider.checkCryptoKey(baseKey, \"deriveKey\");\n        const derivedBits = await provider.deriveBits({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, baseKey, derivedKeyType.length || 512, {\n            keyUsage: false\n        }, ...params);\n        return this.importKey(\"raw\", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n    }\n    async exportKey(...args) {\n        this.checkRequiredArguments(args, 2, \"exportKey\");\n        const [format, key, ...params] = args;\n        this.checkCryptoKey(key);\n        const provider = this.getProvider(key.algorithm.name);\n        const result = await provider.exportKey(format, key, ...params);\n        return result;\n    }\n    async importKey(...args) {\n        this.checkRequiredArguments(args, 5, \"importKey\");\n        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        if ([\n            \"pkcs8\",\n            \"spki\",\n            \"raw\"\n        ].indexOf(format) !== -1) {\n            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n            return provider.importKey(format, preparedData, {\n                ...preparedAlgorithm,\n                name: provider.name\n            }, extractable, keyUsages, ...params);\n        } else {\n            if (!keyData.kty) {\n                throw new TypeError(\"keyData: Is not JSON\");\n            }\n        }\n        return provider.importKey(format, keyData, {\n            ...preparedAlgorithm,\n            name: provider.name\n        }, extractable, keyUsages, ...params);\n    }\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n        let keyData = await this.exportKey(format, key, ...args);\n        if (format === \"jwk\") {\n            const json = JSON.stringify(keyData);\n            keyData = pvtsutils.Convert.FromUtf8String(json);\n        }\n        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        return provider.encrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, wrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n    }\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        let keyData = await provider.decrypt({\n            ...preparedAlgorithm,\n            name: provider.name\n        }, unwrappingKey, preparedData, {\n            keyUsage: false\n        }, ...args);\n        if (format === \"jwk\") {\n            try {\n                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));\n            } catch (e) {\n                const error = new TypeError(\"wrappedKey: Is not a JSON\");\n                error.internal = e;\n                throw error;\n            }\n        }\n        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n    }\n    checkRequiredArguments(args, size, methodName) {\n        if (args.length < size) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);\n        }\n    }\n    prepareAlgorithm(algorithm) {\n        if (typeof algorithm === \"string\") {\n            return {\n                name: algorithm\n            };\n        }\n        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n            const preparedAlgorithm = {\n                ...algorithm\n            };\n            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);\n            return preparedAlgorithm;\n        }\n        return {\n            ...algorithm\n        };\n    }\n    getProvider(name) {\n        const provider = this.providers.get(name);\n        if (!provider) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n        return provider;\n    }\n    checkCryptoKey(key) {\n        if (!(key instanceof CryptoKey)) {\n            throw new TypeError(`Key is not of type 'CryptoKey'`);\n        }\n    }\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    converters: index$3\n});\nconst REQUIRED_FIELDS = [\n    \"crv\",\n    \"e\",\n    \"k\",\n    \"kty\",\n    \"n\",\n    \"x\",\n    \"y\"\n];\nclass JwkUtils {\n    static async thumbprint(hash, jwk, crypto) {\n        const data = this.format(jwk, true);\n        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));\n    }\n    static format(jwk, remove = false) {\n        let res = Object.entries(jwk);\n        if (remove) {\n            res = res.filter((o)=>REQUIRED_FIELDS.includes(o[0]));\n        }\n        res = res.sort(([keyA], [keyB])=>keyA > keyB ? 1 : keyA < keyB ? -1 : 0);\n        return Object.fromEntries(res);\n    }\n}\nObject.defineProperty(exports, \"BufferSourceConverter\", ({\n    enumerable: true,\n    get: function() {\n        return pvtsutils.BufferSourceConverter;\n    }\n}));\nexports.AesCbcProvider = AesCbcProvider;\nexports.AesCmacProvider = AesCmacProvider;\nexports.AesCtrProvider = AesCtrProvider;\nexports.AesEcbProvider = AesEcbProvider;\nexports.AesGcmProvider = AesGcmProvider;\nexports.AesKwProvider = AesKwProvider;\nexports.AesProvider = AesProvider;\nexports.AlgorithmError = AlgorithmError;\nexports.Crypto = Crypto;\nexports.CryptoError = CryptoError;\nexports.CryptoKey = CryptoKey;\nexports.DesProvider = DesProvider;\nexports.EcCurves = EcCurves;\nexports.EcUtils = EcUtils;\nexports.EcdhEsProvider = EcdhEsProvider;\nexports.EcdhProvider = EcdhProvider;\nexports.EcdsaProvider = EcdsaProvider;\nexports.EdDsaProvider = EdDsaProvider;\nexports.EllipticProvider = EllipticProvider;\nexports.HkdfProvider = HkdfProvider;\nexports.HmacProvider = HmacProvider;\nexports.JwkUtils = JwkUtils;\nexports.OperationError = OperationError;\nexports.Pbkdf2Provider = Pbkdf2Provider;\nexports.PemConverter = PemConverter;\nexports.ProviderCrypto = ProviderCrypto;\nexports.ProviderStorage = ProviderStorage;\nexports.RequiredPropertyError = RequiredPropertyError;\nexports.RsaOaepProvider = RsaOaepProvider;\nexports.RsaProvider = RsaProvider;\nexports.RsaPssProvider = RsaPssProvider;\nexports.RsaSsaProvider = RsaSsaProvider;\nexports.Shake128Provider = Shake128Provider;\nexports.Shake256Provider = Shake256Provider;\nexports.ShakeProvider = ShakeProvider;\nexports.SubtleCrypto = SubtleCrypto;\nexports.UnsupportedOperationError = UnsupportedOperationError;\nexports.asn1 = index$1;\nexports.isJWK = isJWK;\nexports.json = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvYnVpbGQvd2ViY3J5cHRvLWNvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsR0FFQTtBQUVBLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLGFBQWFILG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlJLE9BQU9KLG1CQUFPQSxDQUFDO0FBRW5CLFNBQVNLLHlCQUF5QkMsQ0FBQztJQUNqQyxJQUFJQyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNMRSxPQUFPRSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2hDLElBQUlBLE1BQU0sV0FBVztnQkFDbkIsSUFBSUMsSUFBSUwsT0FBT00sd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ0osT0FBT08sY0FBYyxDQUFDUixHQUFHSyxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7b0JBQ3RDSSxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9WLENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDbEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQUwsRUFBRVcsT0FBTyxHQUFHWjtJQUNaLE9BQU9FLE9BQU9XLE1BQU0sQ0FBQ1o7QUFDdkI7QUFFQSxJQUFJYSxrQkFBa0IsV0FBVyxHQUFFZix5QkFBeUJEO0FBRTVELE1BQU1pQixvQkFBb0JDO0FBQzFCO0FBRUEsTUFBTUMsdUJBQXVCRjtBQUM3QjtBQUVBLE1BQU1HLGtDQUFrQ0g7SUFDcENJLFlBQVlDLFVBQVUsQ0FBRTtRQUNwQixLQUFLLENBQUMsQ0FBQyx1QkFBdUIsRUFBRUEsYUFBYSxDQUFDLEVBQUVBLFdBQVcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUN2RTtBQUNKO0FBRUEsTUFBTUMsdUJBQXVCTjtBQUM3QjtBQUVBLE1BQU1P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QnNPLGdCQUFnQixHQUFHcEY7QUFDbkJvRixlQUFlLEdBQUc3STtBQUNsQjZJLHNCQUFzQixHQUFHNU07QUFDekI0TSxvQkFBb0IsR0FBRzlNO0FBQ3ZCOE0scUJBQXFCLEdBQUdyTjtBQUN4QnFOLHFCQUFxQixHQUFHM007QUFDeEIyTSx3QkFBd0IsR0FBR3pOO0FBQzNCeU4sb0JBQW9CLEdBQUdsRTtBQUN2QmtFLG9CQUFvQixHQUFHekU7QUFDdkJ5RSxnQkFBZ0IsR0FBR2I7QUFDbkJhLHNCQUFzQixHQUFHMVc7QUFDekIwVyxzQkFBc0IsR0FBR3RFO0FBQ3pCc0Usb0JBQW9CLEdBQUd2VztBQUN2QnVXLHNCQUFzQixHQUFHbFU7QUFDekJrVSx1QkFBdUIsR0FBR3JEO0FBQzFCcUQsNkJBQTZCLEdBQUd6VztBQUNoQ3lXLHVCQUF1QixHQUFHM047QUFDMUIyTixtQkFBbUIsR0FBR25PO0FBQ3RCbU8sc0JBQXNCLEdBQUc5TjtBQUN6QjhOLHNCQUFzQixHQUFHL047QUFDekIrTix3QkFBd0IsR0FBRzlEO0FBQzNCOEQsd0JBQXdCLEdBQUc3RDtBQUMzQjZELHFCQUFxQixHQUFHaEU7QUFDeEJnRSxvQkFBb0IsR0FBRzlDO0FBQ3ZCOEMsaUNBQWlDLEdBQUc3VztBQUNwQzZXLFlBQVksR0FBR3RGO0FBQ2ZzRixhQUFhLEdBQUduVTtBQUNoQm1VLFlBQVksR0FBR2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvYnVpbGQvd2ViY3J5cHRvLWNvcmUuanM/OGRlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB2dHN1dGlscyA9IHJlcXVpcmUoJ3B2dHN1dGlscycpO1xudmFyIGFzbjFTY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvYXNuMS1zY2hlbWEnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIganNvblNjaGVtYSA9IHJlcXVpcmUoJ0BwZWN1bGlhci9qc29uLXNjaGVtYScpO1xudmFyIGFzbjEgPSByZXF1aXJlKCdhc24xanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGUpIHtcbiAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG4uZGVmYXVsdCA9IGU7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgYXNuMV9fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChhc24xKTtcblxuY2xhc3MgQ3J5cHRvRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNsYXNzIEFsZ29yaXRobUVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xufVxuXG5jbGFzcyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIG9wZXJhdGlvbjogJHttZXRob2ROYW1lID8gYCR7bWV0aG9kTmFtZX1gIDogXCJcIn1gKTtcbiAgICB9XG59XG5cbmNsYXNzIE9wZXJhdGlvbkVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xufVxuXG5jbGFzcyBSZXF1aXJlZFByb3BlcnR5RXJyb3IgZXh0ZW5kcyBDcnlwdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IocHJvcE5hbWUpIHtcbiAgICAgICAgc3VwZXIoYCR7cHJvcE5hbWV9OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5YCk7XG4gICAgfVxufVxuXG5jbGFzcyBQZW1Db252ZXJ0ZXIge1xuICAgIHN0YXRpYyB0b0FycmF5QnVmZmVyKHBlbSkge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBwZW1cbiAgICAgICAgICAgIC5yZXBsYWNlKC8tezV9KEJFR0lOfEVORCkgLiotezV9L2csIFwiXCIpXG4gICAgICAgICAgICAucmVwbGFjZShcIlxcclwiLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJcXG5cIiwgXCJcIik7XG4gICAgICAgIHJldHVybiBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0KGJhc2U2NCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1VpbnQ4QXJyYXkocGVtKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy50b0FycmF5QnVmZmVyKHBlbSk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnVmZmVyU291cmNlKGJ1ZmZlciwgdGFnKSB7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0KGJ1ZmZlcik7XG4gICAgICAgIGxldCBzbGljZWQ7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCByb3dzID0gW107XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBiYXNlNjQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzbGljZWQgPSBiYXNlNjQuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA2NCk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChzbGljZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBwZXJDYXNlVGFnID0gdGFnLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgLS0tLS1CRUdJTiAke3VwcGVyQ2FzZVRhZ30tLS0tLVxcbiR7cm93cy5qb2luKFwiXFxuXCIpfVxcbi0tLS0tRU5EICR7dXBwZXJDYXNlVGFnfS0tLS0tYDtcbiAgICB9XG4gICAgc3RhdGljIGlzUEVNKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIC8tLS0tLUJFR0lOIC4rLS0tLS1bQS1aYS16MC05Ky8rPVxcc1xcbl0rLS0tLS1FTkQgListLS0tLS9pLnRlc3QoZGF0YSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUYWdOYW1lKHBlbSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNQRU0ocGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIHBhcmFtZXRlci4gSW5jb21pbmcgZGF0YSBpcyBub3QgcmlnaHQgUEVNXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IC8tLS0tLUJFR0lOICguKyktLS0tLS8uZXhlYyhwZW0pO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0YWcgZnJvbSBQRU1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc1sxXTtcbiAgICB9XG4gICAgc3RhdGljIGhhc1RhZ05hbWUocGVtLCB0YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0VGFnTmFtZShwZW0pO1xuICAgICAgICByZXR1cm4gdGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ2VydGlmaWNhdGUocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcImNlcnRpZmljYXRlXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDZXJ0aWZpY2F0ZVJlcXVlc3QocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcImNlcnRpZmljYXRlIHJlcXVlc3RcIik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NSTChwZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnTmFtZShwZW0sIFwieDUwOSBjcmxcIik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1B1YmxpY0tleShwZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnTmFtZShwZW0sIFwicHVibGljIGtleVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzSldLKGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgXCJrdHlcIiBpbiBkYXRhO1xufVxuXG5jbGFzcyBQcm92aWRlckNyeXB0byB7XG4gICAgYXN5bmMgZGlnZXN0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0RpZ2VzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGlnZXN0KGFsZ29yaXRobSwgX2RhdGEpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICB9XG4gICAgYXN5bmMgb25EaWdlc3QoX2FsZ29yaXRobSwgX2RhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJkaWdlc3RcIik7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkdlbmVyYXRlS2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5KGFsZ29yaXRobSwgX2V4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICBpZiAoIShrZXlVc2FnZXMgJiYga2V5VXNhZ2VzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVzYWdlcyBjYW5ub3QgYmUgZW1wdHkgd2hlbiBjcmVhdGluZyBhIGtleS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWxsb3dlZFVzYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy51c2FnZXMpKSB7XG4gICAgICAgICAgICBhbGxvd2VkVXNhZ2VzID0gdGhpcy51c2FnZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGxvd2VkVXNhZ2VzID0gdGhpcy51c2FnZXMucHJpdmF0ZUtleS5jb25jYXQodGhpcy51c2FnZXMucHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrS2V5VXNhZ2VzKGtleVVzYWdlcywgYWxsb3dlZFVzYWdlcyk7XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoX2FsZ29yaXRobSkge1xuICAgIH1cbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KF9hbGdvcml0aG0sIF9leHRyYWN0YWJsZSwgX2tleVVzYWdlcywgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJnZW5lcmF0ZUtleVwiKTtcbiAgICB9XG4gICAgYXN5bmMgc2lnbiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vblNpZ24uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrU2lnbihhbGdvcml0aG0sIGtleSwgX2RhdGEsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIFwic2lnblwiKTtcbiAgICB9XG4gICAgYXN5bmMgb25TaWduKF9hbGdvcml0aG0sIF9rZXksIF9kYXRhLCAuLi5fYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIHZlcmlmeSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tWZXJpZnkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uVmVyaWZ5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja1ZlcmlmeShhbGdvcml0aG0sIGtleSwgX3NpZ25hdHVyZSwgX2RhdGEsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBvblZlcmlmeShfYWxnb3JpdGhtLCBfa2V5LCBfc2lnbmF0dXJlLCBfZGF0YSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJ2ZXJpZnlcIik7XG4gICAgfVxuICAgIGFzeW5jIGVuY3J5cHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRW5jcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25FbmNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0VuY3J5cHQoYWxnb3JpdGhtLCBrZXksIF9kYXRhLCBvcHRpb25zID0ge30sIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXksIG9wdGlvbnMua2V5VXNhZ2UgPyBcImVuY3J5cHRcIiA6IHZvaWQgMCk7XG4gICAgfVxuICAgIGFzeW5jIG9uRW5jcnlwdChfYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJlbmNyeXB0XCIpO1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0RlY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRGVjcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tEZWNyeXB0KGFsZ29yaXRobSwga2V5LCBfZGF0YSwgb3B0aW9ucyA9IHt9LCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBvcHRpb25zLmtleVVzYWdlID8gXCJkZWNyeXB0XCIgOiB2b2lkIDApO1xuICAgIH1cbiAgICBhc3luYyBvbkRlY3J5cHQoX2FsZ29yaXRobSwgX2tleSwgX2RhdGEsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGVjcnlwdFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVyaXZlQml0cyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRlcml2ZUJpdHMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCwgb3B0aW9ucyA9IHt9LCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoYmFzZUtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZGVyaXZlQml0c1wiIDogdm9pZCAwKTtcbiAgICAgICAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogSXMgbm90IG11bHRpcGxlIG9mIDhcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKF9hbGdvcml0aG0sIF9iYXNlS2V5LCBfbGVuZ3RoLCAuLi5fYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImRlcml2ZUJpdHNcIik7XG4gICAgfVxuICAgIGFzeW5jIGV4cG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tFeHBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRXhwb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0V4cG9ydEtleShmb3JtYXQsIGtleSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleUZvcm1hdChmb3JtYXQpO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGlmICgha2V5LmV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoXCJrZXk6IElzIG5vdCBleHRyYWN0YWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkV4cG9ydEtleShfZm9ybWF0LCBfa2V5LCAuLi5fYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImV4cG9ydEtleVwiKTtcbiAgICB9XG4gICAgYXN5bmMgaW1wb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25JbXBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBfZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleUZvcm1hdChmb3JtYXQpO1xuICAgICAgICB0aGlzLmNoZWNrS2V5RGF0YShmb3JtYXQsIGtleURhdGEpO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrSW1wb3J0UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXNhZ2VzKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMsIHRoaXMudXNhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBvbkltcG9ydEtleShfZm9ybWF0LCBfa2V5RGF0YSwgX2FsZ29yaXRobSwgX2V4dHJhY3RhYmxlLCBfa2V5VXNhZ2VzLCAuLi5fYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImltcG9ydEtleVwiKTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGhpcy5uYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKF9hbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tEZXJpdmVkS2V5UGFyYW1zKF9hbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tLZXlVc2FnZXModXNhZ2VzLCBhbGxvd2VkKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXNhZ2Ugb2YgdXNhZ2VzKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZC5pbmRleE9mKHVzYWdlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNyZWF0ZSBhIGtleSB1c2luZyB0aGUgc3BlY2lmaWVkIGtleSB1c2FnZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKGtleVVzYWdlICYmIGtleS51c2FnZXMuaW5kZXhPZihrZXlVc2FnZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoYGtleSBkb2VzIG5vdCBtYXRjaCB0aGF0IG9mIG9wZXJhdGlvbmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrUmVxdWlyZWRQcm9wZXJ0eShkYXRhLCBwcm9wTmFtZSkge1xuICAgICAgICBpZiAoIShwcm9wTmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlcXVpcmVkUHJvcGVydHlFcnJvcihwcm9wTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobSwgaGFzaEFsZ29yaXRobXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGhhc2hBbGdvcml0aG1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS50b0xvd2VyQ2FzZSgpID09PSBhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgaGFzaDogTXVzdCBiZSBvbmUgb2YgJHtoYXNoQWxnb3JpdGhtcy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0UGFyYW1zKF9hbGdvcml0aG0pIHtcbiAgICB9XG4gICAgY2hlY2tLZXlGb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmb3JtYXQ6IElzIGludmFsaWQgdmFsdWUuIE11c3QgYmUgJ2p3aycsICdyYXcnLCAnc3BraScsIG9yICdwa2NzOCdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tLZXlEYXRhKGZvcm1hdCwga2V5RGF0YSkge1xuICAgICAgICBpZiAoIWtleURhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBDYW5ub3QgYmUgZW1wdHkgb24gZW1wdHkgb24ga2V5IGltcG9ydGluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImp3a1wiKSB7XG4gICAgICAgICAgICBpZiAoIWlzSldLKGtleURhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IElzIG5vdCBKc29uV2ViVG9rZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2Uoa2V5RGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBJcyBub3QgQXJyYXlCdWZmZXJWaWV3IG9yIEFycmF5QnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICB9XG59XG5cbmNsYXNzIEFlc1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJsZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IG9mIHR5cGUgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICBjYXNlIDE5MjpcbiAgICAgICAgICAgIGNhc2UgMjU2OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBNdXN0IGJlIDEyOCwgMTkyLCBvciAyNTZcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEZXJpdmVkS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICB9XG59XG5cbmNsYXNzIEFlc0NiY1Byb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1DQkNcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaXZcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uaXYpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uaXYuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogTXVzdCBoYXZlIGxlbmd0aCAxNiBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzQ21hY1Byb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1DTUFDXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wic2lnblwiLCBcInZlcmlmeVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJsZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwibGVuZ3RoOiBNdXN0IGJlIG1vcmUgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNDdHJQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtQ1RSXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImNvdW50ZXJcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5jb3VudGVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5jb3VudGVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb3VudGVyOiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uY291bnRlci5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBNdXN0IGhhdmUgbGVuZ3RoIDE2IGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJsZW5ndGhcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLmxlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwibGVuZ3RoOiBNdXN0IGJlIG1vcmUgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBBZXNFY2JQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtRUNCXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbn1cblxuY2xhc3MgQWVzR2NtUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUdDTVwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpdlwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5pdikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5pdi5ieXRlTGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwiaXY6IE11c3QgaGF2ZSBsZW5ndGggbW9yZSB0aGFuIDAgYW5kIGxlc3MgdGhhbiAyXjY0IC0gMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcInRhZ0xlbmd0aFwiIGluIGFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgIGFsZ29yaXRobS50YWdMZW5ndGggPSAxMjg7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0udGFnTGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSA2NDpcbiAgICAgICAgICAgIGNhc2UgOTY6XG4gICAgICAgICAgICBjYXNlIDEwNDpcbiAgICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgY2FzZSAxMjA6XG4gICAgICAgICAgICBjYXNlIDEyODpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwidGFnTGVuZ3RoOiBNdXN0IGJlIG9uZSBvZiAzMiwgNjQsIDk2LCAxMDQsIDExMiwgMTIwIG9yIDEyOFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzS3dQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtS1dcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbn1cblxuY2xhc3MgRGVzUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXZTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaXZcIik7XG4gICAgICAgICAgICBpZiAoIShhbGdvcml0aG0uaXYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLml2KSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxnb3JpdGhtLml2LmJ5dGVMZW5ndGggIT09IHRoaXMuaXZTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaXY6IE11c3QgaGF2ZSBsZW5ndGggJHt0aGlzLml2U2l6ZX0gYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBvZiB0eXBlIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCAhPT0gdGhpcy5rZXlTaXplQml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKGBhbGdvcml0aG0ubGVuZ3RoOiBNdXN0IGJlICR7dGhpcy5rZXlTaXplQml0c31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Rlcml2ZWRLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pO1xuICAgIH1cbn1cblxuY2xhc3MgUnNhUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY0V4cG9uZW50XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0ucHVibGljRXhwb25lbnQgJiYgYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTWlzc2luZyBvciBub3QgYSBVaW50OEFycmF5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0V4cG9uZW50ID0gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjQoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50KTtcbiAgICAgICAgaWYgKCEocHVibGljRXhwb25lbnQgPT09IFwiQXc9PVwiIHx8IHB1YmxpY0V4cG9uZW50ID09PSBcIkFRQUJcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTXVzdCBiZSBbM10gb3IgWzEsMCwxXVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibW9kdWx1c0xlbmd0aFwiKTtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoICUgOFxuICAgICAgICAgICAgfHwgYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPCAyNTZcbiAgICAgICAgICAgIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID4gMTYzODQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbW9kdWx1cyBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDggYml0cyBhbmQgPj0gMjU2IGFuZCA8PSAxNjM4NFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltcG9ydFBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVNzYVByb3ZpZGVyIGV4dGVuZHMgUnNhUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQVNTQS1QS0NTMS12MV81XCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY2xhc3MgUnNhUHNzUHJvdmlkZXIgZXh0ZW5kcyBSc2FQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBLVBTU1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJzYWx0TGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5zYWx0TGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2FsdExlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uc2FsdExlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic2FsdExlbmd0aDogTXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFJzYU9hZXBQcm92aWRlciBleHRlbmRzIFJzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0EtT0FFUFwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlY3J5cHRcIiwgXCJ1bndyYXBLZXlcIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5sYWJlbFxuICAgICAgICAgICAgJiYgIShhbGdvcml0aG0ubGFiZWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLmxhYmVsKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsYWJlbDogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRWxsaXB0aWNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibmFtZWRDdXJ2ZVwiKTtcbiAgICAgICAgdGhpcy5jaGVja05hbWVkQ3VydmUoYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xuICAgIH1cbiAgICBjaGVja05hbWVkQ3VydmUobmFtZWRDdXJ2ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5uYW1lZEN1cnZlcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9Mb3dlckNhc2UoKSA9PT0gbmFtZWRDdXJ2ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgbmFtZWRDdXJ2ZTogTXVzdCBiZSBvbmUgb2YgJHt0aGlzLm5hbWVkQ3VydmVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG59XG5cbmNsYXNzIEVjZHNhUHJvdmlkZXIgZXh0ZW5kcyBFbGxpcHRpY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJFQ0RTQVwiO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wic2lnblwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1widmVyaWZ5XCJdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiUC0yNTZcIiwgXCJQLTM4NFwiLCBcIlAtNTIxXCIsIFwiSy0yNTZcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgIH1cbn1cblxuY29uc3QgS0VZX1RZUEVTID0gW1wic2VjcmV0XCIsIFwicHJpdmF0ZVwiLCBcInB1YmxpY1wiXTtcbmNsYXNzIENyeXB0b0tleSB7XG4gICAgc3RhdGljIGNyZWF0ZShhbGdvcml0aG0sIHR5cGUsIGV4dHJhY3RhYmxlLCB1c2FnZXMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IHRoaXMoKTtcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAga2V5LnR5cGUgPSB0eXBlO1xuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcbiAgICAgICAga2V5LnVzYWdlcyA9IHVzYWdlcztcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgc3RhdGljIGlzS2V5VHlwZShkYXRhKSB7XG4gICAgICAgIHJldHVybiBLRVlfVFlQRVMuaW5kZXhPZihkYXRhKSAhPT0gLTE7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ3J5cHRvS2V5XCI7XG4gICAgfVxufVxuXG5jbGFzcyBFY2RoUHJvdmlkZXIgZXh0ZW5kcyBFbGxpcHRpY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJFQ0RIXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xuICAgICAgICAgICAgcHJpdmF0ZUtleTogW1wiZGVyaXZlQml0c1wiLCBcImRlcml2ZUtleVwiXSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJQLTI1NlwiLCBcIlAtMzg0XCIsIFwiUC01MjFcIiwgXCJLLTI1NlwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWMgaW5zdGFuY2VvZiBDcnlwdG9LZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljOiBJcyBub3QgYSBDcnlwdG9LZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5wdWJsaWMudHlwZSAhPT0gXCJwdWJsaWNcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwicHVibGljOiBJcyBub3QgYSBwdWJsaWMga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ucHVibGljLmFsZ29yaXRobS5uYW1lICE9PSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgcHVibGljOiBJcyBub3QgJHt0aGlzLm5hbWV9IGtleWApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBFY2RoRXNQcm92aWRlciBleHRlbmRzIEVjZGhQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRUNESC1FU1wiO1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiWDI1NTE5XCIsIFwiWDQ0OFwiXTtcbiAgICB9XG59XG5cbmNsYXNzIEVkRHNhUHJvdmlkZXIgZXh0ZW5kcyBFbGxpcHRpY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJFZERTQVwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIkVkMjU1MTlcIiwgXCJFZDQ0OFwiXTtcbiAgICB9XG59XG5cbmxldCBPYmplY3RJZGVudGlmaWVyID0gY2xhc3MgT2JqZWN0SWRlbnRpZmllciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2JqZWN0SWRlbnRpZmllciB9KVxuXSwgT2JqZWN0SWRlbnRpZmllci5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbk9iamVjdElkZW50aWZpZXIgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIE9iamVjdElkZW50aWZpZXIpO1xuXG5jbGFzcyBBbGdvcml0aG1JZGVudGlmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwYXJhbXMpO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7XG4gICAgICAgIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9iamVjdElkZW50aWZpZXIsXG4gICAgfSlcbl0sIEFsZ29yaXRobUlkZW50aWZpZXIucHJvdG90eXBlLCBcImFsZ29yaXRobVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHtcbiAgICAgICAgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LFxuICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB9KVxuXSwgQWxnb3JpdGhtSWRlbnRpZmllci5wcm90b3R5cGUsIFwicGFyYW1ldGVyc1wiLCB2b2lkIDApO1xuXG5jbGFzcyBQcml2YXRlS2V5SW5mbyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleUFsZ29yaXRobSA9IG5ldyBBbGdvcml0aG1JZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogQWxnb3JpdGhtSWRlbnRpZmllciB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcInByaXZhdGVLZXlBbGdvcml0aG1cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBQcml2YXRlS2V5SW5mby5wcm90b3R5cGUsIFwicHJpdmF0ZUtleVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcImF0dHJpYnV0ZXNcIiwgdm9pZCAwKTtcblxuY2xhc3MgUHVibGljS2V5SW5mbyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucHVibGljS2V5QWxnb3JpdGhtID0gbmV3IEFsZ29yaXRobUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogQWxnb3JpdGhtSWRlbnRpZmllciB9KVxuXSwgUHVibGljS2V5SW5mby5wcm90b3R5cGUsIFwicHVibGljS2V5QWxnb3JpdGhtXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcgfSlcbl0sIFB1YmxpY0tleUluZm8ucHJvdG90eXBlLCBcInB1YmxpY0tleVwiLCB2b2lkIDApO1xuXG5jb25zdCBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUpTT046ICh2YWx1ZSkgPT4gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybCh2YWx1ZSksXG4gICAgdG9KU09OOiAodmFsdWUpID0+IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKG5ldyBVaW50OEFycmF5KHZhbHVlKSksXG59O1xuXG5jb25zdCBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlSGV4ID0gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuICEobmV3IFVpbnQ4QXJyYXkodmFsdWVIZXgpWzBdKVxuICAgICAgICAgICAgPyB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4LnNsaWNlKDEpXG4gICAgICAgICAgICA6IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgfSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlSGV4ID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpWzBdID4gMTI3XG4gICAgICAgICAgICA/IHB2dHN1dGlscy5jb21iaW5lKG5ldyBVaW50OEFycmF5KFswXSkuYnVmZmVyLCB2YWx1ZSlcbiAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMV9fbmFtZXNwYWNlLkludGVnZXIoeyB2YWx1ZUhleCB9KTtcbiAgICB9LFxufTtcblxudmFyIGluZGV4JDMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIsXG4gIEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyXG59KTtcblxuY2xhc3MgUnNhUHJpdmF0ZUtleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDA7XG4gICAgICAgIHRoaXMubW9kdWx1cyA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wdWJsaWNFeHBvbmVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wcml2YXRlRXhwb25lbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHJpbWUxID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnByaW1lMiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5leHBvbmVudDEgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMuZXhwb25lbnQyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLmNvZWZmaWNpZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogYXNuMVNjaGVtYS5Bc25JbnRlZ2VyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJuXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJtb2R1bHVzXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJlXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNFeHBvbmVudFwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZFwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpdmF0ZUV4cG9uZW50XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJwXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcmltZTFcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcInFcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaW1lMlwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZHBcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcImV4cG9uZW50MVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZHFcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcImV4cG9uZW50MlwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwicWlcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcImNvZWZmaWNpZW50XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJvdGhlclByaW1lSW5mb3NcIiwgdm9pZCAwKTtcblxuY2xhc3MgUnNhUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tb2R1bHVzID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnB1YmxpY0V4cG9uZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcIm5cIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVB1YmxpY0tleS5wcm90b3R5cGUsIFwibW9kdWx1c1wiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHVibGljS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNFeHBvbmVudFwiLCB2b2lkIDApO1xuXG5sZXQgRWNQdWJsaWNLZXkgPSBjbGFzcyBFY1B1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlKTtcbiAgICAgICAgaWYgKGJ5dGVzWzBdICE9PSAweDA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvRXJyb3IoXCJXcm9uZyBFQ1BvaW50LiBDdXJyZW50IHZlcnNpb24gc3VwcG9ydHMgb25seSBVbmNvbXByZXNzZWQgKDB4MDQpIHBvaW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZS5zbGljZSgxKSk7XG4gICAgICAgIGNvbnN0IHNpemUgPSBieXRlcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBqc29uID0ge1xuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYnl0ZXMuYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSkpLFxuICAgICAgICAgICAgeTogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYnl0ZXMuYnVmZmVyLnNsaWNlKG9mZnNldCArIHNpemUsIG9mZnNldCArIHNpemUgKyBzaXplKSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIGlmICghKFwieFwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKFwieVwiIGluIGpzb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5OiBNaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XG4gICAgICAgIGNvbnN0IHkgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHZ0c3V0aWxzLmNvbWJpbmUobmV3IFVpbnQ4QXJyYXkoWzB4MDRdKS5idWZmZXIsIHgsIHkpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpLmJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBFY1B1YmxpY0tleS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkVjUHVibGljS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBFY1B1YmxpY0tleSk7XG5cbmNsYXNzIEVjUHJpdmF0ZUtleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIShcImRcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZDogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24uZCk7XG4gICAgICAgIGlmIChcInhcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBuZXcgRWNQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgIHB1YmxpY0tleS5mcm9tSlNPTihqc29uKTtcbiAgICAgICAgICAgIGNvbnN0IGFzbiA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci50b0FTTihwdWJsaWNLZXkpO1xuICAgICAgICAgICAgaWYgKFwidmFsdWVIZXhcIiBpbiBhc24udmFsdWVCbG9jaykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5ID0gYXNuLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgandrID0ge307XG4gICAgICAgIGp3ay5kID0gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodGhpcy5wcml2YXRlS2V5KTtcbiAgICAgICAgaWYgKHRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGp3aywgbmV3IEVjUHVibGljS2V5KHRoaXMucHVibGljS2V5KS50b0pTT04oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IGFzbjFTY2hlbWEuQXNuSW50ZWdlckNvbnZlcnRlciB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJ2ZXJzaW9uXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcml2YXRlS2V5XCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyBjb250ZXh0OiAwLCB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5BbnksIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IGNvbnRleHQ6IDEsIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZywgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHVibGljS2V5XCIsIHZvaWQgMCk7XG5cbmNvbnN0IEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4KTtcbiAgICAgICAgcmV0dXJuIChieXRlc1swXSA9PT0gMClcbiAgICAgICAgICAgID8gYnl0ZXMuYnVmZmVyLnNsaWNlKDEpXG4gICAgICAgICAgICA6IGJ5dGVzLmJ1ZmZlcjtcbiAgICB9LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmIChieXRlc1swXSA+IDEyNykge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBuZXcgVWludDhBcnJheShieXRlcy5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlLnNldChieXRlcywgMSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFfX25hbWVzcGFjZS5JbnRlZ2VyKHsgdmFsdWVIZXg6IG5ld1ZhbHVlLmJ1ZmZlciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGFzbjFfX25hbWVzcGFjZS5JbnRlZ2VyKHsgdmFsdWVIZXg6IHZhbHVlIH0pO1xuICAgIH0sXG59O1xuXG52YXIgaW5kZXgkMiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXI6IEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlclxufSk7XG5cbmNsYXNzIEVjVXRpbHMge1xuICAgIHN0YXRpYyBkZWNvZGVQb2ludChkYXRhLCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGRhdGEpO1xuICAgICAgICBpZiAoKHZpZXcubGVuZ3RoID09PSAwKSB8fCAodmlld1swXSAhPT0gNCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkgdW5jb21wcmVzc2VkIHBvaW50IGZvcm1hdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9ICh2aWV3Lmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgaWYgKG4gIT09IChNYXRoLmNlaWwocG9pbnRTaXplIC8gOCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2ludCBkb2VzIG5vdCBtYXRjaCBmaWVsZCBzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhiID0gdmlldy5zbGljZSgxLCBuICsgMSk7XG4gICAgICAgIGNvbnN0IHliID0gdmlldy5zbGljZShuICsgMSwgbiArIDEgKyBuKTtcbiAgICAgICAgcmV0dXJuIHsgeDogeGIsIHk6IHliIH07XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVQb2ludChwb2ludCwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLmNlaWwocG9pbnRTaXplIC8gOCk7XG4gICAgICAgIGlmIChwb2ludC54LmJ5dGVMZW5ndGggIT09IHNpemUgfHwgcG9pbnQueS5ieXRlTGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJYLFkgY29vcmRpbmF0ZXMgZG9uJ3QgbWF0Y2ggcG9pbnQgc2l6ZSBjcml0ZXJpYVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocG9pbnQueCk7XG4gICAgICAgIGNvbnN0IHkgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwb2ludC55KTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIDIgKyAxKTtcbiAgICAgICAgcmVzWzBdID0gNDtcbiAgICAgICAgcmVzLnNldCh4LCAxKTtcbiAgICAgICAgcmVzLnNldCh5LCBzaXplICsgMSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaXplKHBvaW50U2l6ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHBvaW50U2l6ZSAvIDgpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlU2lnbmF0dXJlKHNpZ25hdHVyZSwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUocG9pbnRTaXplKTtcbiAgICAgICAgY29uc3QgciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHNpZ25hdHVyZS5yKTtcbiAgICAgICAgY29uc3QgcyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHNpZ25hdHVyZS5zKTtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSAqIDIpO1xuICAgICAgICByZXMuc2V0KHRoaXMucGFkU3RhcnQociwgc2l6ZSkpO1xuICAgICAgICByZXMuc2V0KHRoaXMucGFkU3RhcnQocywgc2l6ZSksIHNpemUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlU2lnbmF0dXJlKGRhdGEsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKHBvaW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKHZpZXcubGVuZ3RoICE9PSAoc2l6ZSAqIDIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3Qgc2l6ZSBvZiB0aGUgc2lnbmF0dXJlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSB2aWV3LnNsaWNlKDAsIHNpemUpO1xuICAgICAgICBjb25zdCBzID0gdmlldy5zbGljZShzaXplKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHRoaXMudHJpbVN0YXJ0KHIpLFxuICAgICAgICAgICAgczogdGhpcy50cmltU3RhcnQocyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB0cmltU3RhcnQoZGF0YSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlICgoaSA8IGRhdGEubGVuZ3RoIC0gMSkgJiYgKGRhdGFbaV0gPT09IDApKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKGksIGRhdGEubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIHBhZFN0YXJ0KGRhdGEsIHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUgPT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICAgICAgcmVzLnNldChkYXRhLCBzaXplIC0gZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cblxuY2xhc3MgRWNEc2FTaWduYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucyA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21XZWJDcnlwdG9TaWduYXR1cmUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gdmFsdWUuYnl0ZUxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gRWNVdGlscy5kZWNvZGVTaWduYXR1cmUodmFsdWUsIHBvaW50U2l6ZSAqIDgpO1xuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZSA9IG5ldyBFY0RzYVNpZ25hdHVyZSgpO1xuICAgICAgICBlY1NpZ25hdHVyZS5yID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBvaW50LnIpO1xuICAgICAgICBlY1NpZ25hdHVyZS5zID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBvaW50LnMpO1xuICAgICAgICByZXR1cm4gZWNTaWduYXR1cmU7XG4gICAgfVxuICAgIHRvV2ViQ3J5cHRvU2lnbmF0dXJlKHBvaW50U2l6ZSkge1xuICAgICAgICBwb2ludFNpemUgIT09IG51bGwgJiYgcG9pbnRTaXplICE9PSB2b2lkIDAgPyBwb2ludFNpemUgOiAocG9pbnRTaXplID0gTWF0aC5tYXgodGhpcy5yLmJ5dGVMZW5ndGgsIHRoaXMucy5ieXRlTGVuZ3RoKSAqIDgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBFY1V0aWxzLmVuY29kZVNpZ25hdHVyZSh0aGlzLCBwb2ludFNpemUpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlLmJ1ZmZlcjtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlciB9KVxuXSwgRWNEc2FTaWduYXR1cmUucHJvdG90eXBlLCBcInJcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyIH0pXG5dLCBFY0RzYVNpZ25hdHVyZS5wcm90b3R5cGUsIFwic1wiLCB2b2lkIDApO1xuXG5jbGFzcyBPbmVBc3ltbWV0cmljS2V5IGV4dGVuZHMgUHJpdmF0ZUtleUluZm8ge1xufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgY29udGV4dDogMSwgaW1wbGljaXQ6IHRydWUsIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZywgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE9uZUFzeW1tZXRyaWNLZXkucHJvdG90eXBlLCBcInB1YmxpY0tleVwiLCB2b2lkIDApO1xuXG5sZXQgRWRQcml2YXRlS2V5ID0gY2xhc3MgRWRQcml2YXRlS2V5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIWpzb24uZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZDogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLmQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCBqd2sgPSB7XG4gICAgICAgICAgICBkOiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGp3aztcbiAgICB9XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIEVkUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkVkUHJpdmF0ZUtleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgRWRQcml2YXRlS2V5KTtcblxubGV0IEVkUHVibGljS2V5ID0gY2xhc3MgRWRQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIHg6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHRoaXMudmFsdWUpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIShcInhcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieDogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLngpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nIH0pXG5dLCBFZFB1YmxpY0tleS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbkVkUHVibGljS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBFZFB1YmxpY0tleSk7XG5cbmxldCBDdXJ2ZVByaXZhdGVLZXkgPSBjbGFzcyBDdXJ2ZVByaXZhdGVLZXkge1xufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgQ3VydmVQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJkXCIsIHZvaWQgMCk7XG5DdXJ2ZVByaXZhdGVLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEN1cnZlUHJpdmF0ZUtleSk7XG5cbmNvbnN0IGlkU2VjcDI1NnIxID0gXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI7XG5jb25zdCBpZEVsbGlwdGljQ3VydmUgPSBcIjEuMy4xMzIuMFwiO1xuY29uc3QgaWRTZWNwMzg0cjEgPSBgJHtpZEVsbGlwdGljQ3VydmV9LjM0YDtcbmNvbnN0IGlkU2VjcDUyMXIxID0gYCR7aWRFbGxpcHRpY0N1cnZlfS4zNWA7XG5jb25zdCBpZFNlY3AyNTZrMSA9IGAke2lkRWxsaXB0aWNDdXJ2ZX0uMTBgO1xuY29uc3QgaWRWZXJzaW9uT25lID0gXCIxLjMuMzYuMy4zLjIuOC4xLjFcIjtcbmNvbnN0IGlkQnJhaW5wb29sUDE2MHIxID0gYCR7aWRWZXJzaW9uT25lfS4xYDtcbmNvbnN0IGlkQnJhaW5wb29sUDE2MHQxID0gYCR7aWRWZXJzaW9uT25lfS4yYDtcbmNvbnN0IGlkQnJhaW5wb29sUDE5MnIxID0gYCR7aWRWZXJzaW9uT25lfS4zYDtcbmNvbnN0IGlkQnJhaW5wb29sUDE5MnQxID0gYCR7aWRWZXJzaW9uT25lfS40YDtcbmNvbnN0IGlkQnJhaW5wb29sUDIyNHIxID0gYCR7aWRWZXJzaW9uT25lfS41YDtcbmNvbnN0IGlkQnJhaW5wb29sUDIyNHQxID0gYCR7aWRWZXJzaW9uT25lfS42YDtcbmNvbnN0IGlkQnJhaW5wb29sUDI1NnIxID0gYCR7aWRWZXJzaW9uT25lfS43YDtcbmNvbnN0IGlkQnJhaW5wb29sUDI1NnQxID0gYCR7aWRWZXJzaW9uT25lfS44YDtcbmNvbnN0IGlkQnJhaW5wb29sUDMyMHIxID0gYCR7aWRWZXJzaW9uT25lfS45YDtcbmNvbnN0IGlkQnJhaW5wb29sUDMyMHQxID0gYCR7aWRWZXJzaW9uT25lfS4xMGA7XG5jb25zdCBpZEJyYWlucG9vbFAzODRyMSA9IGAke2lkVmVyc2lvbk9uZX0uMTFgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzg0dDEgPSBgJHtpZFZlcnNpb25PbmV9LjEyYDtcbmNvbnN0IGlkQnJhaW5wb29sUDUxMnIxID0gYCR7aWRWZXJzaW9uT25lfS4xM2A7XG5jb25zdCBpZEJyYWlucG9vbFA1MTJ0MSA9IGAke2lkVmVyc2lvbk9uZX0uMTRgO1xuY29uc3QgaWRYMjU1MTkgPSBcIjEuMy4xMDEuMTEwXCI7XG5jb25zdCBpZFg0NDggPSBcIjEuMy4xMDEuMTExXCI7XG5jb25zdCBpZEVkMjU1MTkgPSBcIjEuMy4xMDEuMTEyXCI7XG5jb25zdCBpZEVkNDQ4ID0gXCIxLjMuMTAxLjExM1wiO1xuXG52YXIgaW5kZXgkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBbGdvcml0aG1JZGVudGlmaWVyOiBBbGdvcml0aG1JZGVudGlmaWVyLFxuICBnZXQgQ3VydmVQcml2YXRlS2V5ICgpIHsgcmV0dXJuIEN1cnZlUHJpdmF0ZUtleTsgfSxcbiAgRWNEc2FTaWduYXR1cmU6IEVjRHNhU2lnbmF0dXJlLFxuICBFY1ByaXZhdGVLZXk6IEVjUHJpdmF0ZUtleSxcbiAgZ2V0IEVjUHVibGljS2V5ICgpIHsgcmV0dXJuIEVjUHVibGljS2V5OyB9LFxuICBnZXQgRWRQcml2YXRlS2V5ICgpIHsgcmV0dXJuIEVkUHJpdmF0ZUtleTsgfSxcbiAgZ2V0IEVkUHVibGljS2V5ICgpIHsgcmV0dXJuIEVkUHVibGljS2V5OyB9LFxuICBnZXQgT2JqZWN0SWRlbnRpZmllciAoKSB7IHJldHVybiBPYmplY3RJZGVudGlmaWVyOyB9LFxuICBPbmVBc3ltbWV0cmljS2V5OiBPbmVBc3ltbWV0cmljS2V5LFxuICBQcml2YXRlS2V5SW5mbzogUHJpdmF0ZUtleUluZm8sXG4gIFB1YmxpY0tleUluZm86IFB1YmxpY0tleUluZm8sXG4gIFJzYVByaXZhdGVLZXk6IFJzYVByaXZhdGVLZXksXG4gIFJzYVB1YmxpY0tleTogUnNhUHVibGljS2V5LFxuICBjb252ZXJ0ZXJzOiBpbmRleCQyLFxuICBpZEJyYWlucG9vbFAxNjByMTogaWRCcmFpbnBvb2xQMTYwcjEsXG4gIGlkQnJhaW5wb29sUDE2MHQxOiBpZEJyYWlucG9vbFAxNjB0MSxcbiAgaWRCcmFpbnBvb2xQMTkycjE6IGlkQnJhaW5wb29sUDE5MnIxLFxuICBpZEJyYWlucG9vbFAxOTJ0MTogaWRCcmFpbnBvb2xQMTkydDEsXG4gIGlkQnJhaW5wb29sUDIyNHIxOiBpZEJyYWlucG9vbFAyMjRyMSxcbiAgaWRCcmFpbnBvb2xQMjI0dDE6IGlkQnJhaW5wb29sUDIyNHQxLFxuICBpZEJyYWlucG9vbFAyNTZyMTogaWRCcmFpbnBvb2xQMjU2cjEsXG4gIGlkQnJhaW5wb29sUDI1NnQxOiBpZEJyYWlucG9vbFAyNTZ0MSxcbiAgaWRCcmFpbnBvb2xQMzIwcjE6IGlkQnJhaW5wb29sUDMyMHIxLFxuICBpZEJyYWlucG9vbFAzMjB0MTogaWRCcmFpbnBvb2xQMzIwdDEsXG4gIGlkQnJhaW5wb29sUDM4NHIxOiBpZEJyYWlucG9vbFAzODRyMSxcbiAgaWRCcmFpbnBvb2xQMzg0dDE6IGlkQnJhaW5wb29sUDM4NHQxLFxuICBpZEJyYWlucG9vbFA1MTJyMTogaWRCcmFpbnBvb2xQNTEycjEsXG4gIGlkQnJhaW5wb29sUDUxMnQxOiBpZEJyYWlucG9vbFA1MTJ0MSxcbiAgaWRFZDI1NTE5OiBpZEVkMjU1MTksXG4gIGlkRWQ0NDg6IGlkRWQ0NDgsXG4gIGlkRWxsaXB0aWNDdXJ2ZTogaWRFbGxpcHRpY0N1cnZlLFxuICBpZFNlY3AyNTZrMTogaWRTZWNwMjU2azEsXG4gIGlkU2VjcDI1NnIxOiBpZFNlY3AyNTZyMSxcbiAgaWRTZWNwMzg0cjE6IGlkU2VjcDM4NHIxLFxuICBpZFNlY3A1MjFyMTogaWRTZWNwNTIxcjEsXG4gIGlkVmVyc2lvbk9uZTogaWRWZXJzaW9uT25lLFxuICBpZFgyNTUxOTogaWRYMjU1MTksXG4gIGlkWDQ0ODogaWRYNDQ4XG59KTtcblxuY2xhc3MgRWNDdXJ2ZXMge1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgc3RhdGljIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgY29uc3Qgb2lkID0gbmV3IE9iamVjdElkZW50aWZpZXIoKTtcbiAgICAgICAgb2lkLnZhbHVlID0gaXRlbS5pZDtcbiAgICAgICAgY29uc3QgcmF3ID0gYXNuMVNjaGVtYS5Bc25Db252ZXJ0LnNlcmlhbGl6ZShvaWQpO1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgICAgIHJhdyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZXMucHVzaChpdGVtLm5hbWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZChuYW1lT3JJZCkge1xuICAgICAgICBuYW1lT3JJZCA9IG5hbWVPcklkLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5hbWVPcklkIHx8IGl0ZW0uaWQudG9VcHBlckNhc2UoKSA9PT0gbmFtZU9ySWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldChuYW1lT3JJZCkge1xuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZpbmQobmFtZU9ySWQpO1xuICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBFQyBuYW1lZCBjdXJ2ZSAnJHtuYW1lT3JJZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5FY0N1cnZlcy5pdGVtcyA9IFtdO1xuRWNDdXJ2ZXMubmFtZXMgPSBbXTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJQLTI1NlwiLCBpZDogaWRTZWNwMjU2cjEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJQLTM4NFwiLCBpZDogaWRTZWNwMzg0cjEsIHNpemU6IDM4NCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJQLTUyMVwiLCBpZDogaWRTZWNwNTIxcjEsIHNpemU6IDUyMSB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJLLTI1NlwiLCBpZDogaWRTZWNwMjU2azEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTYwcjFcIiwgaWQ6IGlkQnJhaW5wb29sUDE2MHIxLCBzaXplOiAxNjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE2MHQxXCIsIGlkOiBpZEJyYWlucG9vbFAxNjB0MSwgc2l6ZTogMTYwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxOTJyMVwiLCBpZDogaWRCcmFpbnBvb2xQMTkycjEsIHNpemU6IDE5MiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTkydDFcIiwgaWQ6IGlkQnJhaW5wb29sUDE5MnQxLCBzaXplOiAxOTIgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDIyNHIxXCIsIGlkOiBpZEJyYWlucG9vbFAyMjRyMSwgc2l6ZTogMjI0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyMjR0MVwiLCBpZDogaWRCcmFpbnBvb2xQMjI0dDEsIHNpemU6IDIyNCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjU2cjFcIiwgaWQ6IGlkQnJhaW5wb29sUDI1NnIxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDI1NnQxXCIsIGlkOiBpZEJyYWlucG9vbFAyNTZ0MSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzMjByMVwiLCBpZDogaWRCcmFpbnBvb2xQMzIwcjEsIHNpemU6IDMyMCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzIwdDFcIiwgaWQ6IGlkQnJhaW5wb29sUDMyMHQxLCBzaXplOiAzMjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDM4NHIxXCIsIGlkOiBpZEJyYWlucG9vbFAzODRyMSwgc2l6ZTogMzg0IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzODR0MVwiLCBpZDogaWRCcmFpbnBvb2xQMzg0dDEsIHNpemU6IDM4NCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQNTEycjFcIiwgaWQ6IGlkQnJhaW5wb29sUDUxMnIxLCBzaXplOiA1MTIgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDUxMnQxXCIsIGlkOiBpZEJyYWlucG9vbFA1MTJ0MSwgc2l6ZTogNTEyIH0pO1xuXG5jbGFzcyBIbWFjUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSE1BQ1wiO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wic2lnblwiLCBcInZlcmlmeVwiXTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdExlbmd0aChhbGdOYW1lKSB7XG4gICAgICAgIHN3aXRjaCAoYWxnTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTEyO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWxnb3JpdGhtIG5hbWUgJyR7YWxnTmFtZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICAgICAgaWYgKFwibGVuZ3RoXCIgaW4gYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImxlbmd0aDogTnVtYmVyIGlzIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltcG9ydFBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICB9XG59XG5cbmNsYXNzIFBia2RmMlByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlBCS0RGMlwiO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZGVyaXZlQml0c1wiLCBcImRlcml2ZUtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJzYWx0XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uc2FsdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uc2FsdCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2FsdDogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaXRlcmF0aW9uc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0uaXRlcmF0aW9ucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvbnM6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLml0ZXJhdGlvbnMgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9uczogSXMgbGVzcyB0aGFuIDFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZXh0cmFjdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcImV4dHJhY3RhYmxlOiBNdXN0IGJlICdmYWxzZSdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEhrZGZQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJIS0RGXCI7XG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXCJTSEEtMVwiLCBcIlNIQS0yNTZcIiwgXCJTSEEtMzg0XCIsIFwiU0hBLTUxMlwiXTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInNhbHRcIik7XG4gICAgICAgIGlmICghcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShhbGdvcml0aG0uc2FsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzYWx0OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJpbmZvXCIpO1xuICAgICAgICBpZiAoIXB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UoYWxnb3JpdGhtLmluZm8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2FsdDogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICBzdXBlci5jaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncyk7XG4gICAgICAgIGlmIChleHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiZXh0cmFjdGFibGU6IE11c3QgYmUgJ2ZhbHNlJ1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgU2hha2VQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZGlnZXN0KC4uLmFyZ3MpIHtcbiAgICAgICAgYXJnc1swXSA9IHsgbGVuZ3RoOiB0aGlzLmRlZmF1bHRMZW5ndGgsIC4uLmFyZ3NbMF0gfTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRpZ2VzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tEaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrRGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFsZ29yaXRobS5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKHR5cGVvZiBsZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbmVnYXRpdmVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNoYWtlMTI4UHJvdmlkZXIgZXh0ZW5kcyBTaGFrZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJzaGFrZTEyOFwiO1xuICAgICAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSAxNjtcbiAgICB9XG59XG5cbmNsYXNzIFNoYWtlMjU2UHJvdmlkZXIgZXh0ZW5kcyBTaGFrZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJzaGFrZTI1NlwiO1xuICAgICAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSAzMjtcbiAgICB9XG59XG5cbmNsYXNzIENyeXB0byB7XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgICByZXR1cm4gXCJDcnlwdG9cIjtcbiAgICB9XG4gICAgcmFuZG9tVVVJRCgpIHtcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG4gICAgICAgIGJbNl0gPSAoYls2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAgICAgYls4XSA9IChiWzhdICYgMHgzZikgfCAweDgwO1xuICAgICAgICBjb25zdCB1dWlkID0gcHZ0c3V0aWxzLkNvbnZlcnQuVG9IZXgoYikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGAke3V1aWQuc3Vic3RyaW5nKDAsIDgpfS0ke3V1aWQuc3Vic3RyaW5nKDgsIDEyKX0tJHt1dWlkLnN1YnN0cmluZygxMiwgMTYpfS0ke3V1aWQuc3Vic3RyaW5nKDE2LCAyMCl9LSR7dXVpZC5zdWJzdHJpbmcoMjApfWA7XG4gICAgfVxufVxuXG5jbGFzcyBQcm92aWRlclN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0ge307XG4gICAgfVxuICAgIGdldChhbGdvcml0aG1OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2FsZ29yaXRobU5hbWUudG9Mb3dlckNhc2UoKV0gfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0KHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuaXRlbXNbcHJvdmlkZXIubmFtZS50b0xvd2VyQ2FzZSgpXSA9IHByb3ZpZGVyO1xuICAgIH1cbiAgICByZW1vdmVBdChhbGdvcml0aG1OYW1lKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXQoYWxnb3JpdGhtTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5pdGVtc1thbGdvcml0aG1OYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0KG5hbWUpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5pdGVtcykubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgYWxnb3JpdGhtcygpIHtcbiAgICAgICAgY29uc3QgYWxnb3JpdGhtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuaXRlbXNba2V5XTtcbiAgICAgICAgICAgIGFsZ29yaXRobXMucHVzaChwcm92aWRlci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxnb3JpdGhtcy5zb3J0KCk7XG4gICAgfVxufVxuXG5jbGFzcyBTdWJ0bGVDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb3ZpZGVycyA9IG5ldyBQcm92aWRlclN0b3JhZ2UoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzSGFzaGVkQWxnb3JpdGhtKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAgICYmIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAmJiBcIm5hbWVcIiBpbiBkYXRhXG4gICAgICAgICAgICAmJiBcImhhc2hcIiBpbiBkYXRhXG4gICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiU3VidGxlQ3J5cHRvXCI7XG4gICAgfVxuICAgIGFzeW5jIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAyLCBcImRpZ2VzdFwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5kaWdlc3QocHJlcGFyZWRBbGdvcml0aG0sIHByZXBhcmVkRGF0YSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJnZW5lcmF0ZUtleVwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZ2VuZXJhdGVLZXkoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaWduKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwic2lnblwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuc2lnbih7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWREYXRhLCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgNCwgXCJ2ZXJpZnlcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkU2lnbmF0dXJlID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIudmVyaWZ5KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZFNpZ25hdHVyZSwgcHJlcGFyZWREYXRhLCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZW5jcnlwdFwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZW5jcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiB0cnVlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlY3J5cHQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJkZWNyeXB0XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm92aWRlci5kZWNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwga2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IHRydWUgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVyaXZlQml0cyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImRlcml2ZUJpdHNcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoYmFzZUtleSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZGVyaXZlQml0cyh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGJhc2VLZXksIGxlbmd0aCwgeyBrZXlVc2FnZTogdHJ1ZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZXJpdmVLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgNSwgXCJkZXJpdmVLZXlcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGJhc2VLZXksIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgY29uc3QgcHJlcGFyZWREZXJpdmVkS2V5VHlwZSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShkZXJpdmVkS2V5VHlwZSk7XG4gICAgICAgIGNvbnN0IGltcG9ydFByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZERlcml2ZWRLZXlUeXBlLm5hbWUpO1xuICAgICAgICBpbXBvcnRQcm92aWRlci5jaGVja0Rlcml2ZWRLZXlQYXJhbXMocHJlcGFyZWREZXJpdmVkS2V5VHlwZSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgcHJvdmlkZXIuY2hlY2tDcnlwdG9LZXkoYmFzZUtleSwgXCJkZXJpdmVLZXlcIik7XG4gICAgICAgIGNvbnN0IGRlcml2ZWRCaXRzID0gYXdhaXQgcHJvdmlkZXIuZGVyaXZlQml0cyh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGJhc2VLZXksIGRlcml2ZWRLZXlUeXBlLmxlbmd0aCB8fCA1MTIsIHsga2V5VXNhZ2U6IGZhbHNlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmltcG9ydEtleShcInJhd1wiLCBkZXJpdmVkQml0cywgZGVyaXZlZEtleVR5cGUsIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIGV4cG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAyLCBcImV4cG9ydEtleVwiKTtcbiAgICAgICAgY29uc3QgW2Zvcm1hdCwga2V5LCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIoa2V5LmFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZXhwb3J0S2V5KGZvcm1hdCwga2V5LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBpbXBvcnRLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgNSwgXCJpbXBvcnRLZXlcIik7XG4gICAgICAgIGNvbnN0IFtmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgaWYgKFtcInBrY3M4XCIsIFwic3BraVwiLCBcInJhd1wiXS5pbmRleE9mKGZvcm1hdCkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoa2V5RGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuaW1wb3J0S2V5KGZvcm1hdCwgcHJlcGFyZWREYXRhLCB7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWtleURhdGEua3R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IElzIG5vdCBKU09OXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlci5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtcyk7XG4gICAgfVxuICAgIGFzeW5jIHdyYXBLZXkoZm9ybWF0LCBrZXksIHdyYXBwaW5nS2V5LCB3cmFwQWxnb3JpdGhtLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBrZXlEYXRhID0gYXdhaXQgdGhpcy5leHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZm9ybWF0ID09PSBcImp3a1wiKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkoa2V5RGF0YSk7XG4gICAgICAgICAgICBrZXlEYXRhID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbVV0ZjhTdHJpbmcoanNvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0od3JhcEFsZ29yaXRobSk7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGF0YSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihrZXlEYXRhKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByZXBhcmVkQWxnb3JpdGhtLm5hbWUpO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIuZW5jcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIHdyYXBwaW5nS2V5LCBwcmVwYXJlZERhdGEsIHsga2V5VXNhZ2U6IGZhbHNlIH0sIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBhc3luYyB1bndyYXBLZXkoZm9ybWF0LCB3cmFwcGVkS2V5LCB1bndyYXBwaW5nS2V5LCB1bndyYXBBbGdvcml0aG0sIHVud3JhcHBlZEtleUFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4uYXJncykge1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobSh1bndyYXBBbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIod3JhcHBlZEtleSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgbGV0IGtleURhdGEgPSBhd2FpdCBwcm92aWRlci5kZWNyeXB0KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgdW53cmFwcGluZ0tleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiBmYWxzZSB9LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBrZXlEYXRhID0gSlNPTi5wYXJzZShwdnRzdXRpbHMuQ29udmVydC5Ub1V0ZjhTdHJpbmcoa2V5RGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoXCJ3cmFwcGVkS2V5OiBJcyBub3QgYSBKU09OXCIpO1xuICAgICAgICAgICAgICAgIGVycm9yLmludGVybmFsID0gZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBjaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIHNpemUsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJyR7bWV0aG9kTmFtZX0nIG9uICdTdWJ0bGVDcnlwdG8nOiAke3NpemV9IGFyZ3VtZW50cyByZXF1aXJlZCwgYnV0IG9ubHkgJHthcmdzLmxlbmd0aH0gcHJlc2VudGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGFsZ29yaXRobSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN1YnRsZUNyeXB0by5pc0hhc2hlZEFsZ29yaXRobShhbGdvcml0aG0pKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHsgLi4uYWxnb3JpdGhtIH07XG4gICAgICAgICAgICBwcmVwYXJlZEFsZ29yaXRobS5oYXNoID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVwYXJlZEFsZ29yaXRobTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAuLi5hbGdvcml0aG0gfTtcbiAgICB9XG4gICAgZ2V0UHJvdmlkZXIobmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFsZ29yaXRobUVycm9yKFwiVW5yZWNvZ25pemVkIG5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICBjaGVja0NyeXB0b0tleShrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgS2V5IGlzIG5vdCBvZiB0eXBlICdDcnlwdG9LZXknYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjb252ZXJ0ZXJzOiBpbmRleCQzXG59KTtcblxuY29uc3QgUkVRVUlSRURfRklFTERTID0gW1wiY3J2XCIsIFwiZVwiLCBcImtcIiwgXCJrdHlcIiwgXCJuXCIsIFwieFwiLCBcInlcIl07XG5jbGFzcyBKd2tVdGlscyB7XG4gICAgc3RhdGljIGFzeW5jIHRodW1icHJpbnQoaGFzaCwgandrLCBjcnlwdG8pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZm9ybWF0KGp3aywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdChoYXNoLCBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmluYXJ5KEpTT04uc3RyaW5naWZ5KGRhdGEpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmb3JtYXQoandrLCByZW1vdmUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmVzID0gT2JqZWN0LmVudHJpZXMoandrKTtcbiAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgcmVzID0gcmVzLmZpbHRlcihvID0+IFJFUVVJUkVEX0ZJRUxEUy5pbmNsdWRlcyhvWzBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gcmVzLnNvcnQoKFtrZXlBXSwgW2tleUJdKSA9PiBrZXlBID4ga2V5QiA/IDEgOiBrZXlBIDwga2V5QiA/IC0xIDogMCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMocmVzKTtcbiAgICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJ1ZmZlclNvdXJjZUNvbnZlcnRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlcjsgfVxufSk7XG5leHBvcnRzLkFlc0NiY1Byb3ZpZGVyID0gQWVzQ2JjUHJvdmlkZXI7XG5leHBvcnRzLkFlc0NtYWNQcm92aWRlciA9IEFlc0NtYWNQcm92aWRlcjtcbmV4cG9ydHMuQWVzQ3RyUHJvdmlkZXIgPSBBZXNDdHJQcm92aWRlcjtcbmV4cG9ydHMuQWVzRWNiUHJvdmlkZXIgPSBBZXNFY2JQcm92aWRlcjtcbmV4cG9ydHMuQWVzR2NtUHJvdmlkZXIgPSBBZXNHY21Qcm92aWRlcjtcbmV4cG9ydHMuQWVzS3dQcm92aWRlciA9IEFlc0t3UHJvdmlkZXI7XG5leHBvcnRzLkFlc1Byb3ZpZGVyID0gQWVzUHJvdmlkZXI7XG5leHBvcnRzLkFsZ29yaXRobUVycm9yID0gQWxnb3JpdGhtRXJyb3I7XG5leHBvcnRzLkNyeXB0byA9IENyeXB0bztcbmV4cG9ydHMuQ3J5cHRvRXJyb3IgPSBDcnlwdG9FcnJvcjtcbmV4cG9ydHMuQ3J5cHRvS2V5ID0gQ3J5cHRvS2V5O1xuZXhwb3J0cy5EZXNQcm92aWRlciA9IERlc1Byb3ZpZGVyO1xuZXhwb3J0cy5FY0N1cnZlcyA9IEVjQ3VydmVzO1xuZXhwb3J0cy5FY1V0aWxzID0gRWNVdGlscztcbmV4cG9ydHMuRWNkaEVzUHJvdmlkZXIgPSBFY2RoRXNQcm92aWRlcjtcbmV4cG9ydHMuRWNkaFByb3ZpZGVyID0gRWNkaFByb3ZpZGVyO1xuZXhwb3J0cy5FY2RzYVByb3ZpZGVyID0gRWNkc2FQcm92aWRlcjtcbmV4cG9ydHMuRWREc2FQcm92aWRlciA9IEVkRHNhUHJvdmlkZXI7XG5leHBvcnRzLkVsbGlwdGljUHJvdmlkZXIgPSBFbGxpcHRpY1Byb3ZpZGVyO1xuZXhwb3J0cy5Ia2RmUHJvdmlkZXIgPSBIa2RmUHJvdmlkZXI7XG5leHBvcnRzLkhtYWNQcm92aWRlciA9IEhtYWNQcm92aWRlcjtcbmV4cG9ydHMuSndrVXRpbHMgPSBKd2tVdGlscztcbmV4cG9ydHMuT3BlcmF0aW9uRXJyb3IgPSBPcGVyYXRpb25FcnJvcjtcbmV4cG9ydHMuUGJrZGYyUHJvdmlkZXIgPSBQYmtkZjJQcm92aWRlcjtcbmV4cG9ydHMuUGVtQ29udmVydGVyID0gUGVtQ29udmVydGVyO1xuZXhwb3J0cy5Qcm92aWRlckNyeXB0byA9IFByb3ZpZGVyQ3J5cHRvO1xuZXhwb3J0cy5Qcm92aWRlclN0b3JhZ2UgPSBQcm92aWRlclN0b3JhZ2U7XG5leHBvcnRzLlJlcXVpcmVkUHJvcGVydHlFcnJvciA9IFJlcXVpcmVkUHJvcGVydHlFcnJvcjtcbmV4cG9ydHMuUnNhT2FlcFByb3ZpZGVyID0gUnNhT2FlcFByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQcm92aWRlciA9IFJzYVByb3ZpZGVyO1xuZXhwb3J0cy5Sc2FQc3NQcm92aWRlciA9IFJzYVBzc1Byb3ZpZGVyO1xuZXhwb3J0cy5Sc2FTc2FQcm92aWRlciA9IFJzYVNzYVByb3ZpZGVyO1xuZXhwb3J0cy5TaGFrZTEyOFByb3ZpZGVyID0gU2hha2UxMjhQcm92aWRlcjtcbmV4cG9ydHMuU2hha2UyNTZQcm92aWRlciA9IFNoYWtlMjU2UHJvdmlkZXI7XG5leHBvcnRzLlNoYWtlUHJvdmlkZXIgPSBTaGFrZVByb3ZpZGVyO1xuZXhwb3J0cy5TdWJ0bGVDcnlwdG8gPSBTdWJ0bGVDcnlwdG87XG5leHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yO1xuZXhwb3J0cy5hc24xID0gaW5kZXgkMTtcbmV4cG9ydHMuaXNKV0sgPSBpc0pXSztcbmV4cG9ydHMuanNvbiA9IGluZGV4O1xuIl0sIm5hbWVzIjpbInB2dHN1dGlscyIsInJlcXVpcmUiLCJhc24xU2NoZW1hIiwidHNsaWIiLCJqc29uU2NoZW1hIiwiYXNuMSIsIl9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdCIsImUiLCJuIiwiT2JqZWN0IiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImRlZmF1bHQiLCJmcmVlemUiLCJhc24xX19uYW1lc3BhY2UiLCJDcnlwdG9FcnJvciIsIkVycm9yIiwiQWxnb3JpdGhtRXJyb3IiLCJVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXRob2ROYW1lIiwiT3BlcmF0aW9uRXJyb3IiLCJSZXF1aXJlZFByb3BlcnR5RXJyb3IiLCJwcm9wTmFtZSIsIlBlbUNvbnZlcnRlciIsInRvQXJyYXlCdWZmZXIiLCJwZW0iLCJiYXNlNjQiLCJyZXBsYWNlIiwiQ29udmVydCIsIkZyb21CYXNlNjQiLCJ0b1VpbnQ4QXJyYXkiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJmcm9tQnVmZmVyU291cmNlIiwiYnVmZmVyIiwidGFnIiwiVG9CYXNlNjQiLCJzbGljZWQiLCJvZmZzZXQiLCJyb3dzIiwibGVuZ3RoIiwic2xpY2UiLCJwdXNoIiwidXBwZXJDYXNlVGFnIiwidG9VcHBlckNhc2UiLCJqb2luIiwiaXNQRU0iLCJkYXRhIiwidGVzdCIsImdldFRhZ05hbWUiLCJyZXMiLCJleGVjIiwiaGFzVGFnTmFtZSIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsImlzQ2VydGlmaWNhdGUiLCJpc0NlcnRpZmljYXRlUmVxdWVzdCIsImlzQ1JMIiwiaXNQdWJsaWNLZXkiLCJpc0pXSyIsIlByb3ZpZGVyQ3J5cHRvIiwiZGlnZXN0IiwiYXJncyIsImNoZWNrRGlnZXN0IiwiYXBwbHkiLCJvbkRpZ2VzdCIsImFsZ29yaXRobSIsIl9kYXRhIiwiY2hlY2tBbGdvcml0aG1OYW1lIiwiX2FsZ29yaXRobSIsImdlbmVyYXRlS2V5IiwiY2hlY2tHZW5lcmF0ZUtleSIsIm9uR2VuZXJhdGVLZXkiLCJfZXh0cmFjdGFibGUiLCJrZXlVc2FnZXMiLCJfYXJncyIsImNoZWNrR2VuZXJhdGVLZXlQYXJhbXMiLCJUeXBlRXJyb3IiLCJhbGxvd2VkVXNhZ2VzIiwiQXJyYXkiLCJpc0FycmF5IiwidXNhZ2VzIiwicHJpdmF0ZUtleSIsImNvbmNhdCIsInB1YmxpY0tleSIsImNoZWNrS2V5VXNhZ2VzIiwiX2tleVVzYWdlcyIsInNpZ24iLCJjaGVja1NpZ24iLCJvblNpZ24iLCJrZXkiLCJjaGVja0FsZ29yaXRobVBhcmFtcyIsImNoZWNrQ3J5cHRvS2V5IiwiX2tleSIsInZlcmlmeSIsImNoZWNrVmVyaWZ5Iiwib25WZXJpZnkiLCJfc2lnbmF0dXJlIiwiZW5jcnlwdCIsImNoZWNrRW5jcnlwdCIsIm9uRW5jcnlwdCIsIm9wdGlvbnMiLCJrZXlVc2FnZSIsImRlY3J5cHQiLCJjaGVja0RlY3J5cHQiLCJvbkRlY3J5cHQiLCJkZXJpdmVCaXRzIiwiY2hlY2tEZXJpdmVCaXRzIiwib25EZXJpdmVCaXRzIiwiYmFzZUtleSIsIl9iYXNlS2V5IiwiX2xlbmd0aCIsImV4cG9ydEtleSIsImNoZWNrRXhwb3J0S2V5Iiwib25FeHBvcnRLZXkiLCJmb3JtYXQiLCJjaGVja0tleUZvcm1hdCIsImV4dHJhY3RhYmxlIiwiX2Zvcm1hdCIsImltcG9ydEtleSIsImNoZWNrSW1wb3J0S2V5Iiwib25JbXBvcnRLZXkiLCJrZXlEYXRhIiwiY2hlY2tLZXlEYXRhIiwiY2hlY2tJbXBvcnRQYXJhbXMiLCJfa2V5RGF0YSIsIm5hbWUiLCJjaGVja0Rlcml2ZWRLZXlQYXJhbXMiLCJhbGxvd2VkIiwidXNhZ2UiLCJpbmRleE9mIiwiY2hlY2tSZXF1aXJlZFByb3BlcnR5IiwiY2hlY2tIYXNoQWxnb3JpdGhtIiwiaGFzaEFsZ29yaXRobXMiLCJpdGVtIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNCdWZmZXJTb3VyY2UiLCJwcmVwYXJlRGF0YSIsIkFlc1Byb3ZpZGVyIiwiQWVzQ2JjUHJvdmlkZXIiLCJhcmd1bWVudHMiLCJpdiIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsIkFlc0NtYWNQcm92aWRlciIsIkFlc0N0clByb3ZpZGVyIiwiY291bnRlciIsIkFlc0VjYlByb3ZpZGVyIiwiQWVzR2NtUHJvdmlkZXIiLCJ0YWdMZW5ndGgiLCJBZXNLd1Byb3ZpZGVyIiwiRGVzUHJvdmlkZXIiLCJpdlNpemUiLCJrZXlTaXplQml0cyIsIlJzYVByb3ZpZGVyIiwiaGFzaCIsInB1YmxpY0V4cG9uZW50IiwibW9kdWx1c0xlbmd0aCIsIlJzYVNzYVByb3ZpZGVyIiwiUnNhUHNzUHJvdmlkZXIiLCJzYWx0TGVuZ3RoIiwiUmFuZ2VFcnJvciIsIlJzYU9hZXBQcm92aWRlciIsImxhYmVsIiwiRWxsaXB0aWNQcm92aWRlciIsImNoZWNrTmFtZWRDdXJ2ZSIsIm5hbWVkQ3VydmUiLCJuYW1lZEN1cnZlcyIsIkVjZHNhUHJvdmlkZXIiLCJLRVlfVFlQRVMiLCJDcnlwdG9LZXkiLCJ0eXBlIiwiaXNLZXlUeXBlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJFY2RoUHJvdmlkZXIiLCJwdWJsaWMiLCJFY2RoRXNQcm92aWRlciIsIkVkRHNhUHJvdmlkZXIiLCJPYmplY3RJZGVudGlmaWVyIiwidmFsdWUiLCJfX2RlY29yYXRlIiwiQXNuUHJvcCIsIkFzblByb3BUeXBlcyIsInByb3RvdHlwZSIsIkFzblR5cGUiLCJBc25UeXBlVHlwZXMiLCJDaG9pY2UiLCJBbGdvcml0aG1JZGVudGlmaWVyIiwicGFyYW1zIiwiYXNzaWduIiwiQW55Iiwib3B0aW9uYWwiLCJQcml2YXRlS2V5SW5mbyIsInZlcnNpb24iLCJwcml2YXRlS2V5QWxnb3JpdGhtIiwiSW50ZWdlciIsIk9jdGV0U3RyaW5nIiwiUHVibGljS2V5SW5mbyIsInB1YmxpY0tleUFsZ29yaXRobSIsIkJpdFN0cmluZyIsIkpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciIsImZyb21KU09OIiwiRnJvbUJhc2U2NFVybCIsInRvSlNPTiIsIlRvQmFzZTY0VXJsIiwiQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIiwiZnJvbUFTTiIsInZhbHVlSGV4IiwidmFsdWVCbG9jayIsInRvQVNOIiwiY29tYmluZSIsImluZGV4JDMiLCJfX3Byb3RvX18iLCJSc2FQcml2YXRlS2V5IiwibW9kdWx1cyIsInByaXZhdGVFeHBvbmVudCIsInByaW1lMSIsInByaW1lMiIsImV4cG9uZW50MSIsImV4cG9uZW50MiIsImNvZWZmaWNpZW50IiwiY29udmVydGVyIiwiQXNuSW50ZWdlckNvbnZlcnRlciIsIkpzb25Qcm9wIiwiUnNhUHVibGljS2V5IiwiRWNQdWJsaWNLZXkiLCJzaXplIiwianNvbiIsIngiLCJ5IiwiRWNQcml2YXRlS2V5IiwiYXNuIiwiQXNuU2VyaWFsaXplciIsImp3ayIsImNvbnRleHQiLCJBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIiLCJuZXdWYWx1ZSIsInNldCIsImluZGV4JDIiLCJFY1V0aWxzIiwiZGVjb2RlUG9pbnQiLCJwb2ludFNpemUiLCJ2aWV3IiwiTWF0aCIsImNlaWwiLCJ4YiIsInliIiwiZW5jb2RlUG9pbnQiLCJwb2ludCIsImdldFNpemUiLCJlbmNvZGVTaWduYXR1cmUiLCJzaWduYXR1cmUiLCJyIiwicyIsInBhZFN0YXJ0IiwiZGVjb2RlU2lnbmF0dXJlIiwidHJpbVN0YXJ0IiwiaSIsIkVjRHNhU2lnbmF0dXJlIiwiZnJvbVdlYkNyeXB0b1NpZ25hdHVyZSIsImVjU2lnbmF0dXJlIiwidG9XZWJDcnlwdG9TaWduYXR1cmUiLCJtYXgiLCJPbmVBc3ltbWV0cmljS2V5IiwiaW1wbGljaXQiLCJFZFByaXZhdGVLZXkiLCJFZFB1YmxpY0tleSIsIkN1cnZlUHJpdmF0ZUtleSIsIkpzb25Qcm9wVHlwZXMiLCJTdHJpbmciLCJpZFNlY3AyNTZyMSIsImlkRWxsaXB0aWNDdXJ2ZSIsImlkU2VjcDM4NHIxIiwiaWRTZWNwNTIxcjEiLCJpZFNlY3AyNTZrMSIsImlkVmVyc2lvbk9uZSIsImlkQnJhaW5wb29sUDE2MHIxIiwiaWRCcmFpbnBvb2xQMTYwdDEiLCJpZEJyYWlucG9vbFAxOTJyMSIsImlkQnJhaW5wb29sUDE5MnQxIiwiaWRCcmFpbnBvb2xQMjI0cjEiLCJpZEJyYWlucG9vbFAyMjR0MSIsImlkQnJhaW5wb29sUDI1NnIxIiwiaWRCcmFpbnBvb2xQMjU2dDEiLCJpZEJyYWlucG9vbFAzMjByMSIsImlkQnJhaW5wb29sUDMyMHQxIiwiaWRCcmFpbnBvb2xQMzg0cjEiLCJpZEJyYWlucG9vbFAzODR0MSIsImlkQnJhaW5wb29sUDUxMnIxIiwiaWRCcmFpbnBvb2xQNTEydDEiLCJpZFgyNTUxOSIsImlkWDQ0OCIsImlkRWQyNTUxOSIsImlkRWQ0NDgiLCJpbmRleCQxIiwiY29udmVydGVycyIsIkVjQ3VydmVzIiwicmVnaXN0ZXIiLCJvaWQiLCJpZCIsInJhdyIsIkFzbkNvbnZlcnQiLCJzZXJpYWxpemUiLCJpdGVtcyIsIm5hbWVzIiwiZmluZCIsIm5hbWVPcklkIiwiSG1hY1Byb3ZpZGVyIiwiZ2V0RGVmYXVsdExlbmd0aCIsImFsZ05hbWUiLCJQYmtkZjJQcm92aWRlciIsInNhbHQiLCJpdGVyYXRpb25zIiwiU3ludGF4RXJyb3IiLCJIa2RmUHJvdmlkZXIiLCJpbmZvIiwiU2hha2VQcm92aWRlciIsImRlZmF1bHRMZW5ndGgiLCJTaGFrZTEyOFByb3ZpZGVyIiwiU2hha2UyNTZQcm92aWRlciIsIkNyeXB0byIsInJhbmRvbVVVSUQiLCJiIiwiZ2V0UmFuZG9tVmFsdWVzIiwidXVpZCIsIlRvSGV4Iiwic3Vic3RyaW5nIiwiUHJvdmlkZXJTdG9yYWdlIiwiYWxnb3JpdGhtTmFtZSIsInByb3ZpZGVyIiwicmVtb3ZlQXQiLCJoYXMiLCJhbGdvcml0aG1zIiwic29ydCIsIlN1YnRsZUNyeXB0byIsInByb3ZpZGVycyIsImlzSGFzaGVkQWxnb3JpdGhtIiwiY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyIsInByZXBhcmVkQWxnb3JpdGhtIiwicHJlcGFyZUFsZ29yaXRobSIsInByZXBhcmVkRGF0YSIsImdldFByb3ZpZGVyIiwicmVzdWx0IiwicHJlcGFyZWRTaWduYXR1cmUiLCJkZXJpdmVLZXkiLCJkZXJpdmVkS2V5VHlwZSIsInByZXBhcmVkRGVyaXZlZEtleVR5cGUiLCJpbXBvcnRQcm92aWRlciIsImRlcml2ZWRCaXRzIiwia3R5Iiwid3JhcEtleSIsIndyYXBwaW5nS2V5Iiwid3JhcEFsZ29yaXRobSIsIkpTT04iLCJzdHJpbmdpZnkiLCJGcm9tVXRmOFN0cmluZyIsInVud3JhcEtleSIsIndyYXBwZWRLZXkiLCJ1bndyYXBwaW5nS2V5IiwidW53cmFwQWxnb3JpdGhtIiwidW53cmFwcGVkS2V5QWxnb3JpdGhtIiwicGFyc2UiLCJUb1V0ZjhTdHJpbmciLCJlcnJvciIsImludGVybmFsIiwiaW5kZXgiLCJSRVFVSVJFRF9GSUVMRFMiLCJKd2tVdGlscyIsInRodW1icHJpbnQiLCJjcnlwdG8iLCJzdWJ0bGUiLCJGcm9tQmluYXJ5IiwicmVtb3ZlIiwiZW50cmllcyIsImZpbHRlciIsIm8iLCJpbmNsdWRlcyIsImtleUEiLCJrZXlCIiwiZnJvbUVudHJpZXMiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/webcrypto-core/build/webcrypto-core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/webcrypto-core/build/webcrypto-core.js":
/*!*************************************************************!*\
  !*** ./node_modules/webcrypto-core/build/webcrypto-core.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\n\n\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(ssr)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(ssr)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(ssr)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar asn1 = __webpack_require__(/*! asn1js */ \"(ssr)/./node_modules/asn1js/build/index.js\");\n\nfunction _interopNamespaceDefault(e) {\n  var n = Object.create(null);\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () { return e[k]; }\n        });\n      }\n    });\n  }\n  n.default = e;\n  return Object.freeze(n);\n}\n\nvar asn1__namespace = /*#__PURE__*/_interopNamespaceDefault(asn1);\n\nclass CryptoError extends Error {\n}\n\nclass AlgorithmError extends CryptoError {\n}\n\nclass UnsupportedOperationError extends CryptoError {\n    constructor(methodName) {\n        super(`Unsupported operation: ${methodName ? `${methodName}` : \"\"}`);\n    }\n}\n\nclass OperationError extends CryptoError {\n}\n\nclass RequiredPropertyError extends CryptoError {\n    constructor(propName) {\n        super(`${propName}: Missing required property`);\n    }\n}\n\nclass PemConverter {\n    static toArrayBuffer(pem) {\n        const base64 = pem\n            .replace(/-{5}(BEGIN|END) .*-{5}/g, \"\")\n            .replace(\"\\r\", \"\")\n            .replace(\"\\n\", \"\");\n        return pvtsutils.Convert.FromBase64(base64);\n    }\n    static toUint8Array(pem) {\n        const bytes = this.toArrayBuffer(pem);\n        return new Uint8Array(bytes);\n    }\n    static fromBufferSource(buffer, tag) {\n        const base64 = pvtsutils.Convert.ToBase64(buffer);\n        let sliced;\n        let offset = 0;\n        const rows = [];\n        while (offset < base64.length) {\n            sliced = base64.slice(offset, offset + 64);\n            if (sliced.length) {\n                rows.push(sliced);\n            }\n            else {\n                break;\n            }\n            offset += 64;\n        }\n        const upperCaseTag = tag.toUpperCase();\n        return `-----BEGIN ${upperCaseTag}-----\\n${rows.join(\"\\n\")}\\n-----END ${upperCaseTag}-----`;\n    }\n    static isPEM(data) {\n        return /-----BEGIN .+-----[A-Za-z0-9+/+=\\s\\n]+-----END .+-----/i.test(data);\n    }\n    static getTagName(pem) {\n        if (!this.isPEM(pem)) {\n            throw new Error(\"Bad parameter. Incoming data is not right PEM\");\n        }\n        const res = /-----BEGIN (.+)-----/.exec(pem);\n        if (!res) {\n            throw new Error(\"Cannot get tag from PEM\");\n        }\n        return res[1];\n    }\n    static hasTagName(pem, tagName) {\n        const tag = this.getTagName(pem);\n        return tagName.toLowerCase() === tag.toLowerCase();\n    }\n    static isCertificate(pem) {\n        return this.hasTagName(pem, \"certificate\");\n    }\n    static isCertificateRequest(pem) {\n        return this.hasTagName(pem, \"certificate request\");\n    }\n    static isCRL(pem) {\n        return this.hasTagName(pem, \"x509 crl\");\n    }\n    static isPublicKey(pem) {\n        return this.hasTagName(pem, \"public key\");\n    }\n}\n\nfunction isJWK(data) {\n    return typeof data === \"object\" && \"kty\" in data;\n}\n\nclass ProviderCrypto {\n    async digest(...args) {\n        this.checkDigest.apply(this, args);\n        return this.onDigest.apply(this, args);\n    }\n    checkDigest(algorithm, _data) {\n        this.checkAlgorithmName(algorithm);\n    }\n    async onDigest(_algorithm, _data) {\n        throw new UnsupportedOperationError(\"digest\");\n    }\n    async generateKey(...args) {\n        this.checkGenerateKey.apply(this, args);\n        return this.onGenerateKey.apply(this, args);\n    }\n    checkGenerateKey(algorithm, _extractable, keyUsages, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkGenerateKeyParams(algorithm);\n        if (!(keyUsages && keyUsages.length)) {\n            throw new TypeError(`Usages cannot be empty when creating a key.`);\n        }\n        let allowedUsages;\n        if (Array.isArray(this.usages)) {\n            allowedUsages = this.usages;\n        }\n        else {\n            allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n        }\n        this.checkKeyUsages(keyUsages, allowedUsages);\n    }\n    checkGenerateKeyParams(_algorithm) {\n    }\n    async onGenerateKey(_algorithm, _extractable, _keyUsages, ..._args) {\n        throw new UnsupportedOperationError(\"generateKey\");\n    }\n    async sign(...args) {\n        this.checkSign.apply(this, args);\n        return this.onSign.apply(this, args);\n    }\n    checkSign(algorithm, key, _data, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"sign\");\n    }\n    async onSign(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"sign\");\n    }\n    async verify(...args) {\n        this.checkVerify.apply(this, args);\n        return this.onVerify.apply(this, args);\n    }\n    checkVerify(algorithm, key, _signature, _data, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, \"verify\");\n    }\n    async onVerify(_algorithm, _key, _signature, _data, ..._args) {\n        throw new UnsupportedOperationError(\"verify\");\n    }\n    async encrypt(...args) {\n        this.checkEncrypt.apply(this, args);\n        return this.onEncrypt.apply(this, args);\n    }\n    checkEncrypt(algorithm, key, _data, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"encrypt\" : void 0);\n    }\n    async onEncrypt(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"encrypt\");\n    }\n    async decrypt(...args) {\n        this.checkDecrypt.apply(this, args);\n        return this.onDecrypt.apply(this, args);\n    }\n    checkDecrypt(algorithm, key, _data, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(key, options.keyUsage ? \"decrypt\" : void 0);\n    }\n    async onDecrypt(_algorithm, _key, _data, ..._args) {\n        throw new UnsupportedOperationError(\"decrypt\");\n    }\n    async deriveBits(...args) {\n        this.checkDeriveBits.apply(this, args);\n        return this.onDeriveBits.apply(this, args);\n    }\n    checkDeriveBits(algorithm, baseKey, length, options = {}, ..._args) {\n        this.checkAlgorithmName(algorithm);\n        this.checkAlgorithmParams(algorithm);\n        this.checkCryptoKey(baseKey, options.keyUsage ? \"deriveBits\" : void 0);\n        if (length % 8 !== 0) {\n            throw new OperationError(\"length: Is not multiple of 8\");\n        }\n    }\n    async onDeriveBits(_algorithm, _baseKey, _length, ..._args) {\n        throw new UnsupportedOperationError(\"deriveBits\");\n    }\n    async exportKey(...args) {\n        this.checkExportKey.apply(this, args);\n        return this.onExportKey.apply(this, args);\n    }\n    checkExportKey(format, key, ..._args) {\n        this.checkKeyFormat(format);\n        this.checkCryptoKey(key);\n        if (!key.extractable) {\n            throw new CryptoError(\"key: Is not extractable\");\n        }\n    }\n    async onExportKey(_format, _key, ..._args) {\n        throw new UnsupportedOperationError(\"exportKey\");\n    }\n    async importKey(...args) {\n        this.checkImportKey.apply(this, args);\n        return this.onImportKey.apply(this, args);\n    }\n    checkImportKey(format, keyData, algorithm, _extractable, keyUsages, ..._args) {\n        this.checkKeyFormat(format);\n        this.checkKeyData(format, keyData);\n        this.checkAlgorithmName(algorithm);\n        this.checkImportParams(algorithm);\n        if (Array.isArray(this.usages)) {\n            this.checkKeyUsages(keyUsages, this.usages);\n        }\n    }\n    async onImportKey(_format, _keyData, _algorithm, _extractable, _keyUsages, ..._args) {\n        throw new UnsupportedOperationError(\"importKey\");\n    }\n    checkAlgorithmName(algorithm) {\n        if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n    }\n    checkAlgorithmParams(_algorithm) {\n    }\n    checkDerivedKeyParams(_algorithm) {\n    }\n    checkKeyUsages(usages, allowed) {\n        for (const usage of usages) {\n            if (allowed.indexOf(usage) === -1) {\n                throw new TypeError(\"Cannot create a key using the specified key usages\");\n            }\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        this.checkAlgorithmName(key.algorithm);\n        if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n            throw new CryptoError(`key does not match that of operation`);\n        }\n    }\n    checkRequiredProperty(data, propName) {\n        if (!(propName in data)) {\n            throw new RequiredPropertyError(propName);\n        }\n    }\n    checkHashAlgorithm(algorithm, hashAlgorithms) {\n        for (const item of hashAlgorithms) {\n            if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(\", \")}`);\n    }\n    checkImportParams(_algorithm) {\n    }\n    checkKeyFormat(format) {\n        switch (format) {\n            case \"raw\":\n            case \"pkcs8\":\n            case \"spki\":\n            case \"jwk\":\n                break;\n            default:\n                throw new TypeError(\"format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'\");\n        }\n    }\n    checkKeyData(format, keyData) {\n        if (!keyData) {\n            throw new TypeError(\"keyData: Cannot be empty on empty on key importing\");\n        }\n        if (format === \"jwk\") {\n            if (!isJWK(keyData)) {\n                throw new TypeError(\"keyData: Is not JsonWebToken\");\n            }\n        }\n        else if (!pvtsutils.BufferSourceConverter.isBufferSource(keyData)) {\n            throw new TypeError(\"keyData: Is not ArrayBufferView or ArrayBuffer\");\n        }\n    }\n    prepareData(data) {\n        return pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n    }\n}\n\nclass AesProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        switch (algorithm.length) {\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new TypeError(\"length: Must be 128, 192, or 256\");\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\n\nclass AesCbcProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CBC\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n    }\n}\n\nclass AesCmacProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CMAC\";\n        this.usages = [\"sign\", \"verify\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\n\nclass AesCtrProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-CTR\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"counter\");\n        if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n            throw new TypeError(\"counter: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.counter.byteLength !== 16) {\n            throw new TypeError(\"iv: Must have length 16 bytes\");\n        }\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (algorithm.length < 1) {\n            throw new OperationError(\"length: Must be more than 0\");\n        }\n    }\n}\n\nclass AesEcbProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-ECB\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n}\n\nclass AesGcmProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-GCM\";\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"iv\");\n        if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n            throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        if (algorithm.iv.byteLength < 1) {\n            throw new OperationError(\"iv: Must have length more than 0 and less than 2^64 - 1\");\n        }\n        if (!(\"tagLength\" in algorithm)) {\n            algorithm.tagLength = 128;\n        }\n        switch (algorithm.tagLength) {\n            case 32:\n            case 64:\n            case 96:\n            case 104:\n            case 112:\n            case 120:\n            case 128:\n                break;\n            default:\n                throw new OperationError(\"tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128\");\n        }\n    }\n}\n\nclass AesKwProvider extends AesProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"AES-KW\";\n        this.usages = [\"wrapKey\", \"unwrapKey\"];\n    }\n}\n\nclass DesProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.usages = [\"encrypt\", \"decrypt\", \"wrapKey\", \"unwrapKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        if (this.ivSize) {\n            this.checkRequiredProperty(algorithm, \"iv\");\n            if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n                throw new TypeError(\"iv: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n            }\n            if (algorithm.iv.byteLength !== this.ivSize) {\n                throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n            }\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"length\");\n        if (typeof algorithm.length !== \"number\") {\n            throw new TypeError(\"length: Is not of type Number\");\n        }\n        if (algorithm.length !== this.keySizeBits) {\n            throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n        }\n    }\n    checkDerivedKeyParams(algorithm) {\n        this.checkGenerateKeyParams(algorithm);\n    }\n}\n\nclass RsaProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        if (algorithm.modulusLength % 8\n            || algorithm.modulusLength < 256\n            || algorithm.modulusLength > 16384) {\n            throw new TypeError(\"The modulus length must be a multiple of 8 bits and >= 256 and <= 16384\");\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nclass RsaSsaProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSASSA-PKCS1-v1_5\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n    }\n}\n\nclass RsaPssProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSA-PSS\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"saltLength\");\n        if (typeof algorithm.saltLength !== \"number\") {\n            throw new TypeError(\"saltLength: Is not a Number\");\n        }\n        if (algorithm.saltLength < 0) {\n            throw new RangeError(\"saltLength: Must be positive number\");\n        }\n    }\n}\n\nclass RsaOaepProvider extends RsaProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSA-OAEP\";\n        this.usages = {\n            privateKey: [\"decrypt\", \"unwrapKey\"],\n            publicKey: [\"encrypt\", \"wrapKey\"],\n        };\n    }\n    checkAlgorithmParams(algorithm) {\n        if (algorithm.label\n            && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n            throw new TypeError(\"label: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n}\n\nclass EllipticProvider extends ProviderCrypto {\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"namedCurve\");\n        this.checkNamedCurve(algorithm.namedCurve);\n    }\n    checkNamedCurve(namedCurve) {\n        for (const item of this.namedCurves) {\n            if (item.toLowerCase() === namedCurve.toLowerCase()) {\n                return;\n            }\n        }\n        throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(\", \")}`);\n    }\n}\n\nclass EcdsaProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDSA\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n        this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nconst KEY_TYPES = [\"secret\", \"private\", \"public\"];\nclass CryptoKey {\n    static create(algorithm, type, extractable, usages) {\n        const key = new this();\n        key.algorithm = algorithm;\n        key.type = type;\n        key.extractable = extractable;\n        key.usages = usages;\n        return key;\n    }\n    static isKeyType(data) {\n        return KEY_TYPES.indexOf(data) !== -1;\n    }\n    get [Symbol.toStringTag]() {\n        return \"CryptoKey\";\n    }\n}\n\nclass EcdhProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDH\";\n        this.usages = {\n            privateKey: [\"deriveBits\", \"deriveKey\"],\n            publicKey: [],\n        };\n        this.namedCurves = [\"P-256\", \"P-384\", \"P-521\", \"K-256\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"public\");\n        if (!(algorithm.public instanceof CryptoKey)) {\n            throw new TypeError(\"public: Is not a CryptoKey\");\n        }\n        if (algorithm.public.type !== \"public\") {\n            throw new OperationError(\"public: Is not a public key\");\n        }\n        if (algorithm.public.algorithm.name !== this.name) {\n            throw new OperationError(`public: Is not ${this.name} key`);\n        }\n    }\n}\n\nclass EcdhEsProvider extends EcdhProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"ECDH-ES\";\n        this.namedCurves = [\"X25519\", \"X448\"];\n    }\n}\n\nclass EdDsaProvider extends EllipticProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"EdDSA\";\n        this.usages = {\n            privateKey: [\"sign\"],\n            publicKey: [\"verify\"],\n        };\n        this.namedCurves = [\"Ed25519\", \"Ed448\"];\n    }\n}\n\nlet ObjectIdentifier = class ObjectIdentifier {\n    constructor(value) {\n        if (value) {\n            this.value = value;\n        }\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.ObjectIdentifier })\n], ObjectIdentifier.prototype, \"value\", void 0);\nObjectIdentifier = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], ObjectIdentifier);\n\nclass AlgorithmIdentifier {\n    constructor(params) {\n        Object.assign(this, params);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.ObjectIdentifier,\n    })\n], AlgorithmIdentifier.prototype, \"algorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({\n        type: asn1Schema.AsnPropTypes.Any,\n        optional: true,\n    })\n], AlgorithmIdentifier.prototype, \"parameters\", void 0);\n\nclass PrivateKeyInfo {\n    constructor() {\n        this.version = 0;\n        this.privateKeyAlgorithm = new AlgorithmIdentifier();\n        this.privateKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer })\n], PrivateKeyInfo.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: AlgorithmIdentifier })\n], PrivateKeyInfo.prototype, \"privateKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], PrivateKeyInfo.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })\n], PrivateKeyInfo.prototype, \"attributes\", void 0);\n\nclass PublicKeyInfo {\n    constructor() {\n        this.publicKeyAlgorithm = new AlgorithmIdentifier();\n        this.publicKey = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: AlgorithmIdentifier })\n], PublicKeyInfo.prototype, \"publicKeyAlgorithm\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })\n], PublicKeyInfo.prototype, \"publicKey\", void 0);\n\nconst JsonBase64UrlArrayBufferConverter = {\n    fromJSON: (value) => pvtsutils.Convert.FromBase64Url(value),\n    toJSON: (value) => pvtsutils.Convert.ToBase64Url(new Uint8Array(value)),\n};\n\nconst AsnIntegerArrayBufferConverter = {\n    fromASN: (value) => {\n        const valueHex = value.valueBlock.valueHex;\n        return !(new Uint8Array(valueHex)[0])\n            ? value.valueBlock.valueHex.slice(1)\n            : value.valueBlock.valueHex;\n    },\n    toASN: (value) => {\n        const valueHex = new Uint8Array(value)[0] > 127\n            ? pvtsutils.combine(new Uint8Array([0]).buffer, value)\n            : value;\n        return new asn1__namespace.Integer({ valueHex });\n    },\n};\n\nvar index$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AsnIntegerArrayBufferConverter: AsnIntegerArrayBufferConverter,\n  JsonBase64UrlArrayBufferConverter: JsonBase64UrlArrayBufferConverter\n});\n\nclass RsaPrivateKey {\n    constructor() {\n        this.version = 0;\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n        this.privateExponent = new ArrayBuffer(0);\n        this.prime1 = new ArrayBuffer(0);\n        this.prime2 = new ArrayBuffer(0);\n        this.exponent1 = new ArrayBuffer(0);\n        this.exponent2 = new ArrayBuffer(0);\n        this.coefficient = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })\n], RsaPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"n\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"e\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"publicExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"d\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"privateExponent\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"p\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"prime1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"q\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"prime2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"dp\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"exponent1\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"dq\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"exponent2\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"qi\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, \"coefficient\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Any, optional: true })\n], RsaPrivateKey.prototype, \"otherPrimeInfos\", void 0);\n\nclass RsaPublicKey {\n    constructor() {\n        this.modulus = new ArrayBuffer(0);\n        this.publicExponent = new ArrayBuffer(0);\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"n\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, \"modulus\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n    jsonSchema.JsonProp({ name: \"e\", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, \"publicExponent\", void 0);\n\nlet EcPublicKey = class EcPublicKey {\n    constructor(value) {\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        let bytes = new Uint8Array(this.value);\n        if (bytes[0] !== 0x04) {\n            throw new CryptoError(\"Wrong ECPoint. Current version supports only Uncompressed (0x04) point\");\n        }\n        bytes = new Uint8Array(this.value.slice(1));\n        const size = bytes.length / 2;\n        const offset = 0;\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n            y: pvtsutils.Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size)),\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        if (!(\"y\" in json)) {\n            throw new Error(\"y: Missing required property\");\n        }\n        const x = pvtsutils.Convert.FromBase64Url(json.x);\n        const y = pvtsutils.Convert.FromBase64Url(json.y);\n        const value = pvtsutils.combine(new Uint8Array([0x04]).buffer, x, y);\n        this.value = new Uint8Array(value).buffer;\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EcPublicKey.prototype, \"value\", void 0);\nEcPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EcPublicKey);\n\nclass EcPrivateKey {\n    constructor() {\n        this.version = 1;\n        this.privateKey = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!(\"d\" in json)) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.privateKey = pvtsutils.Convert.FromBase64Url(json.d);\n        if (\"x\" in json) {\n            const publicKey = new EcPublicKey();\n            publicKey.fromJSON(json);\n            const asn = asn1Schema.AsnSerializer.toASN(publicKey);\n            if (\"valueHex\" in asn.valueBlock) {\n                this.publicKey = asn.valueBlock.valueHex;\n            }\n        }\n        return this;\n    }\n    toJSON() {\n        const jwk = {};\n        jwk.d = pvtsutils.Convert.ToBase64Url(this.privateKey);\n        if (this.publicKey) {\n            Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n        }\n        return jwk;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: asn1Schema.AsnIntegerConverter })\n], EcPrivateKey.prototype, \"version\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EcPrivateKey.prototype, \"privateKey\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 0, type: asn1Schema.AsnPropTypes.Any, optional: true })\n], EcPrivateKey.prototype, \"parameters\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 1, type: asn1Schema.AsnPropTypes.BitString, optional: true })\n], EcPrivateKey.prototype, \"publicKey\", void 0);\n\nconst AsnIntegerWithoutPaddingConverter = {\n    fromASN: (value) => {\n        const bytes = new Uint8Array(value.valueBlock.valueHex);\n        return (bytes[0] === 0)\n            ? bytes.buffer.slice(1)\n            : bytes.buffer;\n    },\n    toASN: (value) => {\n        const bytes = new Uint8Array(value);\n        if (bytes[0] > 127) {\n            const newValue = new Uint8Array(bytes.length + 1);\n            newValue.set(bytes, 1);\n            return new asn1__namespace.Integer({ valueHex: newValue.buffer });\n        }\n        return new asn1__namespace.Integer({ valueHex: value });\n    },\n};\n\nvar index$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AsnIntegerWithoutPaddingConverter: AsnIntegerWithoutPaddingConverter\n});\n\nclass EcUtils {\n    static decodePoint(data, pointSize) {\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if ((view.length === 0) || (view[0] !== 4)) {\n            throw new Error(\"Only uncompressed point format supported\");\n        }\n        const n = (view.length - 1) / 2;\n        if (n !== (Math.ceil(pointSize / 8))) {\n            throw new Error(\"Point does not match field size\");\n        }\n        const xb = view.slice(1, n + 1);\n        const yb = view.slice(n + 1, n + 1 + n);\n        return { x: xb, y: yb };\n    }\n    static encodePoint(point, pointSize) {\n        const size = Math.ceil(pointSize / 8);\n        if (point.x.byteLength !== size || point.y.byteLength !== size) {\n            throw new Error(\"X,Y coordinates don't match point size criteria\");\n        }\n        const x = pvtsutils.BufferSourceConverter.toUint8Array(point.x);\n        const y = pvtsutils.BufferSourceConverter.toUint8Array(point.y);\n        const res = new Uint8Array(size * 2 + 1);\n        res[0] = 4;\n        res.set(x, 1);\n        res.set(y, size + 1);\n        return res;\n    }\n    static getSize(pointSize) {\n        return Math.ceil(pointSize / 8);\n    }\n    static encodeSignature(signature, pointSize) {\n        const size = this.getSize(pointSize);\n        const r = pvtsutils.BufferSourceConverter.toUint8Array(signature.r);\n        const s = pvtsutils.BufferSourceConverter.toUint8Array(signature.s);\n        const res = new Uint8Array(size * 2);\n        res.set(this.padStart(r, size));\n        res.set(this.padStart(s, size), size);\n        return res;\n    }\n    static decodeSignature(data, pointSize) {\n        const size = this.getSize(pointSize);\n        const view = pvtsutils.BufferSourceConverter.toUint8Array(data);\n        if (view.length !== (size * 2)) {\n            throw new Error(\"Incorrect size of the signature\");\n        }\n        const r = view.slice(0, size);\n        const s = view.slice(size);\n        return {\n            r: this.trimStart(r),\n            s: this.trimStart(s),\n        };\n    }\n    static trimStart(data) {\n        let i = 0;\n        while ((i < data.length - 1) && (data[i] === 0)) {\n            i++;\n        }\n        if (i === 0) {\n            return data;\n        }\n        return data.slice(i, data.length);\n    }\n    static padStart(data, size) {\n        if (size === data.length) {\n            return data;\n        }\n        const res = new Uint8Array(size);\n        res.set(data, size - data.length);\n        return res;\n    }\n}\n\nclass EcDsaSignature {\n    constructor() {\n        this.r = new ArrayBuffer(0);\n        this.s = new ArrayBuffer(0);\n    }\n    static fromWebCryptoSignature(value) {\n        const pointSize = value.byteLength / 2;\n        const point = EcUtils.decodeSignature(value, pointSize * 8);\n        const ecSignature = new EcDsaSignature();\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(point.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(point.s);\n        return ecSignature;\n    }\n    toWebCryptoSignature(pointSize) {\n        pointSize !== null && pointSize !== void 0 ? pointSize : (pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8);\n        const signature = EcUtils.encodeSignature(this, pointSize);\n        return signature.buffer;\n    }\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, \"r\", void 0);\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, \"s\", void 0);\n\nclass OneAsymmetricKey extends PrivateKeyInfo {\n}\ntslib.__decorate([\n    asn1Schema.AsnProp({ context: 1, implicit: true, type: asn1Schema.AsnPropTypes.BitString, optional: true })\n], OneAsymmetricKey.prototype, \"publicKey\", void 0);\n\nlet EdPrivateKey = class EdPrivateKey {\n    constructor() {\n        this.value = new ArrayBuffer(0);\n    }\n    fromJSON(json) {\n        if (!json.d) {\n            throw new Error(\"d: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.d);\n        return this;\n    }\n    toJSON() {\n        const jwk = {\n            d: pvtsutils.Convert.ToBase64Url(this.value),\n        };\n        return jwk;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString })\n], EdPrivateKey.prototype, \"value\", void 0);\nEdPrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EdPrivateKey);\n\nlet EdPublicKey = class EdPublicKey {\n    constructor(value) {\n        this.value = new ArrayBuffer(0);\n        if (value) {\n            this.value = value;\n        }\n    }\n    toJSON() {\n        const json = {\n            x: pvtsutils.Convert.ToBase64Url(this.value),\n        };\n        return json;\n    }\n    fromJSON(json) {\n        if (!(\"x\" in json)) {\n            throw new Error(\"x: Missing required property\");\n        }\n        this.value = pvtsutils.Convert.FromBase64Url(json.x);\n        return this;\n    }\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.BitString })\n], EdPublicKey.prototype, \"value\", void 0);\nEdPublicKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], EdPublicKey);\n\nlet CurvePrivateKey = class CurvePrivateKey {\n};\ntslib.__decorate([\n    asn1Schema.AsnProp({ type: asn1Schema.AsnPropTypes.OctetString }),\n    jsonSchema.JsonProp({ type: jsonSchema.JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })\n], CurvePrivateKey.prototype, \"d\", void 0);\nCurvePrivateKey = tslib.__decorate([\n    asn1Schema.AsnType({ type: asn1Schema.AsnTypeTypes.Choice })\n], CurvePrivateKey);\n\nconst idSecp256r1 = \"1.2.840.10045.3.1.7\";\nconst idEllipticCurve = \"1.3.132.0\";\nconst idSecp384r1 = `${idEllipticCurve}.34`;\nconst idSecp521r1 = `${idEllipticCurve}.35`;\nconst idSecp256k1 = `${idEllipticCurve}.10`;\nconst idVersionOne = \"1.3.36.3.3.2.8.1.1\";\nconst idBrainpoolP160r1 = `${idVersionOne}.1`;\nconst idBrainpoolP160t1 = `${idVersionOne}.2`;\nconst idBrainpoolP192r1 = `${idVersionOne}.3`;\nconst idBrainpoolP192t1 = `${idVersionOne}.4`;\nconst idBrainpoolP224r1 = `${idVersionOne}.5`;\nconst idBrainpoolP224t1 = `${idVersionOne}.6`;\nconst idBrainpoolP256r1 = `${idVersionOne}.7`;\nconst idBrainpoolP256t1 = `${idVersionOne}.8`;\nconst idBrainpoolP320r1 = `${idVersionOne}.9`;\nconst idBrainpoolP320t1 = `${idVersionOne}.10`;\nconst idBrainpoolP384r1 = `${idVersionOne}.11`;\nconst idBrainpoolP384t1 = `${idVersionOne}.12`;\nconst idBrainpoolP512r1 = `${idVersionOne}.13`;\nconst idBrainpoolP512t1 = `${idVersionOne}.14`;\nconst idX25519 = \"1.3.101.110\";\nconst idX448 = \"1.3.101.111\";\nconst idEd25519 = \"1.3.101.112\";\nconst idEd448 = \"1.3.101.113\";\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AlgorithmIdentifier: AlgorithmIdentifier,\n  get CurvePrivateKey () { return CurvePrivateKey; },\n  EcDsaSignature: EcDsaSignature,\n  EcPrivateKey: EcPrivateKey,\n  get EcPublicKey () { return EcPublicKey; },\n  get EdPrivateKey () { return EdPrivateKey; },\n  get EdPublicKey () { return EdPublicKey; },\n  get ObjectIdentifier () { return ObjectIdentifier; },\n  OneAsymmetricKey: OneAsymmetricKey,\n  PrivateKeyInfo: PrivateKeyInfo,\n  PublicKeyInfo: PublicKeyInfo,\n  RsaPrivateKey: RsaPrivateKey,\n  RsaPublicKey: RsaPublicKey,\n  converters: index$2,\n  idBrainpoolP160r1: idBrainpoolP160r1,\n  idBrainpoolP160t1: idBrainpoolP160t1,\n  idBrainpoolP192r1: idBrainpoolP192r1,\n  idBrainpoolP192t1: idBrainpoolP192t1,\n  idBrainpoolP224r1: idBrainpoolP224r1,\n  idBrainpoolP224t1: idBrainpoolP224t1,\n  idBrainpoolP256r1: idBrainpoolP256r1,\n  idBrainpoolP256t1: idBrainpoolP256t1,\n  idBrainpoolP320r1: idBrainpoolP320r1,\n  idBrainpoolP320t1: idBrainpoolP320t1,\n  idBrainpoolP384r1: idBrainpoolP384r1,\n  idBrainpoolP384t1: idBrainpoolP384t1,\n  idBrainpoolP512r1: idBrainpoolP512r1,\n  idBrainpoolP512t1: idBrainpoolP512t1,\n  idEd25519: idEd25519,\n  idEd448: idEd448,\n  idEllipticCurve: idEllipticCurve,\n  idSecp256k1: idSecp256k1,\n  idSecp256r1: idSecp256r1,\n  idSecp384r1: idSecp384r1,\n  idSecp521r1: idSecp521r1,\n  idVersionOne: idVersionOne,\n  idX25519: idX25519,\n  idX448: idX448\n});\n\nclass EcCurves {\n    constructor() { }\n    static register(item) {\n        const oid = new ObjectIdentifier();\n        oid.value = item.id;\n        const raw = asn1Schema.AsnConvert.serialize(oid);\n        this.items.push({\n            ...item,\n            raw,\n        });\n        this.names.push(item.name);\n    }\n    static find(nameOrId) {\n        nameOrId = nameOrId.toUpperCase();\n        for (const item of this.items) {\n            if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n                return item;\n            }\n        }\n        return null;\n    }\n    static get(nameOrId) {\n        const res = this.find(nameOrId);\n        if (!res) {\n            throw new Error(`Unsupported EC named curve '${nameOrId}'`);\n        }\n        return res;\n    }\n}\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({ name: \"P-256\", id: idSecp256r1, size: 256 });\nEcCurves.register({ name: \"P-384\", id: idSecp384r1, size: 384 });\nEcCurves.register({ name: \"P-521\", id: idSecp521r1, size: 521 });\nEcCurves.register({ name: \"K-256\", id: idSecp256k1, size: 256 });\nEcCurves.register({ name: \"brainpoolP160r1\", id: idBrainpoolP160r1, size: 160 });\nEcCurves.register({ name: \"brainpoolP160t1\", id: idBrainpoolP160t1, size: 160 });\nEcCurves.register({ name: \"brainpoolP192r1\", id: idBrainpoolP192r1, size: 192 });\nEcCurves.register({ name: \"brainpoolP192t1\", id: idBrainpoolP192t1, size: 192 });\nEcCurves.register({ name: \"brainpoolP224r1\", id: idBrainpoolP224r1, size: 224 });\nEcCurves.register({ name: \"brainpoolP224t1\", id: idBrainpoolP224t1, size: 224 });\nEcCurves.register({ name: \"brainpoolP256r1\", id: idBrainpoolP256r1, size: 256 });\nEcCurves.register({ name: \"brainpoolP256t1\", id: idBrainpoolP256t1, size: 256 });\nEcCurves.register({ name: \"brainpoolP320r1\", id: idBrainpoolP320r1, size: 320 });\nEcCurves.register({ name: \"brainpoolP320t1\", id: idBrainpoolP320t1, size: 320 });\nEcCurves.register({ name: \"brainpoolP384r1\", id: idBrainpoolP384r1, size: 384 });\nEcCurves.register({ name: \"brainpoolP384t1\", id: idBrainpoolP384t1, size: 384 });\nEcCurves.register({ name: \"brainpoolP512r1\", id: idBrainpoolP512r1, size: 512 });\nEcCurves.register({ name: \"brainpoolP512t1\", id: idBrainpoolP512t1, size: 512 });\n\nclass HmacProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"HMAC\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"sign\", \"verify\"];\n    }\n    getDefaultLength(algName) {\n        switch (algName.toUpperCase()) {\n            case \"SHA-1\":\n            case \"SHA-256\":\n            case \"SHA-384\":\n            case \"SHA-512\":\n                return 512;\n            default:\n                throw new Error(`Unknown algorithm name '${algName}'`);\n        }\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        if (\"length\" in algorithm) {\n            if (typeof algorithm.length !== \"number\") {\n                throw new TypeError(\"length: Is not a Number\");\n            }\n            if (algorithm.length < 1) {\n                throw new RangeError(\"length: Number is out of range\");\n            }\n        }\n    }\n    checkImportParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    }\n}\n\nclass Pbkdf2Provider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"PBKDF2\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"deriveBits\", \"deriveKey\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"iterations\");\n        if (typeof algorithm.iterations !== \"number\") {\n            throw new TypeError(\"iterations: Is not a Number\");\n        }\n        if (algorithm.iterations < 1) {\n            throw new TypeError(\"iterations: Is less than 1\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\n\nclass HkdfProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"HKDF\";\n        this.hashAlgorithms = [\"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\"];\n        this.usages = [\"deriveKey\", \"deriveBits\"];\n    }\n    checkAlgorithmParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"hash\");\n        this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n        this.checkRequiredProperty(algorithm, \"salt\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.salt)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n        this.checkRequiredProperty(algorithm, \"info\");\n        if (!pvtsutils.BufferSourceConverter.isBufferSource(algorithm.info)) {\n            throw new TypeError(\"salt: Is not of type '(ArrayBuffer or ArrayBufferView)'\");\n        }\n    }\n    checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n        super.checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args);\n        if (extractable) {\n            throw new SyntaxError(\"extractable: Must be 'false'\");\n        }\n    }\n}\n\nclass ShakeProvider extends ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.usages = [];\n        this.defaultLength = 0;\n    }\n    digest(...args) {\n        args[0] = { length: this.defaultLength, ...args[0] };\n        return super.digest.apply(this, args);\n    }\n    checkDigest(algorithm, data) {\n        super.checkDigest(algorithm, data);\n        const length = algorithm.length || 0;\n        if (typeof length !== \"number\") {\n            throw new TypeError(\"length: Is not a Number\");\n        }\n        if (length < 0) {\n            throw new TypeError(\"length: Is negative\");\n        }\n    }\n}\n\nclass Shake128Provider extends ShakeProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"shake128\";\n        this.defaultLength = 16;\n    }\n}\n\nclass Shake256Provider extends ShakeProvider {\n    constructor() {\n        super(...arguments);\n        this.name = \"shake256\";\n        this.defaultLength = 32;\n    }\n}\n\nclass Crypto {\n    get [Symbol.toStringTag]() {\n        return \"Crypto\";\n    }\n    randomUUID() {\n        const b = this.getRandomValues(new Uint8Array(16));\n        b[6] = (b[6] & 0x0f) | 0x40;\n        b[8] = (b[8] & 0x3f) | 0x80;\n        const uuid = pvtsutils.Convert.ToHex(b).toLowerCase();\n        return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n    }\n}\n\nclass ProviderStorage {\n    constructor() {\n        this.items = {};\n    }\n    get(algorithmName) {\n        return this.items[algorithmName.toLowerCase()] || null;\n    }\n    set(provider) {\n        this.items[provider.name.toLowerCase()] = provider;\n    }\n    removeAt(algorithmName) {\n        const provider = this.get(algorithmName.toLowerCase());\n        if (provider) {\n            delete this.items[algorithmName];\n        }\n        return provider;\n    }\n    has(name) {\n        return !!this.get(name);\n    }\n    get length() {\n        return Object.keys(this.items).length;\n    }\n    get algorithms() {\n        const algorithms = [];\n        for (const key in this.items) {\n            const provider = this.items[key];\n            algorithms.push(provider.name);\n        }\n        return algorithms.sort();\n    }\n}\n\nclass SubtleCrypto {\n    constructor() {\n        this.providers = new ProviderStorage();\n    }\n    static isHashedAlgorithm(data) {\n        return data\n            && typeof data === \"object\"\n            && \"name\" in data\n            && \"hash\" in data\n            ? true\n            : false;\n    }\n    get [Symbol.toStringTag]() {\n        return \"SubtleCrypto\";\n    }\n    async digest(...args) {\n        this.checkRequiredArguments(args, 2, \"digest\");\n        const [algorithm, data, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n        return result;\n    }\n    async generateKey(...args) {\n        this.checkRequiredArguments(args, 3, \"generateKey\");\n        const [algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n        return result;\n    }\n    async sign(...args) {\n        this.checkRequiredArguments(args, 3, \"sign\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);\n        return result;\n    }\n    async verify(...args) {\n        this.checkRequiredArguments(args, 4, \"verify\");\n        const [algorithm, key, signature, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const preparedSignature = pvtsutils.BufferSourceConverter.toArrayBuffer(signature);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);\n        return result;\n    }\n    async encrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"encrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n        return result;\n    }\n    async decrypt(...args) {\n        this.checkRequiredArguments(args, 3, \"decrypt\");\n        const [algorithm, key, data, ...params] = args;\n        this.checkCryptoKey(key);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(data);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n        return result;\n    }\n    async deriveBits(...args) {\n        this.checkRequiredArguments(args, 3, \"deriveBits\");\n        const [algorithm, baseKey, length, ...params] = args;\n        this.checkCryptoKey(baseKey);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);\n        return result;\n    }\n    async deriveKey(...args) {\n        this.checkRequiredArguments(args, 5, \"deriveKey\");\n        const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n        const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n        const importProvider = this.getProvider(preparedDerivedKeyType.name);\n        importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        provider.checkCryptoKey(baseKey, \"deriveKey\");\n        const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);\n        return this.importKey(\"raw\", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n    }\n    async exportKey(...args) {\n        this.checkRequiredArguments(args, 2, \"exportKey\");\n        const [format, key, ...params] = args;\n        this.checkCryptoKey(key);\n        const provider = this.getProvider(key.algorithm.name);\n        const result = await provider.exportKey(format, key, ...params);\n        return result;\n    }\n    async importKey(...args) {\n        this.checkRequiredArguments(args, 5, \"importKey\");\n        const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n        const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        if ([\"pkcs8\", \"spki\", \"raw\"].indexOf(format) !== -1) {\n            const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n            return provider.importKey(format, preparedData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n        }\n        else {\n            if (!keyData.kty) {\n                throw new TypeError(\"keyData: Is not JSON\");\n            }\n        }\n        return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n    }\n    async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n        let keyData = await this.exportKey(format, key, ...args);\n        if (format === \"jwk\") {\n            const json = JSON.stringify(keyData);\n            keyData = pvtsutils.Convert.FromUtf8String(json);\n        }\n        const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(keyData);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);\n    }\n    async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n        const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n        const preparedData = pvtsutils.BufferSourceConverter.toArrayBuffer(wrappedKey);\n        const provider = this.getProvider(preparedAlgorithm.name);\n        let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);\n        if (format === \"jwk\") {\n            try {\n                keyData = JSON.parse(pvtsutils.Convert.ToUtf8String(keyData));\n            }\n            catch (e) {\n                const error = new TypeError(\"wrappedKey: Is not a JSON\");\n                error.internal = e;\n                throw error;\n            }\n        }\n        return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n    }\n    checkRequiredArguments(args, size, methodName) {\n        if (args.length < size) {\n            throw new TypeError(`Failed to execute '${methodName}' on 'SubtleCrypto': ${size} arguments required, but only ${args.length} present`);\n        }\n    }\n    prepareAlgorithm(algorithm) {\n        if (typeof algorithm === \"string\") {\n            return {\n                name: algorithm,\n            };\n        }\n        if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n            const preparedAlgorithm = { ...algorithm };\n            preparedAlgorithm.hash = this.prepareAlgorithm(algorithm.hash);\n            return preparedAlgorithm;\n        }\n        return { ...algorithm };\n    }\n    getProvider(name) {\n        const provider = this.providers.get(name);\n        if (!provider) {\n            throw new AlgorithmError(\"Unrecognized name\");\n        }\n        return provider;\n    }\n    checkCryptoKey(key) {\n        if (!(key instanceof CryptoKey)) {\n            throw new TypeError(`Key is not of type 'CryptoKey'`);\n        }\n    }\n}\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  converters: index$3\n});\n\nconst REQUIRED_FIELDS = [\"crv\", \"e\", \"k\", \"kty\", \"n\", \"x\", \"y\"];\nclass JwkUtils {\n    static async thumbprint(hash, jwk, crypto) {\n        const data = this.format(jwk, true);\n        return crypto.subtle.digest(hash, pvtsutils.Convert.FromBinary(JSON.stringify(data)));\n    }\n    static format(jwk, remove = false) {\n        let res = Object.entries(jwk);\n        if (remove) {\n            res = res.filter(o => REQUIRED_FIELDS.includes(o[0]));\n        }\n        res = res.sort(([keyA], [keyB]) => keyA > keyB ? 1 : keyA < keyB ? -1 : 0);\n        return Object.fromEntries(res);\n    }\n}\n\nObject.defineProperty(exports, \"BufferSourceConverter\", ({\n  enumerable: true,\n  get: function () { return pvtsutils.BufferSourceConverter; }\n}));\nexports.AesCbcProvider = AesCbcProvider;\nexports.AesCmacProvider = AesCmacProvider;\nexports.AesCtrProvider = AesCtrProvider;\nexports.AesEcbProvider = AesEcbProvider;\nexports.AesGcmProvider = AesGcmProvider;\nexports.AesKwProvider = AesKwProvider;\nexports.AesProvider = AesProvider;\nexports.AlgorithmError = AlgorithmError;\nexports.Crypto = Crypto;\nexports.CryptoError = CryptoError;\nexports.CryptoKey = CryptoKey;\nexports.DesProvider = DesProvider;\nexports.EcCurves = EcCurves;\nexports.EcUtils = EcUtils;\nexports.EcdhEsProvider = EcdhEsProvider;\nexports.EcdhProvider = EcdhProvider;\nexports.EcdsaProvider = EcdsaProvider;\nexports.EdDsaProvider = EdDsaProvider;\nexports.EllipticProvider = EllipticProvider;\nexports.HkdfProvider = HkdfProvider;\nexports.HmacProvider = HmacProvider;\nexports.JwkUtils = JwkUtils;\nexports.OperationError = OperationError;\nexports.Pbkdf2Provider = Pbkdf2Provider;\nexports.PemConverter = PemConverter;\nexports.ProviderCrypto = ProviderCrypto;\nexports.ProviderStorage = ProviderStorage;\nexports.RequiredPropertyError = RequiredPropertyError;\nexports.RsaOaepProvider = RsaOaepProvider;\nexports.RsaProvider = RsaProvider;\nexports.RsaPssProvider = RsaPssProvider;\nexports.RsaSsaProvider = RsaSsaProvider;\nexports.Shake128Provider = Shake128Provider;\nexports.Shake256Provider = Shake256Provider;\nexports.ShakeProvider = ShakeProvider;\nexports.SubtleCrypto = SubtleCrypto;\nexports.UnsupportedOperationError = UnsupportedOperationError;\nexports.asn1 = index$1;\nexports.isJWK = isJWK;\nexports.json = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvYnVpbGQvd2ViY3J5cHRvLWNvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXO0FBQ25DLGlCQUFpQixtQkFBTyxDQUFDLDRGQUF1QjtBQUNoRCxZQUFZLG1CQUFPLENBQUMsbUZBQU87QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ2hELFdBQVcsbUJBQU8sQ0FBQywwREFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCLFdBQVcsT0FBTztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEVBQUUsZ0JBQWdCLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsU0FBUyxnQkFBZ0IsYUFBYSxhQUFhO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDBCQUEwQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxhQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDL0Qsb0JBQW9CLDJDQUEyQztBQUMvRCxvQkFBb0IsMkNBQTJDO0FBQy9ELG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDtBQUMvRSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9CQUFvQiwyREFBMkQ7QUFDL0Usb0JBQW9CLDJEQUEyRDs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELFFBQVE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3RCLGNBQWM7QUFDZCxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixpQ0FBaUM7QUFDakMsWUFBWTtBQUNaLGFBQWE7QUFDYixZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb3NwLy4vbm9kZV9tb2R1bGVzL3dlYmNyeXB0by1jb3JlL2J1aWxkL3dlYmNyeXB0by1jb3JlLmpzPzYwN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBhc24xID0gcmVxdWlyZSgnYXNuMWpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGFzbjFfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoYXNuMSk7XG5cbmNsYXNzIENyeXB0b0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5jbGFzcyBBbGdvcml0aG1FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBVbnN1cHBvcnRlZCBvcGVyYXRpb246ICR7bWV0aG9kTmFtZSA/IGAke21ldGhvZE5hbWV9YCA6IFwiXCJ9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBPcGVyYXRpb25FcnJvciBleHRlbmRzIENyeXB0b0Vycm9yIHtcbn1cblxuY2xhc3MgUmVxdWlyZWRQcm9wZXJ0eUVycm9yIGV4dGVuZHMgQ3J5cHRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BOYW1lKSB7XG4gICAgICAgIHN1cGVyKGAke3Byb3BOYW1lfTogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eWApO1xuICAgIH1cbn1cblxuY2xhc3MgUGVtQ29udmVydGVyIHtcbiAgICBzdGF0aWMgdG9BcnJheUJ1ZmZlcihwZW0pIHtcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gcGVtXG4gICAgICAgICAgICAucmVwbGFjZSgvLXs1fShCRUdJTnxFTkQpIC4qLXs1fS9nLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCJcXHJcIiwgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKFwiXFxuXCIsIFwiXCIpO1xuICAgICAgICByZXR1cm4gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NChiYXNlNjQpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9VaW50OEFycmF5KHBlbSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMudG9BcnJheUJ1ZmZlcihwZW0pO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlclNvdXJjZShidWZmZXIsIHRhZykge1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChidWZmZXIpO1xuICAgICAgICBsZXQgc2xpY2VkO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgYmFzZTY0Lmxlbmd0aCkge1xuICAgICAgICAgICAgc2xpY2VkID0gYmFzZTY0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNjQpO1xuICAgICAgICAgICAgaWYgKHNsaWNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByb3dzLnB1c2goc2xpY2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IDY0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhZyA9IHRhZy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYC0tLS0tQkVHSU4gJHt1cHBlckNhc2VUYWd9LS0tLS1cXG4ke3Jvd3Muam9pbihcIlxcblwiKX1cXG4tLS0tLUVORCAke3VwcGVyQ2FzZVRhZ30tLS0tLWA7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BFTShkYXRhKSB7XG4gICAgICAgIHJldHVybiAvLS0tLS1CRUdJTiAuKy0tLS0tW0EtWmEtejAtOSsvKz1cXHNcXG5dKy0tLS0tRU5EIC4rLS0tLS0vaS50ZXN0KGRhdGEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VGFnTmFtZShwZW0pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUEVNKHBlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBwYXJhbWV0ZXIuIEluY29taW5nIGRhdGEgaXMgbm90IHJpZ2h0IFBFTVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSAvLS0tLS1CRUdJTiAoLispLS0tLS0vLmV4ZWMocGVtKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGFnIGZyb20gUEVNXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNbMV07XG4gICAgfVxuICAgIHN0YXRpYyBoYXNUYWdOYW1lKHBlbSwgdGFnTmFtZSkge1xuICAgICAgICBjb25zdCB0YWcgPSB0aGlzLmdldFRhZ05hbWUocGVtKTtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0NlcnRpZmljYXRlKHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZVwiKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQ2VydGlmaWNhdGVSZXF1ZXN0KHBlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNUYWdOYW1lKHBlbSwgXCJjZXJ0aWZpY2F0ZSByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDUkwocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcIng1MDkgY3JsXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQdWJsaWNLZXkocGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZ05hbWUocGVtLCBcInB1YmxpYyBrZXlcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0pXSyhkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIFwia3R5XCIgaW4gZGF0YTtcbn1cblxuY2xhc3MgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGFzeW5jIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRGlnZXN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0RpZ2VzdChhbGdvcml0aG0sIF9kYXRhKSB7XG4gICAgICAgIHRoaXMuY2hlY2tBbGdvcml0aG1OYW1lKGFsZ29yaXRobSk7XG4gICAgfVxuICAgIGFzeW5jIG9uRGlnZXN0KF9hbGdvcml0aG0sIF9kYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZGlnZXN0XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tHZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25HZW5lcmF0ZUtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleShhbGdvcml0aG0sIF9leHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICAgICAgaWYgKCEoa2V5VXNhZ2VzICYmIGtleVVzYWdlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVc2FnZXMgY2Fubm90IGJlIGVtcHR5IHdoZW4gY3JlYXRpbmcgYSBrZXkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsbG93ZWRVc2FnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMudXNhZ2VzKSkge1xuICAgICAgICAgICAgYWxsb3dlZFVzYWdlcyA9IHRoaXMudXNhZ2VzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxsb3dlZFVzYWdlcyA9IHRoaXMudXNhZ2VzLnByaXZhdGVLZXkuY29uY2F0KHRoaXMudXNhZ2VzLnB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0tleVVzYWdlcyhrZXlVc2FnZXMsIGFsbG93ZWRVc2FnZXMpO1xuICAgIH1cbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKF9hbGdvcml0aG0pIHtcbiAgICB9XG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShfYWxnb3JpdGhtLCBfZXh0cmFjdGFibGUsIF9rZXlVc2FnZXMsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZ2VuZXJhdGVLZXlcIik7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24oLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrU2lnbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25TaWduLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja1NpZ24oYWxnb3JpdGhtLCBrZXksIF9kYXRhLCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBcInNpZ25cIik7XG4gICAgfVxuICAgIGFzeW5jIG9uU2lnbihfYWxnb3JpdGhtLCBfa2V5LCBfZGF0YSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJzaWduXCIpO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrVmVyaWZ5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vblZlcmlmeS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tWZXJpZnkoYWxnb3JpdGhtLCBrZXksIF9zaWduYXR1cmUsIF9kYXRhLCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBcInZlcmlmeVwiKTtcbiAgICB9XG4gICAgYXN5bmMgb25WZXJpZnkoX2FsZ29yaXRobSwgX2tleSwgX3NpZ25hdHVyZSwgX2RhdGEsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwidmVyaWZ5XCIpO1xuICAgIH1cbiAgICBhc3luYyBlbmNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0VuY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uRW5jcnlwdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tFbmNyeXB0KGFsZ29yaXRobSwga2V5LCBfZGF0YSwgb3B0aW9ucyA9IHt9LCAuLi5fYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSk7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5LCBvcHRpb25zLmtleVVzYWdlID8gXCJlbmNyeXB0XCIgOiB2b2lkIDApO1xuICAgIH1cbiAgICBhc3luYyBvbkVuY3J5cHQoX2FsZ29yaXRobSwgX2tleSwgX2RhdGEsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yKFwiZW5jcnlwdFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZGVjcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tEZWNyeXB0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkRlY3J5cHQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGVjcnlwdChhbGdvcml0aG0sIGtleSwgX2RhdGEsIG9wdGlvbnMgPSB7fSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGtleSwgb3B0aW9ucy5rZXlVc2FnZSA/IFwiZGVjcnlwdFwiIDogdm9pZCAwKTtcbiAgICB9XG4gICAgYXN5bmMgb25EZWNyeXB0KF9hbGdvcml0aG0sIF9rZXksIF9kYXRhLCAuLi5fYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihcImRlY3J5cHRcIik7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUJpdHMoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRGVyaXZlQml0cy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub25EZXJpdmVCaXRzLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0Rlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIG9wdGlvbnMgPSB7fSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGJhc2VLZXksIG9wdGlvbnMua2V5VXNhZ2UgPyBcImRlcml2ZUJpdHNcIiA6IHZvaWQgMCk7XG4gICAgICAgIGlmIChsZW5ndGggJSA4ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBtdWx0aXBsZSBvZiA4XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhfYWxnb3JpdGhtLCBfYmFzZUtleSwgX2xlbmd0aCwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJkZXJpdmVCaXRzXCIpO1xuICAgIH1cbiAgICBhc3luYyBleHBvcnRLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5vbkV4cG9ydEtleS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2hlY2tFeHBvcnRLZXkoZm9ybWF0LCBrZXksIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBpZiAoIWtleS5leHRyYWN0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKFwia2V5OiBJcyBub3QgZXh0cmFjdGFibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25FeHBvcnRLZXkoX2Zvcm1hdCwgX2tleSwgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJleHBvcnRLZXlcIik7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydEtleSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbXBvcnRLZXkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzLm9uSW1wb3J0S2V5LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBjaGVja0ltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgX2V4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLl9hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tLZXlGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgdGhpcy5jaGVja0tleURhdGEoZm9ybWF0LCBrZXlEYXRhKTtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcbiAgICAgICAgdGhpcy5jaGVja0ltcG9ydFBhcmFtcyhhbGdvcml0aG0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnVzYWdlcykpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tLZXlVc2FnZXMoa2V5VXNhZ2VzLCB0aGlzLnVzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgb25JbXBvcnRLZXkoX2Zvcm1hdCwgX2tleURhdGEsIF9hbGdvcml0aG0sIF9leHRyYWN0YWJsZSwgX2tleVVzYWdlcywgLi4uX2FyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IoXCJpbXBvcnRLZXlcIik7XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtTmFtZShhbGdvcml0aG0pIHtcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvTG93ZXJDYXNlKCkgIT09IHRoaXMubmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxnb3JpdGhtRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhfYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhfYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrS2V5VXNhZ2VzKHVzYWdlcywgYWxsb3dlZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHVzYWdlIG9mIHVzYWdlcykge1xuICAgICAgICAgICAgaWYgKGFsbG93ZWQuaW5kZXhPZih1c2FnZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjcmVhdGUgYSBrZXkgdXNpbmcgdGhlIHNwZWNpZmllZCBrZXkgdXNhZ2VzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcbiAgICAgICAgdGhpcy5jaGVja0FsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobSk7XG4gICAgICAgIGlmIChrZXlVc2FnZSAmJiBrZXkudXNhZ2VzLmluZGV4T2Yoa2V5VXNhZ2UpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKGBrZXkgZG9lcyBub3QgbWF0Y2ggdGhhdCBvZiBvcGVyYXRpb25gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1JlcXVpcmVkUHJvcGVydHkoZGF0YSwgcHJvcE5hbWUpIHtcbiAgICAgICAgaWYgKCEocHJvcE5hbWUgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXF1aXJlZFByb3BlcnR5RXJyb3IocHJvcE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0sIGhhc2hBbGdvcml0aG1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBoYXNoQWxnb3JpdGhtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9Mb3dlckNhc2UoKSA9PT0gYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYGhhc2g6IE11c3QgYmUgb25lIG9mICR7aGFzaEFsZ29yaXRobXMuam9pbihcIiwgXCIpfWApO1xuICAgIH1cbiAgICBjaGVja0ltcG9ydFBhcmFtcyhfYWxnb3JpdGhtKSB7XG4gICAgfVxuICAgIGNoZWNrS2V5Rm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZm9ybWF0OiBJcyBpbnZhbGlkIHZhbHVlLiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3Nwa2knLCBvciAncGtjczgnXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrS2V5RGF0YShmb3JtYXQsIGtleURhdGEpIHtcbiAgICAgICAgaWYgKCFrZXlEYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogQ2Fubm90IGJlIGVtcHR5IG9uIGVtcHR5IG9uIGtleSBpbXBvcnRpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgaWYgKCFpc0pXSyhrZXlEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBJcyBub3QgSnNvbldlYlRva2VuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGtleURhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5RGF0YTogSXMgbm90IEFycmF5QnVmZmVyVmlldyBvciBBcnJheUJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlRGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgfVxufVxuXG5jbGFzcyBBZXNQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBvZiB0eXBlIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTI4OlxuICAgICAgICAgICAgY2FzZSAxOTI6XG4gICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogTXVzdCBiZSAxMjgsIDE5Miwgb3IgMjU2XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrRGVyaXZlZEtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSk7XG4gICAgfVxufVxuXG5jbGFzcyBBZXNDYmNQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtQ0JDXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZW5jcnlwdFwiLCBcImRlY3J5cHRcIiwgXCJ3cmFwS2V5XCIsIFwidW53cmFwS2V5XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uaXYgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLml2KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLml2LmJ5dGVMZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXY6IE11c3QgaGF2ZSBsZW5ndGggMTYgYnl0ZXNcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIEFlc1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBRVMtQ01BQ1wiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogTXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUNUUlwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJjb3VudGVyXCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0uY291bnRlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uY291bnRlcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY291bnRlcjogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmNvdW50ZXIuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdjogTXVzdCBoYXZlIGxlbmd0aCAxNiBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwibGVuZ3RoXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobS5sZW5ndGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImxlbmd0aDogTXVzdCBiZSBtb3JlIHRoYW4gMFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQWVzRWNiUHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUVDQlwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG59XG5cbmNsYXNzIEFlc0djbVByb3ZpZGVyIGV4dGVuZHMgQWVzUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFFUy1HQ01cIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXCJlbmNyeXB0XCIsIFwiZGVjcnlwdFwiLCBcIndyYXBLZXlcIiwgXCJ1bndyYXBLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaXZcIik7XG4gICAgICAgIGlmICghKGFsZ29yaXRobS5pdiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhhbGdvcml0aG0uaXYpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0uaXYuYnl0ZUxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcIml2OiBNdXN0IGhhdmUgbGVuZ3RoIG1vcmUgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMl42NCAtIDFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJ0YWdMZW5ndGhcIiBpbiBhbGdvcml0aG0pKSB7XG4gICAgICAgICAgICBhbGdvcml0aG0udGFnTGVuZ3RoID0gMTI4O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLnRhZ0xlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGNhc2UgNjQ6XG4gICAgICAgICAgICBjYXNlIDk2OlxuICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIGNhc2UgMTIwOlxuICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcInRhZ0xlbmd0aDogTXVzdCBiZSBvbmUgb2YgMzIsIDY0LCA5NiwgMTA0LCAxMTIsIDEyMCBvciAxMjhcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFlc0t3UHJvdmlkZXIgZXh0ZW5kcyBBZXNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiQUVTLUtXXCI7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG59XG5cbmNsYXNzIERlc1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCIsIFwid3JhcEtleVwiLCBcInVud3JhcEtleVwiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmICh0aGlzLml2U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml2XCIpO1xuICAgICAgICAgICAgaWYgKCEoYWxnb3JpdGhtLml2IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5pdikpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml2OiBJcyBub3Qgb2YgdHlwZSAnKEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldyknXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsZ29yaXRobS5pdi5ieXRlTGVuZ3RoICE9PSB0aGlzLml2U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGl2OiBNdXN0IGhhdmUgbGVuZ3RoICR7dGhpcy5pdlNpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImxlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3Qgb2YgdHlwZSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggIT09IHRoaXMua2V5U2l6ZUJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihgYWxnb3JpdGhtLmxlbmd0aDogTXVzdCBiZSAke3RoaXMua2V5U2l6ZUJpdHN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tEZXJpdmVkS2V5UGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNFeHBvbmVudFwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ICYmIGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaWNFeHBvbmVudCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0KGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCk7XG4gICAgICAgIGlmICghKHB1YmxpY0V4cG9uZW50ID09PSBcIkF3PT1cIiB8fCBwdWJsaWNFeHBvbmVudCA9PT0gXCJBUUFCXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE11c3QgYmUgWzNdIG9yIFsxLDAsMV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm1vZHVsdXNMZW5ndGhcIik7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCAlIDhcbiAgICAgICAgICAgIHx8IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoIDwgMjU2XG4gICAgICAgICAgICB8fCBhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+IDE2Mzg0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIG1vZHVsdXMgbGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4IGJpdHMgYW5kID49IDI1NiBhbmQgPD0gMTYzODRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jbGFzcyBSc2FTc2FQcm92aWRlciBleHRlbmRzIFJzYVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0FTU0EtUEtDUzEtdjFfNVwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmNsYXNzIFJzYVBzc1Byb3ZpZGVyIGV4dGVuZHMgUnNhUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJTQS1QU1NcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdExlbmd0aFwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0uc2FsdExlbmd0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHRMZW5ndGg6IElzIG5vdCBhIE51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnNhbHRMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNhbHRMZW5ndGg6IE11c3QgYmUgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBSc2FPYWVwUHJvdmlkZXIgZXh0ZW5kcyBSc2FQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBLU9BRVBcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJlbmNyeXB0XCIsIFwid3JhcEtleVwiXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWxcbiAgICAgICAgICAgICYmICEoYWxnb3JpdGhtLmxhYmVsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGFsZ29yaXRobS5sYWJlbCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGFiZWw6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEVsbGlwdGljUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY2hlY2tHZW5lcmF0ZUtleVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm5hbWVkQ3VydmVcIik7XG4gICAgICAgIHRoaXMuY2hlY2tOYW1lZEN1cnZlKGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcbiAgICB9XG4gICAgY2hlY2tOYW1lZEN1cnZlKG5hbWVkQ3VydmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMubmFtZWRDdXJ2ZXMpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnRvTG93ZXJDYXNlKCkgPT09IG5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYG5hbWVkQ3VydmU6IE11c3QgYmUgb25lIG9mICR7dGhpcy5uYW1lZEN1cnZlcy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxufVxuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRUNEU0FcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcInNpZ25cIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcInZlcmlmeVwiXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlAtMjU2XCIsIFwiUC0zODRcIiwgXCJQLTUyMVwiLCBcIkstMjU2XCJdO1xuICAgIH1cbiAgICBjaGVja0FsZ29yaXRobVBhcmFtcyhhbGdvcml0aG0pIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcImhhc2hcIik7XG4gICAgICAgIHRoaXMuY2hlY2tIYXNoQWxnb3JpdGhtKGFsZ29yaXRobS5oYXNoLCB0aGlzLmhhc2hBbGdvcml0aG1zKTtcbiAgICB9XG59XG5cbmNvbnN0IEtFWV9UWVBFUyA9IFtcInNlY3JldFwiLCBcInByaXZhdGVcIiwgXCJwdWJsaWNcIl07XG5jbGFzcyBDcnlwdG9LZXkge1xuICAgIHN0YXRpYyBjcmVhdGUoYWxnb3JpdGhtLCB0eXBlLCBleHRyYWN0YWJsZSwgdXNhZ2VzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyB0aGlzKCk7XG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XG4gICAgICAgIGtleS50eXBlID0gdHlwZTtcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XG4gICAgICAgIGtleS51c2FnZXMgPSB1c2FnZXM7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0tleVR5cGUoZGF0YSkge1xuICAgICAgICByZXR1cm4gS0VZX1RZUEVTLmluZGV4T2YoZGF0YSkgIT09IC0xO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIkNyeXB0b0tleVwiO1xuICAgIH1cbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRUNESFwiO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlcml2ZUJpdHNcIiwgXCJkZXJpdmVLZXlcIl0sXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gW1wiUC0yNTZcIiwgXCJQLTM4NFwiLCBcIlAtNTIxXCIsIFwiSy0yNTZcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwicHVibGljXCIpO1xuICAgICAgICBpZiAoIShhbGdvcml0aG0ucHVibGljIGluc3RhbmNlb2YgQ3J5cHRvS2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpYzogSXMgbm90IGEgQ3J5cHRvS2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGdvcml0aG0ucHVibGljLnR5cGUgIT09IFwicHVibGljXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcInB1YmxpYzogSXMgbm90IGEgcHVibGljIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxnb3JpdGhtLnB1YmxpYy5hbGdvcml0aG0ubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRXJyb3IoYHB1YmxpYzogSXMgbm90ICR7dGhpcy5uYW1lfSBrZXlgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRWNkaEVzUHJvdmlkZXIgZXh0ZW5kcyBFY2RoUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkVDREgtRVNcIjtcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IFtcIlgyNTUxOVwiLCBcIlg0NDhcIl07XG4gICAgfVxufVxuXG5jbGFzcyBFZERzYVByb3ZpZGVyIGV4dGVuZHMgRWxsaXB0aWNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiRWREU0FcIjtcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJzaWduXCJdLFxuICAgICAgICAgICAgcHVibGljS2V5OiBbXCJ2ZXJpZnlcIl0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBbXCJFZDI1NTE5XCIsIFwiRWQ0NDhcIl07XG4gICAgfVxufVxuXG5sZXQgT2JqZWN0SWRlbnRpZmllciA9IGNsYXNzIE9iamVjdElkZW50aWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9iamVjdElkZW50aWZpZXIgfSlcbl0sIE9iamVjdElkZW50aWZpZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5PYmplY3RJZGVudGlmaWVyID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBPYmplY3RJZGVudGlmaWVyKTtcblxuY2xhc3MgQWxnb3JpdGhtSWRlbnRpZmllciB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1zKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3Aoe1xuICAgICAgICB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyLFxuICAgIH0pXG5dLCBBbGdvcml0aG1JZGVudGlmaWVyLnByb3RvdHlwZSwgXCJhbGdvcml0aG1cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7XG4gICAgICAgIHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSxcbiAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgfSlcbl0sIEFsZ29yaXRobUlkZW50aWZpZXIucHJvdG90eXBlLCBcInBhcmFtZXRlcnNcIiwgdm9pZCAwKTtcblxuY2xhc3MgUHJpdmF0ZUtleUluZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXlBbGdvcml0aG0gPSBuZXcgQWxnb3JpdGhtSWRlbnRpZmllcigpO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcInZlcnNpb25cIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IEFsZ29yaXRobUlkZW50aWZpZXIgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJwcml2YXRlS2V5QWxnb3JpdGhtXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgUHJpdmF0ZUtleUluZm8ucHJvdG90eXBlLCBcInByaXZhdGVLZXlcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkFueSwgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFByaXZhdGVLZXlJbmZvLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFB1YmxpY0tleUluZm8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnB1YmxpY0tleUFsZ29yaXRobSA9IG5ldyBBbGdvcml0aG1JZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIH1cbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IEFsZ29yaXRobUlkZW50aWZpZXIgfSlcbl0sIFB1YmxpY0tleUluZm8ucHJvdG90eXBlLCBcInB1YmxpY0tleUFsZ29yaXRobVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nIH0pXG5dLCBQdWJsaWNLZXlJbmZvLnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxuY29uc3QgSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyID0ge1xuICAgIGZyb21KU09OOiAodmFsdWUpID0+IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwodmFsdWUpLFxuICAgIHRvSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChuZXcgVWludDhBcnJheSh2YWx1ZSkpLFxufTtcblxuY29uc3QgQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZUhleCA9IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgIHJldHVybiAhKG5ldyBVaW50OEFycmF5KHZhbHVlSGV4KVswXSlcbiAgICAgICAgICAgID8gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleC5zbGljZSgxKVxuICAgICAgICAgICAgOiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgIH0sXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZUhleCA9IG5ldyBVaW50OEFycmF5KHZhbHVlKVswXSA+IDEyN1xuICAgICAgICAgICAgPyBwdnRzdXRpbHMuY29tYmluZShuZXcgVWludDhBcnJheShbMF0pLmJ1ZmZlciwgdmFsdWUpXG4gICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFfX25hbWVzcGFjZS5JbnRlZ2VyKHsgdmFsdWVIZXggfSk7XG4gICAgfSxcbn07XG5cbnZhciBpbmRleCQzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyLFxuICBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlclxufSk7XG5cbmNsYXNzIFJzYVByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLm1vZHVsdXMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHVibGljRXhwb25lbnQgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMucHJpdmF0ZUV4cG9uZW50ID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnByaW1lMSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wcmltZTIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIHRoaXMuZXhwb25lbnQxID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLmV4cG9uZW50MiA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5jb2VmZmljaWVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IGFzbjFTY2hlbWEuQXNuSW50ZWdlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiblwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwibW9kdWx1c1wiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZVwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHVibGljRXhwb25lbnRcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVByaXZhdGVLZXkucHJvdG90eXBlLCBcInByaXZhdGVFeHBvbmVudFwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSksXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwicFwiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxBcnJheUJ1ZmZlckNvbnZlcnRlciB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpbWUxXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJxXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwcmltZTJcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRwXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJleHBvbmVudDFcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImRxXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJleHBvbmVudDJcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcInFpXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJjb2VmZmljaWVudFwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUnNhUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwib3RoZXJQcmltZUluZm9zXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFJzYVB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubW9kdWx1cyA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgdGhpcy5wdWJsaWNFeHBvbmVudCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICB9XG59XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJuXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybEFycmF5QnVmZmVyQ29udmVydGVyIH0pXG5dLCBSc2FQdWJsaWNLZXkucHJvdG90eXBlLCBcIm1vZHVsdXNcIiwgdm9pZCAwKTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkludGVnZXIsIGNvbnZlcnRlcjogQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIH0pLFxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImVcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIFJzYVB1YmxpY0tleS5wcm90b3R5cGUsIFwicHVibGljRXhwb25lbnRcIiwgdm9pZCAwKTtcblxubGV0IEVjUHVibGljS2V5ID0gY2xhc3MgRWNQdWJsaWNLZXkge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZSk7XG4gICAgICAgIGlmIChieXRlc1swXSAhPT0gMHgwNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENyeXB0b0Vycm9yKFwiV3JvbmcgRUNQb2ludC4gQ3VycmVudCB2ZXJzaW9uIHN1cHBvcnRzIG9ubHkgVW5jb21wcmVzc2VkICgweDA0KSBwb2ludFwiKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICBjb25zdCBzaXplID0gYnl0ZXMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3QganNvbiA9IHtcbiAgICAgICAgICAgIHg6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGJ5dGVzLmJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpKSxcbiAgICAgICAgICAgIHk6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGJ5dGVzLmJ1ZmZlci5zbGljZShvZmZzZXQgKyBzaXplLCBvZmZzZXQgKyBzaXplICsgc2l6ZSkpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgZnJvbUpTT04oanNvbikge1xuICAgICAgICBpZiAoIShcInhcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieDogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShcInlcIiBpbiBqc29uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieTogTWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLngpO1xuICAgICAgICBjb25zdCB5ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLnkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHB2dHN1dGlscy5jb21iaW5lKG5ldyBVaW50OEFycmF5KFsweDA0XSkuYnVmZmVyLCB4LCB5KTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKS5idWZmZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KVxuXSwgRWNQdWJsaWNLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FY1B1YmxpY0tleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgRWNQdWJsaWNLZXkpO1xuXG5jbGFzcyBFY1ByaXZhdGVLZXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJkXCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImQ6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcml2YXRlS2V5ID0gcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqc29uLmQpO1xuICAgICAgICBpZiAoXCJ4XCIgaW4ganNvbikge1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XG4gICAgICAgICAgICBwdWJsaWNLZXkuZnJvbUpTT04oanNvbik7XG4gICAgICAgICAgICBjb25zdCBhc24gPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIudG9BU04ocHVibGljS2V5KTtcbiAgICAgICAgICAgIGlmIChcInZhbHVlSGV4XCIgaW4gYXNuLnZhbHVlQmxvY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGp3ayA9IHt9O1xuICAgICAgICBqd2suZCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgIGlmICh0aGlzLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihqd2ssIG5ldyBFY1B1YmxpY0tleSh0aGlzLnB1YmxpY0tleSkudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBhc24xU2NoZW1hLkFzbkludGVnZXJDb252ZXJ0ZXIgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwidmVyc2lvblwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuT2N0ZXRTdHJpbmcgfSlcbl0sIEVjUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwicHJpdmF0ZUtleVwiLCB2b2lkIDApO1xudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgY29udGV4dDogMCwgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuQW55LCBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRWNQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJwYXJhbWV0ZXJzXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyBjb250ZXh0OiAxLCB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBFY1ByaXZhdGVLZXkucHJvdG90eXBlLCBcInB1YmxpY0tleVwiLCB2b2lkIDApO1xuXG5jb25zdCBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUudmFsdWVCbG9jay52YWx1ZUhleCk7XG4gICAgICAgIHJldHVybiAoYnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICA/IGJ5dGVzLmJ1ZmZlci5zbGljZSgxKVxuICAgICAgICAgICAgOiBieXRlcy5idWZmZXI7XG4gICAgfSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAoYnl0ZXNbMF0gPiAxMjcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICBuZXdWYWx1ZS5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4OiBuZXdWYWx1ZS5idWZmZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBhc24xX19uYW1lc3BhY2UuSW50ZWdlcih7IHZhbHVlSGV4OiB2YWx1ZSB9KTtcbiAgICB9LFxufTtcblxudmFyIGluZGV4JDIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQXNuSW50ZWdlcldpdGhvdXRQYWRkaW5nQ29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXJcbn0pO1xuXG5jbGFzcyBFY1V0aWxzIHtcbiAgICBzdGF0aWMgZGVjb2RlUG9pbnQoZGF0YSwgcG9pbnRTaXplKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKCh2aWV3Lmxlbmd0aCA9PT0gMCkgfHwgKHZpZXdbMF0gIT09IDQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IHVuY29tcHJlc3NlZCBwb2ludCBmb3JtYXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSAodmlldy5sZW5ndGggLSAxKSAvIDI7XG4gICAgICAgIGlmIChuICE9PSAoTWF0aC5jZWlsKHBvaW50U2l6ZSAvIDgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9pbnQgZG9lcyBub3QgbWF0Y2ggZmllbGQgc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4YiA9IHZpZXcuc2xpY2UoMSwgbiArIDEpO1xuICAgICAgICBjb25zdCB5YiA9IHZpZXcuc2xpY2UobiArIDEsIG4gKyAxICsgbik7XG4gICAgICAgIHJldHVybiB7IHg6IHhiLCB5OiB5YiB9O1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlUG9pbnQocG9pbnQsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5jZWlsKHBvaW50U2l6ZSAvIDgpO1xuICAgICAgICBpZiAocG9pbnQueC5ieXRlTGVuZ3RoICE9PSBzaXplIHx8IHBvaW50LnkuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWCxZIGNvb3JkaW5hdGVzIGRvbid0IG1hdGNoIHBvaW50IHNpemUgY3JpdGVyaWFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBvaW50LngpO1xuICAgICAgICBjb25zdCB5ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocG9pbnQueSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiAyICsgMSk7XG4gICAgICAgIHJlc1swXSA9IDQ7XG4gICAgICAgIHJlcy5zZXQoeCwgMSk7XG4gICAgICAgIHJlcy5zZXQoeSwgc2l6ZSArIDEpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2l6ZShwb2ludFNpemUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChwb2ludFNpemUgLyA4KTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVNpZ25hdHVyZShzaWduYXR1cmUsIHBvaW50U2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKHBvaW50U2l6ZSk7XG4gICAgICAgIGNvbnN0IHIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShzaWduYXR1cmUucik7XG4gICAgICAgIGNvbnN0IHMgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShzaWduYXR1cmUucyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiAyKTtcbiAgICAgICAgcmVzLnNldCh0aGlzLnBhZFN0YXJ0KHIsIHNpemUpKTtcbiAgICAgICAgcmVzLnNldCh0aGlzLnBhZFN0YXJ0KHMsIHNpemUpLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZVNpZ25hdHVyZShkYXRhLCBwb2ludFNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZShwb2ludFNpemUpO1xuICAgICAgICBjb25zdCB2aWV3ID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIGlmICh2aWV3Lmxlbmd0aCAhPT0gKHNpemUgKiAyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHNpemUgb2YgdGhlIHNpZ25hdHVyZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdmlldy5zbGljZSgwLCBzaXplKTtcbiAgICAgICAgY29uc3QgcyA9IHZpZXcuc2xpY2Uoc2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiB0aGlzLnRyaW1TdGFydChyKSxcbiAgICAgICAgICAgIHM6IHRoaXMudHJpbVN0YXJ0KHMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgdHJpbVN0YXJ0KGRhdGEpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoKGkgPCBkYXRhLmxlbmd0aCAtIDEpICYmIChkYXRhW2ldID09PSAwKSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5zbGljZShpLCBkYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYWRTdGFydChkYXRhLCBzaXplKSB7XG4gICAgICAgIGlmIChzaXplID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIHJlcy5zZXQoZGF0YSwgc2l6ZSAtIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbmNsYXNzIEVjRHNhU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICB0aGlzLnMgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tV2ViQ3J5cHRvU2lnbmF0dXJlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IHZhbHVlLmJ5dGVMZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBwb2ludCA9IEVjVXRpbHMuZGVjb2RlU2lnbmF0dXJlKHZhbHVlLCBwb2ludFNpemUgKiA4KTtcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBuZXcgRWNEc2FTaWduYXR1cmUoKTtcbiAgICAgICAgZWNTaWduYXR1cmUuciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwb2ludC5yKTtcbiAgICAgICAgZWNTaWduYXR1cmUucyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwb2ludC5zKTtcbiAgICAgICAgcmV0dXJuIGVjU2lnbmF0dXJlO1xuICAgIH1cbiAgICB0b1dlYkNyeXB0b1NpZ25hdHVyZShwb2ludFNpemUpIHtcbiAgICAgICAgcG9pbnRTaXplICE9PSBudWxsICYmIHBvaW50U2l6ZSAhPT0gdm9pZCAwID8gcG9pbnRTaXplIDogKHBvaW50U2l6ZSA9IE1hdGgubWF4KHRoaXMuci5ieXRlTGVuZ3RoLCB0aGlzLnMuYnl0ZUxlbmd0aCkgKiA4KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gRWNVdGlscy5lbmNvZGVTaWduYXR1cmUodGhpcywgcG9pbnRTaXplKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZS5idWZmZXI7XG4gICAgfVxufVxudHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25Qcm9wKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25Qcm9wVHlwZXMuSW50ZWdlciwgY29udmVydGVyOiBBc25JbnRlZ2VyV2l0aG91dFBhZGRpbmdDb252ZXJ0ZXIgfSlcbl0sIEVjRHNhU2lnbmF0dXJlLnByb3RvdHlwZSwgXCJyXCIsIHZvaWQgMCk7XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5JbnRlZ2VyLCBjb252ZXJ0ZXI6IEFzbkludGVnZXJXaXRob3V0UGFkZGluZ0NvbnZlcnRlciB9KVxuXSwgRWNEc2FTaWduYXR1cmUucHJvdG90eXBlLCBcInNcIiwgdm9pZCAwKTtcblxuY2xhc3MgT25lQXN5bW1ldHJpY0tleSBleHRlbmRzIFByaXZhdGVLZXlJbmZvIHtcbn1cbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IGNvbnRleHQ6IDEsIGltcGxpY2l0OiB0cnVlLCB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5CaXRTdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBPbmVBc3ltbWV0cmljS2V5LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwgdm9pZCAwKTtcblxubGV0IEVkUHJpdmF0ZUtleSA9IGNsYXNzIEVkUHJpdmF0ZUtleSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uLmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImQ6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi5kKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgandrID0ge1xuICAgICAgICAgICAgZDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodGhpcy52YWx1ZSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nIH0pXG5dLCBFZFByaXZhdGVLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FZFByaXZhdGVLZXkgPSB0c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblR5cGUoeyB0eXBlOiBhc24xU2NoZW1hLkFzblR5cGVUeXBlcy5DaG9pY2UgfSlcbl0sIEVkUHJpdmF0ZUtleSk7XG5cbmxldCBFZFB1YmxpY0tleSA9IGNsYXNzIEVkUHVibGljS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh0aGlzLnZhbHVlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIGZyb21KU09OKGpzb24pIHtcbiAgICAgICAgaWYgKCEoXCJ4XCIgaW4ganNvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIng6IE1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufTtcbnRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuUHJvcCh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuUHJvcFR5cGVzLkJpdFN0cmluZyB9KVxuXSwgRWRQdWJsaWNLZXkucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5FZFB1YmxpY0tleSA9IHRzbGliLl9fZGVjb3JhdGUoW1xuICAgIGFzbjFTY2hlbWEuQXNuVHlwZSh7IHR5cGU6IGFzbjFTY2hlbWEuQXNuVHlwZVR5cGVzLkNob2ljZSB9KVxuXSwgRWRQdWJsaWNLZXkpO1xuXG5sZXQgQ3VydmVQcml2YXRlS2V5ID0gY2xhc3MgQ3VydmVQcml2YXRlS2V5IHtcbn07XG50c2xpYi5fX2RlY29yYXRlKFtcbiAgICBhc24xU2NoZW1hLkFzblByb3AoeyB0eXBlOiBhc24xU2NoZW1hLkFzblByb3BUeXBlcy5PY3RldFN0cmluZyB9KSxcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZywgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQXJyYXlCdWZmZXJDb252ZXJ0ZXIgfSlcbl0sIEN1cnZlUHJpdmF0ZUtleS5wcm90b3R5cGUsIFwiZFwiLCB2b2lkIDApO1xuQ3VydmVQcml2YXRlS2V5ID0gdHNsaWIuX19kZWNvcmF0ZShbXG4gICAgYXNuMVNjaGVtYS5Bc25UeXBlKHsgdHlwZTogYXNuMVNjaGVtYS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pXG5dLCBDdXJ2ZVByaXZhdGVLZXkpO1xuXG5jb25zdCBpZFNlY3AyNTZyMSA9IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiO1xuY29uc3QgaWRFbGxpcHRpY0N1cnZlID0gXCIxLjMuMTMyLjBcIjtcbmNvbnN0IGlkU2VjcDM4NHIxID0gYCR7aWRFbGxpcHRpY0N1cnZlfS4zNGA7XG5jb25zdCBpZFNlY3A1MjFyMSA9IGAke2lkRWxsaXB0aWNDdXJ2ZX0uMzVgO1xuY29uc3QgaWRTZWNwMjU2azEgPSBgJHtpZEVsbGlwdGljQ3VydmV9LjEwYDtcbmNvbnN0IGlkVmVyc2lvbk9uZSA9IFwiMS4zLjM2LjMuMy4yLjguMS4xXCI7XG5jb25zdCBpZEJyYWlucG9vbFAxNjByMSA9IGAke2lkVmVyc2lvbk9uZX0uMWA7XG5jb25zdCBpZEJyYWlucG9vbFAxNjB0MSA9IGAke2lkVmVyc2lvbk9uZX0uMmA7XG5jb25zdCBpZEJyYWlucG9vbFAxOTJyMSA9IGAke2lkVmVyc2lvbk9uZX0uM2A7XG5jb25zdCBpZEJyYWlucG9vbFAxOTJ0MSA9IGAke2lkVmVyc2lvbk9uZX0uNGA7XG5jb25zdCBpZEJyYWlucG9vbFAyMjRyMSA9IGAke2lkVmVyc2lvbk9uZX0uNWA7XG5jb25zdCBpZEJyYWlucG9vbFAyMjR0MSA9IGAke2lkVmVyc2lvbk9uZX0uNmA7XG5jb25zdCBpZEJyYWlucG9vbFAyNTZyMSA9IGAke2lkVmVyc2lvbk9uZX0uN2A7XG5jb25zdCBpZEJyYWlucG9vbFAyNTZ0MSA9IGAke2lkVmVyc2lvbk9uZX0uOGA7XG5jb25zdCBpZEJyYWlucG9vbFAzMjByMSA9IGAke2lkVmVyc2lvbk9uZX0uOWA7XG5jb25zdCBpZEJyYWlucG9vbFAzMjB0MSA9IGAke2lkVmVyc2lvbk9uZX0uMTBgO1xuY29uc3QgaWRCcmFpbnBvb2xQMzg0cjEgPSBgJHtpZFZlcnNpb25PbmV9LjExYDtcbmNvbnN0IGlkQnJhaW5wb29sUDM4NHQxID0gYCR7aWRWZXJzaW9uT25lfS4xMmA7XG5jb25zdCBpZEJyYWlucG9vbFA1MTJyMSA9IGAke2lkVmVyc2lvbk9uZX0uMTNgO1xuY29uc3QgaWRCcmFpbnBvb2xQNTEydDEgPSBgJHtpZFZlcnNpb25PbmV9LjE0YDtcbmNvbnN0IGlkWDI1NTE5ID0gXCIxLjMuMTAxLjExMFwiO1xuY29uc3QgaWRYNDQ4ID0gXCIxLjMuMTAxLjExMVwiO1xuY29uc3QgaWRFZDI1NTE5ID0gXCIxLjMuMTAxLjExMlwiO1xuY29uc3QgaWRFZDQ0OCA9IFwiMS4zLjEwMS4xMTNcIjtcblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQWxnb3JpdGhtSWRlbnRpZmllcjogQWxnb3JpdGhtSWRlbnRpZmllcixcbiAgZ2V0IEN1cnZlUHJpdmF0ZUtleSAoKSB7IHJldHVybiBDdXJ2ZVByaXZhdGVLZXk7IH0sXG4gIEVjRHNhU2lnbmF0dXJlOiBFY0RzYVNpZ25hdHVyZSxcbiAgRWNQcml2YXRlS2V5OiBFY1ByaXZhdGVLZXksXG4gIGdldCBFY1B1YmxpY0tleSAoKSB7IHJldHVybiBFY1B1YmxpY0tleTsgfSxcbiAgZ2V0IEVkUHJpdmF0ZUtleSAoKSB7IHJldHVybiBFZFByaXZhdGVLZXk7IH0sXG4gIGdldCBFZFB1YmxpY0tleSAoKSB7IHJldHVybiBFZFB1YmxpY0tleTsgfSxcbiAgZ2V0IE9iamVjdElkZW50aWZpZXIgKCkgeyByZXR1cm4gT2JqZWN0SWRlbnRpZmllcjsgfSxcbiAgT25lQXN5bW1ldHJpY0tleTogT25lQXN5bW1ldHJpY0tleSxcbiAgUHJpdmF0ZUtleUluZm86IFByaXZhdGVLZXlJbmZvLFxuICBQdWJsaWNLZXlJbmZvOiBQdWJsaWNLZXlJbmZvLFxuICBSc2FQcml2YXRlS2V5OiBSc2FQcml2YXRlS2V5LFxuICBSc2FQdWJsaWNLZXk6IFJzYVB1YmxpY0tleSxcbiAgY29udmVydGVyczogaW5kZXgkMixcbiAgaWRCcmFpbnBvb2xQMTYwcjE6IGlkQnJhaW5wb29sUDE2MHIxLFxuICBpZEJyYWlucG9vbFAxNjB0MTogaWRCcmFpbnBvb2xQMTYwdDEsXG4gIGlkQnJhaW5wb29sUDE5MnIxOiBpZEJyYWlucG9vbFAxOTJyMSxcbiAgaWRCcmFpbnBvb2xQMTkydDE6IGlkQnJhaW5wb29sUDE5MnQxLFxuICBpZEJyYWlucG9vbFAyMjRyMTogaWRCcmFpbnBvb2xQMjI0cjEsXG4gIGlkQnJhaW5wb29sUDIyNHQxOiBpZEJyYWlucG9vbFAyMjR0MSxcbiAgaWRCcmFpbnBvb2xQMjU2cjE6IGlkQnJhaW5wb29sUDI1NnIxLFxuICBpZEJyYWlucG9vbFAyNTZ0MTogaWRCcmFpbnBvb2xQMjU2dDEsXG4gIGlkQnJhaW5wb29sUDMyMHIxOiBpZEJyYWlucG9vbFAzMjByMSxcbiAgaWRCcmFpbnBvb2xQMzIwdDE6IGlkQnJhaW5wb29sUDMyMHQxLFxuICBpZEJyYWlucG9vbFAzODRyMTogaWRCcmFpbnBvb2xQMzg0cjEsXG4gIGlkQnJhaW5wb29sUDM4NHQxOiBpZEJyYWlucG9vbFAzODR0MSxcbiAgaWRCcmFpbnBvb2xQNTEycjE6IGlkQnJhaW5wb29sUDUxMnIxLFxuICBpZEJyYWlucG9vbFA1MTJ0MTogaWRCcmFpbnBvb2xQNTEydDEsXG4gIGlkRWQyNTUxOTogaWRFZDI1NTE5LFxuICBpZEVkNDQ4OiBpZEVkNDQ4LFxuICBpZEVsbGlwdGljQ3VydmU6IGlkRWxsaXB0aWNDdXJ2ZSxcbiAgaWRTZWNwMjU2azE6IGlkU2VjcDI1NmsxLFxuICBpZFNlY3AyNTZyMTogaWRTZWNwMjU2cjEsXG4gIGlkU2VjcDM4NHIxOiBpZFNlY3AzODRyMSxcbiAgaWRTZWNwNTIxcjE6IGlkU2VjcDUyMXIxLFxuICBpZFZlcnNpb25PbmU6IGlkVmVyc2lvbk9uZSxcbiAgaWRYMjU1MTk6IGlkWDI1NTE5LFxuICBpZFg0NDg6IGlkWDQ0OFxufSk7XG5cbmNsYXNzIEVjQ3VydmVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHsgfVxuICAgIHN0YXRpYyByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIGNvbnN0IG9pZCA9IG5ldyBPYmplY3RJZGVudGlmaWVyKCk7XG4gICAgICAgIG9pZC52YWx1ZSA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHJhdyA9IGFzbjFTY2hlbWEuQXNuQ29udmVydC5zZXJpYWxpemUob2lkKTtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHtcbiAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICByYXcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWVzLnB1c2goaXRlbS5uYW1lKTtcbiAgICB9XG4gICAgc3RhdGljIGZpbmQobmFtZU9ySWQpIHtcbiAgICAgICAgbmFtZU9ySWQgPSBuYW1lT3JJZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBuYW1lT3JJZCB8fCBpdGVtLmlkLnRvVXBwZXJDYXNlKCkgPT09IG5hbWVPcklkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQobmFtZU9ySWQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5maW5kKG5hbWVPcklkKTtcbiAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgRUMgbmFtZWQgY3VydmUgJyR7bmFtZU9ySWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuRWNDdXJ2ZXMuaXRlbXMgPSBbXTtcbkVjQ3VydmVzLm5hbWVzID0gW107XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC0yNTZcIiwgaWQ6IGlkU2VjcDI1NnIxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC0zODRcIiwgaWQ6IGlkU2VjcDM4NHIxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiUC01MjFcIiwgaWQ6IGlkU2VjcDUyMXIxLCBzaXplOiA1MjEgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiSy0yNTZcIiwgaWQ6IGlkU2VjcDI1NmsxLCBzaXplOiAyNTYgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE2MHIxXCIsIGlkOiBpZEJyYWlucG9vbFAxNjByMSwgc2l6ZTogMTYwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAxNjB0MVwiLCBpZDogaWRCcmFpbnBvb2xQMTYwdDEsIHNpemU6IDE2MCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMTkycjFcIiwgaWQ6IGlkQnJhaW5wb29sUDE5MnIxLCBzaXplOiAxOTIgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDE5MnQxXCIsIGlkOiBpZEJyYWlucG9vbFAxOTJ0MSwgc2l6ZTogMTkyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyMjRyMVwiLCBpZDogaWRCcmFpbnBvb2xQMjI0cjEsIHNpemU6IDIyNCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMjI0dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDIyNHQxLCBzaXplOiAyMjQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDI1NnIxXCIsIGlkOiBpZEJyYWlucG9vbFAyNTZyMSwgc2l6ZTogMjU2IH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAyNTZ0MVwiLCBpZDogaWRCcmFpbnBvb2xQMjU2dDEsIHNpemU6IDI1NiB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzIwcjFcIiwgaWQ6IGlkQnJhaW5wb29sUDMyMHIxLCBzaXplOiAzMjAgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDMyMHQxXCIsIGlkOiBpZEJyYWlucG9vbFAzMjB0MSwgc2l6ZTogMzIwIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFAzODRyMVwiLCBpZDogaWRCcmFpbnBvb2xQMzg0cjEsIHNpemU6IDM4NCB9KTtcbkVjQ3VydmVzLnJlZ2lzdGVyKHsgbmFtZTogXCJicmFpbnBvb2xQMzg0dDFcIiwgaWQ6IGlkQnJhaW5wb29sUDM4NHQxLCBzaXplOiAzODQgfSk7XG5FY0N1cnZlcy5yZWdpc3Rlcih7IG5hbWU6IFwiYnJhaW5wb29sUDUxMnIxXCIsIGlkOiBpZEJyYWlucG9vbFA1MTJyMSwgc2l6ZTogNTEyIH0pO1xuRWNDdXJ2ZXMucmVnaXN0ZXIoeyBuYW1lOiBcImJyYWlucG9vbFA1MTJ0MVwiLCBpZDogaWRCcmFpbnBvb2xQNTEydDEsIHNpemU6IDUxMiB9KTtcblxuY2xhc3MgSG1hY1Byb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJDcnlwdG8ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkhNQUNcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl07XG4gICAgfVxuICAgIGdldERlZmF1bHRMZW5ndGgoYWxnTmFtZSkge1xuICAgICAgICBzd2l0Y2ggKGFsZ05hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XG4gICAgICAgICAgICBjYXNlIFwiU0hBLTI1NlwiOlxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDUxMjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFsZ29yaXRobSBuYW1lICcke2FsZ05hbWV9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIGlmIChcImxlbmd0aFwiIGluIGFsZ29yaXRobSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhbGdvcml0aG0ubGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxlbmd0aDogSXMgbm90IGEgTnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsZ29yaXRobS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJsZW5ndGg6IE51bWJlciBpcyBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRQYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgfVxufVxuXG5jbGFzcyBQYmtkZjJQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJQQktERjJcIjtcbiAgICAgICAgdGhpcy5oYXNoQWxnb3JpdGhtcyA9IFtcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCJdO1xuICAgICAgICB0aGlzLnVzYWdlcyA9IFtcImRlcml2ZUJpdHNcIiwgXCJkZXJpdmVLZXlcIl07XG4gICAgfVxuICAgIGNoZWNrQWxnb3JpdGhtUGFyYW1zKGFsZ29yaXRobSkge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaGFzaFwiKTtcbiAgICAgICAgdGhpcy5jaGVja0hhc2hBbGdvcml0aG0oYWxnb3JpdGhtLmhhc2gsIHRoaXMuaGFzaEFsZ29yaXRobXMpO1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwic2FsdFwiKTtcbiAgICAgICAgaWYgKCEoYWxnb3JpdGhtLnNhbHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoYWxnb3JpdGhtLnNhbHQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIml0ZXJhdGlvbnNcIik7XG4gICAgICAgIGlmICh0eXBlb2YgYWxnb3JpdGhtLml0ZXJhdGlvbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsZ29yaXRobS5pdGVyYXRpb25zIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvbnM6IElzIGxlc3MgdGhhbiAxXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyLmNoZWNrSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKGV4dHJhY3RhYmxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJleHRyYWN0YWJsZTogTXVzdCBiZSAnZmFsc2UnXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSEtERlwiO1xuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1wiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIl07XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW1wiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcbiAgICB9XG4gICAgY2hlY2tBbGdvcml0aG1QYXJhbXMoYWxnb3JpdGhtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJoYXNoXCIpO1xuICAgICAgICB0aGlzLmNoZWNrSGFzaEFsZ29yaXRobShhbGdvcml0aG0uaGFzaCwgdGhpcy5oYXNoQWxnb3JpdGhtcyk7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJzYWx0XCIpO1xuICAgICAgICBpZiAoIXB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UoYWxnb3JpdGhtLnNhbHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic2FsdDogSXMgbm90IG9mIHR5cGUgJyhBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcpJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRQcm9wZXJ0eShhbGdvcml0aG0sIFwiaW5mb1wiKTtcbiAgICAgICAgaWYgKCFwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGFsZ29yaXRobS5pbmZvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInNhbHQ6IElzIG5vdCBvZiB0eXBlICcoQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3KSdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIuY2hlY2tJbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpO1xuICAgICAgICBpZiAoZXh0cmFjdGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcImV4dHJhY3RhYmxlOiBNdXN0IGJlICdmYWxzZSdcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFNoYWtlUHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlckNyeXB0byB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XG4gICAgICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IDA7XG4gICAgfVxuICAgIGRpZ2VzdCguLi5hcmdzKSB7XG4gICAgICAgIGFyZ3NbMF0gPSB7IGxlbmd0aDogdGhpcy5kZWZhdWx0TGVuZ3RoLCAuLi5hcmdzWzBdIH07XG4gICAgICAgIHJldHVybiBzdXBlci5kaWdlc3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGNoZWNrRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xuICAgICAgICBzdXBlci5jaGVja0RpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBhbGdvcml0aG0ubGVuZ3RoIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGVuZ3RoOiBJcyBub3QgYSBOdW1iZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGg6IElzIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZTEyOFByb3ZpZGVyIGV4dGVuZHMgU2hha2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwic2hha2UxMjhcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gMTY7XG4gICAgfVxufVxuXG5jbGFzcyBTaGFrZTI1NlByb3ZpZGVyIGV4dGVuZHMgU2hha2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwic2hha2UyNTZcIjtcbiAgICAgICAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gMzI7XG4gICAgfVxufVxuXG5jbGFzcyBDcnlwdG8ge1xuICAgIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICAgICAgcmV0dXJuIFwiQ3J5cHRvXCI7XG4gICAgfVxuICAgIHJhbmRvbVVVSUQoKSB7XG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpO1xuICAgICAgICBiWzZdID0gKGJbNl0gJiAweDBmKSB8IDB4NDA7XG4gICAgICAgIGJbOF0gPSAoYls4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgY29uc3QgdXVpZCA9IHB2dHN1dGlscy5Db252ZXJ0LlRvSGV4KGIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHt1dWlkLnN1YnN0cmluZygwLCA4KX0tJHt1dWlkLnN1YnN0cmluZyg4LCAxMil9LSR7dXVpZC5zdWJzdHJpbmcoMTIsIDE2KX0tJHt1dWlkLnN1YnN0cmluZygxNiwgMjApfS0ke3V1aWQuc3Vic3RyaW5nKDIwKX1gO1xuICAgIH1cbn1cblxuY2xhc3MgUHJvdmlkZXJTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgIH1cbiAgICBnZXQoYWxnb3JpdGhtTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1thbGdvcml0aG1OYW1lLnRvTG93ZXJDYXNlKCldIHx8IG51bGw7XG4gICAgfVxuICAgIHNldChwcm92aWRlcikge1xuICAgICAgICB0aGlzLml0ZW1zW3Byb3ZpZGVyLm5hbWUudG9Mb3dlckNhc2UoKV0gPSBwcm92aWRlcjtcbiAgICB9XG4gICAgcmVtb3ZlQXQoYWxnb3JpdGhtTmFtZSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0KGFsZ29yaXRobU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmIChwcm92aWRlcikge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaXRlbXNbYWxnb3JpdGhtTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICBoYXMobmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldChuYW1lKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuaXRlbXMpLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGFsZ29yaXRobXMoKSB7XG4gICAgICAgIGNvbnN0IGFsZ29yaXRobXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLml0ZW1zW2tleV07XG4gICAgICAgICAgICBhbGdvcml0aG1zLnB1c2gocHJvdmlkZXIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsZ29yaXRobXMuc29ydCgpO1xuICAgIH1cbn1cblxuY2xhc3MgU3VidGxlQ3J5cHRvIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgUHJvdmlkZXJTdG9yYWdlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0hhc2hlZEFsZ29yaXRobShkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICAmJiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgJiYgXCJuYW1lXCIgaW4gZGF0YVxuICAgICAgICAgICAgJiYgXCJoYXNoXCIgaW4gZGF0YVxuICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgIHJldHVybiBcIlN1YnRsZUNyeXB0b1wiO1xuICAgIH1cbiAgICBhc3luYyBkaWdlc3QoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMiwgXCJkaWdlc3RcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGRhdGEsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZGlnZXN0KHByZXBhcmVkQWxnb3JpdGhtLCBwcmVwYXJlZERhdGEsIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZ2VuZXJhdGVLZXlcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmdlbmVyYXRlS2V5KHsgLi4ucHJlcGFyZWRBbGdvcml0aG0sIG5hbWU6IHByb3ZpZGVyLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgc2lnbiguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcInNpZ25cIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnNpZ24oeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDQsIFwidmVyaWZ5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFNpZ25hdHVyZSA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmUpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLnZlcmlmeSh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWRTaWduYXR1cmUsIHByZXBhcmVkRGF0YSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZW5jcnlwdCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCAzLCBcImVuY3J5cHRcIik7XG4gICAgICAgIGNvbnN0IFthbGdvcml0aG0sIGtleSwgZGF0YSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmVuY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBrZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogdHJ1ZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBkZWNyeXB0KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDMsIFwiZGVjcnlwdFwiKTtcbiAgICAgICAgY29uc3QgW2FsZ29yaXRobSwga2V5LCBkYXRhLCAuLi5wYXJhbXNdID0gYXJncztcbiAgICAgICAgdGhpcy5jaGVja0NyeXB0b0tleShrZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoZGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvdmlkZXIuZGVjcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIGtleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiB0cnVlIH0sIC4uLnBhcmFtcyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGRlcml2ZUJpdHMoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMywgXCJkZXJpdmVCaXRzXCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICB0aGlzLmNoZWNrQ3J5cHRvS2V5KGJhc2VLZXkpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmRlcml2ZUJpdHMoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBiYXNlS2V5LCBsZW5ndGgsIHsga2V5VXNhZ2U6IHRydWUgfSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgZGVyaXZlS2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDUsIFwiZGVyaXZlS2V5XCIpO1xuICAgICAgICBjb25zdCBbYWxnb3JpdGhtLCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcywgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIGNvbnN0IHByZXBhcmVkRGVyaXZlZEtleVR5cGUgPSB0aGlzLnByZXBhcmVBbGdvcml0aG0oZGVyaXZlZEtleVR5cGUpO1xuICAgICAgICBjb25zdCBpbXBvcnRQcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWREZXJpdmVkS2V5VHlwZS5uYW1lKTtcbiAgICAgICAgaW1wb3J0UHJvdmlkZXIuY2hlY2tEZXJpdmVkS2V5UGFyYW1zKHByZXBhcmVkRGVyaXZlZEtleVR5cGUpO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIHByb3ZpZGVyLmNoZWNrQ3J5cHRvS2V5KGJhc2VLZXksIFwiZGVyaXZlS2V5XCIpO1xuICAgICAgICBjb25zdCBkZXJpdmVkQml0cyA9IGF3YWl0IHByb3ZpZGVyLmRlcml2ZUJpdHMoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBiYXNlS2V5LCBkZXJpdmVkS2V5VHlwZS5sZW5ndGggfHwgNTEyLCB7IGtleVVzYWdlOiBmYWxzZSB9LCAuLi5wYXJhbXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRLZXkoXCJyYXdcIiwgZGVyaXZlZEJpdHMsIGRlcml2ZWRLZXlUeXBlLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBleHBvcnRLZXkoLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoZWNrUmVxdWlyZWRBcmd1bWVudHMoYXJncywgMiwgXCJleHBvcnRLZXlcIik7XG4gICAgICAgIGNvbnN0IFtmb3JtYXQsIGtleSwgLi4ucGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2hlY2tDcnlwdG9LZXkoa2V5KTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGtleS5hbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb3ZpZGVyLmV4cG9ydEtleShmb3JtYXQsIGtleSwgLi4ucGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgaW1wb3J0S2V5KC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkQXJndW1lbnRzKGFyZ3MsIDUsIFwiaW1wb3J0S2V5XCIpO1xuICAgICAgICBjb25zdCBbZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLnBhcmFtc10gPSBhcmdzO1xuICAgICAgICBjb25zdCBwcmVwYXJlZEFsZ29yaXRobSA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGlmIChbXCJwa2NzOFwiLCBcInNwa2lcIiwgXCJyYXdcIl0uaW5kZXhPZihmb3JtYXQpICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGtleURhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmltcG9ydEtleShmb3JtYXQsIHByZXBhcmVkRGF0YSwgeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFrZXlEYXRhLmt0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBJcyBub3QgSlNPTlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXIuaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5wYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyB3cmFwS2V5KGZvcm1hdCwga2V5LCB3cmFwcGluZ0tleSwgd3JhcEFsZ29yaXRobSwgLi4uYXJncykge1xuICAgICAgICBsZXQga2V5RGF0YSA9IGF3YWl0IHRoaXMuZXhwb3J0S2V5KGZvcm1hdCwga2V5LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJqd2tcIikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KGtleURhdGEpO1xuICAgICAgICAgICAga2V5RGF0YSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21VdGY4U3RyaW5nKGpzb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBhcmVkQWxnb3JpdGhtID0gdGhpcy5wcmVwYXJlQWxnb3JpdGhtKHdyYXBBbGdvcml0aG0pO1xuICAgICAgICBjb25zdCBwcmVwYXJlZERhdGEgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoa2V5RGF0YSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcmVwYXJlZEFsZ29yaXRobS5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyLmVuY3J5cHQoeyAuLi5wcmVwYXJlZEFsZ29yaXRobSwgbmFtZTogcHJvdmlkZXIubmFtZSB9LCB3cmFwcGluZ0tleSwgcHJlcGFyZWREYXRhLCB7IGtleVVzYWdlOiBmYWxzZSB9LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgYXN5bmMgdW53cmFwS2V5KGZvcm1hdCwgd3JhcHBlZEtleSwgdW53cmFwcGluZ0tleSwgdW53cmFwQWxnb3JpdGhtLCB1bndyYXBwZWRLZXlBbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB0aGlzLnByZXBhcmVBbGdvcml0aG0odW53cmFwQWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcHJlcGFyZWREYXRhID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHdyYXBwZWRLZXkpO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJlcGFyZWRBbGdvcml0aG0ubmFtZSk7XG4gICAgICAgIGxldCBrZXlEYXRhID0gYXdhaXQgcHJvdmlkZXIuZGVjcnlwdCh7IC4uLnByZXBhcmVkQWxnb3JpdGhtLCBuYW1lOiBwcm92aWRlci5uYW1lIH0sIHVud3JhcHBpbmdLZXksIHByZXBhcmVkRGF0YSwgeyBrZXlVc2FnZTogZmFsc2UgfSwgLi4uYXJncyk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiandrXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAga2V5RGF0YSA9IEpTT04ucGFyc2UocHZ0c3V0aWxzLkNvbnZlcnQuVG9VdGY4U3RyaW5nKGtleURhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKFwid3JhcHBlZEtleTogSXMgbm90IGEgSlNPTlwiKTtcbiAgICAgICAgICAgICAgICBlcnJvci5pbnRlcm5hbCA9IGU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgdW53cmFwcGVkS2V5QWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgY2hlY2tSZXF1aXJlZEFyZ3VtZW50cyhhcmdzLCBzaXplLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICcke21ldGhvZE5hbWV9JyBvbiAnU3VidGxlQ3J5cHRvJzogJHtzaXplfSBhcmd1bWVudHMgcmVxdWlyZWQsIGJ1dCBvbmx5ICR7YXJncy5sZW5ndGh9IHByZXNlbnRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlQWxnb3JpdGhtKGFsZ29yaXRobSkge1xuICAgICAgICBpZiAodHlwZW9mIGFsZ29yaXRobSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhbGdvcml0aG0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChTdWJ0bGVDcnlwdG8uaXNIYXNoZWRBbGdvcml0aG0oYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRBbGdvcml0aG0gPSB7IC4uLmFsZ29yaXRobSB9O1xuICAgICAgICAgICAgcHJlcGFyZWRBbGdvcml0aG0uaGFzaCA9IHRoaXMucHJlcGFyZUFsZ29yaXRobShhbGdvcml0aG0uaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gcHJlcGFyZWRBbGdvcml0aG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uYWxnb3JpdGhtIH07XG4gICAgfVxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbGdvcml0aG1FcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9XG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIENyeXB0b0tleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEtleSBpcyBub3Qgb2YgdHlwZSAnQ3J5cHRvS2V5J2ApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY29udmVydGVyczogaW5kZXgkM1xufSk7XG5cbmNvbnN0IFJFUVVJUkVEX0ZJRUxEUyA9IFtcImNydlwiLCBcImVcIiwgXCJrXCIsIFwia3R5XCIsIFwiblwiLCBcInhcIiwgXCJ5XCJdO1xuY2xhc3MgSndrVXRpbHMge1xuICAgIHN0YXRpYyBhc3luYyB0aHVtYnByaW50KGhhc2gsIGp3aywgY3J5cHRvKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmZvcm1hdChqd2ssIHRydWUpO1xuICAgICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kaWdlc3QoaGFzaCwgcHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJpbmFyeShKU09OLnN0cmluZ2lmeShkYXRhKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZm9ybWF0KGp3aywgcmVtb3ZlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJlcyA9IE9iamVjdC5lbnRyaWVzKGp3ayk7XG4gICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5maWx0ZXIobyA9PiBSRVFVSVJFRF9GSUVMRFMuaW5jbHVkZXMob1swXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IHJlcy5zb3J0KChba2V5QV0sIFtrZXlCXSkgPT4ga2V5QSA+IGtleUIgPyAxIDoga2V5QSA8IGtleUIgPyAtMSA6IDApO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHJlcyk7XG4gICAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXI7IH1cbn0pO1xuZXhwb3J0cy5BZXNDYmNQcm92aWRlciA9IEFlc0NiY1Byb3ZpZGVyO1xuZXhwb3J0cy5BZXNDbWFjUHJvdmlkZXIgPSBBZXNDbWFjUHJvdmlkZXI7XG5leHBvcnRzLkFlc0N0clByb3ZpZGVyID0gQWVzQ3RyUHJvdmlkZXI7XG5leHBvcnRzLkFlc0VjYlByb3ZpZGVyID0gQWVzRWNiUHJvdmlkZXI7XG5leHBvcnRzLkFlc0djbVByb3ZpZGVyID0gQWVzR2NtUHJvdmlkZXI7XG5leHBvcnRzLkFlc0t3UHJvdmlkZXIgPSBBZXNLd1Byb3ZpZGVyO1xuZXhwb3J0cy5BZXNQcm92aWRlciA9IEFlc1Byb3ZpZGVyO1xuZXhwb3J0cy5BbGdvcml0aG1FcnJvciA9IEFsZ29yaXRobUVycm9yO1xuZXhwb3J0cy5DcnlwdG8gPSBDcnlwdG87XG5leHBvcnRzLkNyeXB0b0Vycm9yID0gQ3J5cHRvRXJyb3I7XG5leHBvcnRzLkNyeXB0b0tleSA9IENyeXB0b0tleTtcbmV4cG9ydHMuRGVzUHJvdmlkZXIgPSBEZXNQcm92aWRlcjtcbmV4cG9ydHMuRWNDdXJ2ZXMgPSBFY0N1cnZlcztcbmV4cG9ydHMuRWNVdGlscyA9IEVjVXRpbHM7XG5leHBvcnRzLkVjZGhFc1Byb3ZpZGVyID0gRWNkaEVzUHJvdmlkZXI7XG5leHBvcnRzLkVjZGhQcm92aWRlciA9IEVjZGhQcm92aWRlcjtcbmV4cG9ydHMuRWNkc2FQcm92aWRlciA9IEVjZHNhUHJvdmlkZXI7XG5leHBvcnRzLkVkRHNhUHJvdmlkZXIgPSBFZERzYVByb3ZpZGVyO1xuZXhwb3J0cy5FbGxpcHRpY1Byb3ZpZGVyID0gRWxsaXB0aWNQcm92aWRlcjtcbmV4cG9ydHMuSGtkZlByb3ZpZGVyID0gSGtkZlByb3ZpZGVyO1xuZXhwb3J0cy5IbWFjUHJvdmlkZXIgPSBIbWFjUHJvdmlkZXI7XG5leHBvcnRzLkp3a1V0aWxzID0gSndrVXRpbHM7XG5leHBvcnRzLk9wZXJhdGlvbkVycm9yID0gT3BlcmF0aW9uRXJyb3I7XG5leHBvcnRzLlBia2RmMlByb3ZpZGVyID0gUGJrZGYyUHJvdmlkZXI7XG5leHBvcnRzLlBlbUNvbnZlcnRlciA9IFBlbUNvbnZlcnRlcjtcbmV4cG9ydHMuUHJvdmlkZXJDcnlwdG8gPSBQcm92aWRlckNyeXB0bztcbmV4cG9ydHMuUHJvdmlkZXJTdG9yYWdlID0gUHJvdmlkZXJTdG9yYWdlO1xuZXhwb3J0cy5SZXF1aXJlZFByb3BlcnR5RXJyb3IgPSBSZXF1aXJlZFByb3BlcnR5RXJyb3I7XG5leHBvcnRzLlJzYU9hZXBQcm92aWRlciA9IFJzYU9hZXBQcm92aWRlcjtcbmV4cG9ydHMuUnNhUHJvdmlkZXIgPSBSc2FQcm92aWRlcjtcbmV4cG9ydHMuUnNhUHNzUHJvdmlkZXIgPSBSc2FQc3NQcm92aWRlcjtcbmV4cG9ydHMuUnNhU3NhUHJvdmlkZXIgPSBSc2FTc2FQcm92aWRlcjtcbmV4cG9ydHMuU2hha2UxMjhQcm92aWRlciA9IFNoYWtlMTI4UHJvdmlkZXI7XG5leHBvcnRzLlNoYWtlMjU2UHJvdmlkZXIgPSBTaGFrZTI1NlByb3ZpZGVyO1xuZXhwb3J0cy5TaGFrZVByb3ZpZGVyID0gU2hha2VQcm92aWRlcjtcbmV4cG9ydHMuU3VidGxlQ3J5cHRvID0gU3VidGxlQ3J5cHRvO1xuZXhwb3J0cy5VbnN1cHBvcnRlZE9wZXJhdGlvbkVycm9yID0gVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcjtcbmV4cG9ydHMuYXNuMSA9IGluZGV4JDE7XG5leHBvcnRzLmlzSldLID0gaXNKV0s7XG5leHBvcnRzLmpzb24gPSBpbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webcrypto-core/build/webcrypto-core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ var extendStatics = function(d, b) {\n    extendStatics = Object.setPrototypeOf || ({\n        __proto__: []\n    }) instanceof Array && function(d, b) {\n        d.__proto__ = b;\n    } || function(d, b) {\n        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n        this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n    return function(target, key) {\n        decorator(target, key, paramIndex);\n    };\n}\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) {\n        if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n        return f;\n    }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for(var i = decorators.length - 1; i >= 0; i--){\n        var context = {};\n        for(var p in contextIn)context[p] = p === \"access\" ? {} : contextIn[p];\n        for(var p in contextIn.access)context.access[p] = contextIn.access[p];\n        context.addInitializer = function(f) {\n            if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n            extraInitializers.push(accept(f || null));\n        };\n        var result = (0, decorators[i])(kind === \"accessor\" ? {\n            get: descriptor.get,\n            set: descriptor.set\n        } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        } else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n}\n;\nfunction __runInitializers(thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for(var i = 0; i < initializers.length; i++){\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n}\n;\nfunction __propKey(x) {\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\n}\n;\nfunction __setFunctionName(f, name, prefix) {\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n    return Object.defineProperty(f, \"name\", {\n        configurable: true,\n        value: prefix ? \"\".concat(prefix, \" \", name) : name\n    });\n}\n;\nfunction __metadata(metadataKey, metadataValue) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __generator(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __createBinding = Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n};\nfunction __exportStar(m, o) {\n    for(var p in m)if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\n/** @deprecated */ function __spread() {\n    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));\n    return ar;\n}\n/** @deprecated */ function __spreadArrays() {\n    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;\n    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];\n    return r;\n}\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: false\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\n;\nvar __setModuleDefault = Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n};\nfunction __importStar(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n}\nfunction __importDefault(mod) {\n    return mod && mod.__esModule ? mod : {\n        default: mod\n    };\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldIn(state, receiver) {\n    if (receiver === null || typeof receiver !== \"object\" && typeof receiver !== \"function\") throw new TypeError(\"Cannot use 'in' operator on non-object\");\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\nfunction __addDisposableResource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction __disposeResources(env) {\n    function fail(e) {\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n        env.hasError = true;\n    }\n    function next() {\n        while(env.stack.length){\n            var rec = env.stack.pop();\n            try {\n                var result = rec.dispose && rec.dispose.call(rec.value);\n                if (rec.async) return Promise.resolve(result).then(next, function(e) {\n                    fail(e);\n                    return next();\n                });\n            } catch (e) {\n                fail(e);\n            }\n        }\n        if (env.hasError) throw env.error;\n    }\n    return next();\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    __extends,\n    __assign,\n    __rest,\n    __decorate,\n    __param,\n    __metadata,\n    __awaiter,\n    __generator,\n    __createBinding,\n    __exportStar,\n    __values,\n    __read,\n    __spread,\n    __spreadArrays,\n    __spreadArray,\n    __await,\n    __asyncGenerator,\n    __asyncDelegator,\n    __asyncValues,\n    __makeTemplateObject,\n    __importStar,\n    __importDefault,\n    __classPrivateFieldGet,\n    __classPrivateFieldSet,\n    __classPrivateFieldIn,\n    __addDisposableResource,\n    __disposeResources\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsb0RBQW9ELEdBRXBELElBQUlBLGdCQUFnQixTQUFTQyxDQUFDLEVBQUVDLENBQUM7SUFDL0JGLGdCQUFnQkcsT0FBT0MsY0FBYyxJQUNoQztRQUFFQyxXQUFXLEVBQUU7SUFBQyxjQUFhQyxTQUFTLFNBQVVMLENBQUMsRUFBRUMsQ0FBQztRQUFJRCxFQUFFSSxTQUFTLEdBQUdIO0lBQUcsS0FDMUUsU0FBVUQsQ0FBQyxFQUFFQyxDQUFDO1FBQUksSUFBSyxJQUFJSyxLQUFLTCxFQUFHLElBQUlDLE9BQU9LLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFBRTtJQUNwRyxPQUFPUCxjQUFjQyxHQUFHQztBQUMxQjtBQUVPLFNBQVNTLFVBQVVWLENBQUMsRUFBRUMsQ0FBQztJQUM1QixJQUFJLE9BQU9BLE1BQU0sY0FBY0EsTUFBTSxNQUNqQyxNQUFNLElBQUlVLFVBQVUseUJBQXlCQyxPQUFPWCxLQUFLO0lBQzdERixjQUFjQyxHQUFHQztJQUNqQixTQUFTWTtRQUFPLElBQUksQ0FBQ0MsV0FBVyxHQUFHZDtJQUFHO0lBQ3RDQSxFQUFFTyxTQUFTLEdBQUdOLE1BQU0sT0FBT0MsT0FBT2EsTUFBTSxDQUFDZCxLQUFNWSxDQUFBQSxHQUFHTixTQUFTLEdBQUdOLEVBQUVNLFNBQVMsRUFBRSxJQUFJTSxJQUFHO0FBQ3BGO0FBRU8sSUFBSUcsV0FBVztJQUNwQkEsV0FBV2QsT0FBT2UsTUFBTSxJQUFJLFNBQVNELFNBQVNFLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlD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LENBQUM7UUFDYnFJLElBQUl0QyxLQUFLLEdBQUdzQyxJQUFJWSxRQUFRLEdBQUcsSUFBSVAsaUJBQWlCMUksR0FBR3FJLElBQUl0QyxLQUFLLEVBQUUsOENBQThDL0Y7UUFDNUdxSSxJQUFJWSxRQUFRLEdBQUc7SUFDakI7SUFDQSxTQUFTaEY7UUFDUCxNQUFPb0UsSUFBSUksS0FBSyxDQUFDNUksTUFBTSxDQUFFO1lBQ3ZCLElBQUlxSixNQUFNYixJQUFJSSxLQUFLLENBQUN4RCxHQUFHO1lBQ3ZCLElBQUk7Z0JBQ0YsSUFBSTlDLFNBQVMrRyxJQUFJWCxPQUFPLElBQUlXLElBQUlYLE9BQU8sQ0FBQ3hKLElBQUksQ0FBQ21LLElBQUl4RyxLQUFLO2dCQUN0RCxJQUFJd0csSUFBSVosS0FBSyxFQUFFLE9BQU96RSxRQUFRRCxPQUFPLENBQUN6QixRQUFRZ0MsSUFBSSxDQUFDRixNQUFNLFNBQVNqRSxDQUFDO29CQUFJZ0osS0FBS2hKO29CQUFJLE9BQU9pRTtnQkFBUTtZQUNqRyxFQUNBLE9BQU9qRSxHQUFHO2dCQUNOZ0osS0FBS2hKO1lBQ1Q7UUFDRjtRQUNBLElBQUlxSSxJQUFJWSxRQUFRLEVBQUUsTUFBTVosSUFBSXRDLEtBQUs7SUFDbkM7SUFDQSxPQUFPOUI7QUFDVDtBQUVBLGlFQUFlO0lBQ2JqRjtJQUNBTTtJQUNBUztJQUNBSztJQUNBVztJQUNBb0M7SUFDQUk7SUFDQWE7SUFDQWM7SUFDQVM7SUFDQUM7SUFDQUM7SUFDQUc7SUFDQUM7SUFDQUs7SUFDQU07SUFDQUM7SUFDQU87SUFDQUM7SUFDQUM7SUFDQUk7SUFDQUU7SUFDQUU7SUFDQUk7SUFDQUM7SUFDQUM7SUFDQVc7QUFDRixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanM/NGVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cblxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cblxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5cbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcbiAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICB0W3BdID0gc1twXTtcbiAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICB9XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2VzRGVjb3JhdGUoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcbiAgZnVuY3Rpb24gYWNjZXB0KGYpIHsgaWYgKGYgIT09IHZvaWQgMCAmJiB0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRnVuY3Rpb24gZXhwZWN0ZWRcIik7IHJldHVybiBmOyB9XG4gIHZhciBraW5kID0gY29udGV4dEluLmtpbmQsIGtleSA9IGtpbmQgPT09IFwiZ2V0dGVyXCIgPyBcImdldFwiIDoga2luZCA9PT0gXCJzZXR0ZXJcIiA/IFwic2V0XCIgOiBcInZhbHVlXCI7XG4gIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xuICB2YXIgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JJbiB8fCAodGFyZ2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGNvbnRleHRJbi5uYW1lKSA6IHt9KTtcbiAgdmFyIF8sIGRvbmUgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbikgY29udGV4dFtwXSA9IHAgPT09IFwiYWNjZXNzXCIgPyB7fSA6IGNvbnRleHRJbltwXTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xuICAgICAgY29udGV4dC5hZGRJbml0aWFsaXplciA9IGZ1bmN0aW9uIChmKSB7IGlmIChkb25lKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCBpbml0aWFsaXplcnMgYWZ0ZXIgZGVjb3JhdGlvbiBoYXMgY29tcGxldGVkXCIpOyBleHRyYUluaXRpYWxpemVycy5wdXNoKGFjY2VwdChmIHx8IG51bGwpKTsgfTtcbiAgICAgIHZhciByZXN1bHQgPSAoMCwgZGVjb3JhdG9yc1tpXSkoa2luZCA9PT0gXCJhY2Nlc3NvclwiID8geyBnZXQ6IGRlc2NyaXB0b3IuZ2V0LCBzZXQ6IGRlc2NyaXB0b3Iuc2V0IH0gOiBkZXNjcmlwdG9yW2tleV0sIGNvbnRleHQpO1xuICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LnNldCkpIGRlc2NyaXB0b3Iuc2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuaW5pdCkpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoXyA9IGFjY2VwdChyZXN1bHQpKSB7XG4gICAgICAgICAgaWYgKGtpbmQgPT09IFwiZmllbGRcIikgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xuICAgICAgfVxuICB9XG4gIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcbiAgZG9uZSA9IHRydWU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19ydW5Jbml0aWFsaXplcnModGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xuICB2YXIgdXNlVmFsdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbml0aWFsaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcbiAgfVxuICByZXR1cm4gdXNlVmFsdWUgPyB2YWx1ZSA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Byb3BLZXkoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwic3ltYm9sXCIgPyB4IDogXCJcIi5jb25jYXQoeCk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19zZXRGdW5jdGlvbk5hbWUoZiwgbmFtZSwgcHJlZml4KSB7XG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzeW1ib2xcIikgbmFtZSA9IG5hbWUuZGVzY3JpcHRpb24gPyBcIltcIi5jb25jYXQobmFtZS5kZXNjcmlwdGlvbiwgXCJdXCIpIDogXCJcIjtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xuICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XG4gIHZhciBpLCBwO1xuICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBmYWxzZSB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICByZXR1cm4gY29va2VkO1xufTtcblxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlO1xuICAgIGlmIChhc3luYykge1xuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0Rpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNEaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuZGlzcG9zZV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICBlbnYuc3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwgZGlzcG9zZTogZGlzcG9zZSwgYXN5bmM6IGFzeW5jIH0pO1xuICB9XG4gIGVsc2UgaWYgKGFzeW5jKSB7XG4gICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBfU3VwcHJlc3NlZEVycm9yID0gdHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGlzcG9zZVJlc291cmNlcyhlbnYpIHtcbiAgZnVuY3Rpb24gZmFpbChlKSB7XG4gICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xuICAgIGVudi5oYXNFcnJvciA9IHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xuICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWMuZGlzcG9zZSAmJiByZWMuZGlzcG9zZS5jYWxsKHJlYy52YWx1ZSk7XG4gICAgICAgIGlmIChyZWMuYXN5bmMpIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKG5leHQsIGZ1bmN0aW9uKGUpIHsgZmFpbChlKTsgcmV0dXJuIG5leHQoKTsgfSk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9fZXh0ZW5kcyxcbiAgX19hc3NpZ24sXG4gIF9fcmVzdCxcbiAgX19kZWNvcmF0ZSxcbiAgX19wYXJhbSxcbiAgX19tZXRhZGF0YSxcbiAgX19hd2FpdGVyLFxuICBfX2dlbmVyYXRvcixcbiAgX19jcmVhdGVCaW5kaW5nLFxuICBfX2V4cG9ydFN0YXIsXG4gIF9fdmFsdWVzLFxuICBfX3JlYWQsXG4gIF9fc3ByZWFkLFxuICBfX3NwcmVhZEFycmF5cyxcbiAgX19zcHJlYWRBcnJheSxcbiAgX19hd2FpdCxcbiAgX19hc3luY0dlbmVyYXRvcixcbiAgX19hc3luY0RlbGVnYXRvcixcbiAgX19hc3luY1ZhbHVlcyxcbiAgX19tYWtlVGVtcGxhdGVPYmplY3QsXG4gIF9faW1wb3J0U3RhcixcbiAgX19pbXBvcnREZWZhdWx0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxuICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4sXG4gIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlLFxuICBfX2Rpc3Bvc2VSZXNvdXJjZXMsXG59O1xuIl0sIm5hbWVzIjpbImV4dGVuZFN0YXRpY3MiLCJkIiwiYiIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQXJyYXkiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19leHRlbmRzIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiX18iLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsIl9fYXNzaWduIiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFwcGx5IiwiX19yZXN0IiwiZSIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiZGVmaW5lUHJvcGVydHkiLCJfX3BhcmFtIiwicGFyYW1JbmRleCIsImRlY29yYXRvciIsIl9fZXNEZWNvcmF0ZSIsImN0b3IiLCJkZXNjcmlwdG9ySW4iLCJjb250ZXh0SW4iLCJpbml0aWFsaXplcnMiLCJleHRyYUluaXRpYWxpemVycyIsImFjY2VwdCIsImYiLCJraW5kIiwiZGVzY3JpcHRvciIsIm5hbWUiLCJfIiwiZG9uZSIsImNvbnRleHQiLCJhY2Nlc3MiLCJhZGRJbml0aWFsaXplciIsInB1c2giLCJyZXN1bHQiLCJnZXQiLCJzZXQiLCJpbml0IiwidW5zaGlmdCIsIl9fcnVuSW5pdGlhbGl6ZXJzIiwidGhpc0FyZyIsInZhbHVlIiwidXNlVmFsdWUiLCJfX3Byb3BLZXkiLCJ4IiwiY29uY2F0IiwiX19zZXRGdW5jdGlvbk5hbWUiLCJwcmVmaXgiLCJkZXNjcmlwdGlvbiIsImNvbmZpZ3VyYWJsZSIsIl9fbWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJtZXRhZGF0YSIsIl9fYXdhaXRlciIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJ0aGVuIiwiX19nZW5lcmF0b3IiLCJib2R5IiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwidiIsIm9wIiwicG9wIiwiX19jcmVhdGVCaW5kaW5nIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiX19leHBvcnRTdGFyIiwiX192YWx1ZXMiLCJfX3JlYWQiLCJhciIsImVycm9yIiwiX19zcHJlYWQiLCJfX3NwcmVhZEFycmF5cyIsImlsIiwiYSIsImoiLCJqbCIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwibCIsInNsaWNlIiwiX19hd2FpdCIsIl9fYXN5bmNHZW5lcmF0b3IiLCJhc3luY0l0ZXJhdG9yIiwicSIsInJlc3VtZSIsInNldHRsZSIsImZ1bGZpbGwiLCJzaGlmdCIsIl9fYXN5bmNEZWxlZ2F0b3IiLCJfX2FzeW5jVmFsdWVzIiwiX19tYWtlVGVtcGxhdGVPYmplY3QiLCJjb29rZWQiLCJyYXciLCJfX3NldE1vZHVsZURlZmF1bHQiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2ltcG9ydERlZmF1bHQiLCJkZWZhdWx0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJoYXMiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwiX19jbGFzc1ByaXZhdGVGaWVsZEluIiwiX19hZGREaXNwb3NhYmxlUmVzb3VyY2UiLCJlbnYiLCJhc3luYyIsImRpc3Bvc2UiLCJhc3luY0Rpc3Bvc2UiLCJzdGFjayIsIl9TdXBwcmVzc2VkRXJyb3IiLCJTdXBwcmVzc2VkRXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwiX19kaXNwb3NlUmVzb3VyY2VzIiwiZmFpbCIsImhhc0Vycm9yIiwicmVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViY3J5cHRvLWNvcmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ2pGLHdCQUF3QjtBQUN4QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRU87QUFDUDtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsY0FBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7O0FBRU87QUFDUCxrQ0FBa0M7QUFDbEM7O0FBRU87QUFDUCx1QkFBdUIsdUZBQXVGO0FBQzlHO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLDhDQUE4Qyx5RkFBeUY7QUFDdkksOERBQThELDJDQUEyQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSw0Q0FBNEMseUVBQXlFO0FBQ3JIOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQLDBCQUEwQiwrREFBK0QsaUJBQWlCO0FBQzFHO0FBQ0Esa0NBQWtDLE1BQU0s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ZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL29zcC8uL25vZGVfbW9kdWxlcy93ZWJjcnlwdG8tY29yZS9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2Lm1qcz8xY2EyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICB9XG59XG5cbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XG4gIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcbiAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgIH1cbiAgfTtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcbiAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICBpZiAoIW0pIHJldHVybiBvO1xuICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgdHJ5IHtcbiAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICB9XG4gIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICB9XG4gICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgfVxuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xuICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcbiAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcbiAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgIHJba10gPSBhW2pdO1xuICByZXR1cm4gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xuICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcbiAgdmFyIGksIHA7XG4gIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gIHJldHVybiBjb29rZWQ7XG59O1xuXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcbiAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xuICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcbiAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlKGVudiwgdmFsdWUsIGFzeW5jKSB7XG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XG4gICAgdmFyIGRpc3Bvc2U7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG4gICAgfVxuICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuZGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5kaXNwb3NlIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qgbm90IGRpc3Bvc2FibGUuXCIpO1xuICAgIGVudi5zdGFjay5wdXNoKHsgdmFsdWU6IHZhbHVlLCBkaXNwb3NlOiBkaXNwb3NlLCBhc3luYzogYXN5bmMgfSk7XG4gIH1cbiAgZWxzZSBpZiAoYXN5bmMpIHtcbiAgICBlbnYuc3RhY2sucHVzaCh7IGFzeW5jOiB0cnVlIH0pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIF9TdXBwcmVzc2VkRXJyb3IgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19kaXNwb3NlUmVzb3VyY2VzKGVudikge1xuICBmdW5jdGlvbiBmYWlsKGUpIHtcbiAgICBlbnYuZXJyb3IgPSBlbnYuaGFzRXJyb3IgPyBuZXcgX1N1cHByZXNzZWRFcnJvcihlLCBlbnYuZXJyb3IsIFwiQW4gZXJyb3Igd2FzIHN1cHByZXNzZWQgZHVyaW5nIGRpc3Bvc2FsLlwiKSA6IGU7XG4gICAgZW52Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHdoaWxlIChlbnYuc3RhY2subGVuZ3RoKSB7XG4gICAgICB2YXIgcmVjID0gZW52LnN0YWNrLnBvcCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlYy5kaXNwb3NlICYmIHJlYy5kaXNwb3NlLmNhbGwocmVjLnZhbHVlKTtcbiAgICAgICAgaWYgKHJlYy5hc3luYykgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgZmFpbChlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVudi5oYXNFcnJvcikgdGhyb3cgZW52LmVycm9yO1xuICB9XG4gIHJldHVybiBuZXh0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webcrypto-core/node_modules/tslib/tslib.es6.mjs\n");

/***/ })

};
;