"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bignumber.js";
exports.ids = ["vendor-chunks/bignumber.js"];
exports.modules = {

/***/ "(rsc)/./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n;\n(function(globalObject) {\n    \"use strict\";\n    /*\r\n *      bignumber.js v9.0.2\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2021 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */ var BigNumber, isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = \"[BigNumber Error] \", tooManyDigits = bignumberError + \"Number primitive has more than 15 significant digits: \", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\n    POWS_TEN = [\n        1,\n        10,\n        100,\n        1e3,\n        1e4,\n        1e5,\n        1e6,\n        1e7,\n        1e8,\n        1e9,\n        1e10,\n        1e11,\n        1e12,\n        1e13\n    ], SQRT_BASE = 1e7, // EDITABLE\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\n    MAX = 1E9; // 0 to MAX_INT32\n    /*\r\n   * Create and return a BigNumber constructor.\r\n   */ function clone(configObject) {\n        var div, convertBase, parseNumeric, P = BigNumber.prototype = {\n            constructor: BigNumber,\n            toString: null,\n            valueOf: null\n        }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n        // The default values below must be integers within the inclusive ranges stated.\n        // The values can also be changed at run-time using BigNumber.set.\n        // The maximum number of decimal places for operations involving division.\n        DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using\n        // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n        // UP         0 Away from zero.\n        // DOWN       1 Towards zero.\n        // CEIL       2 Towards +Infinity.\n        // FLOOR      3 Towards -Infinity.\n        // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n        // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n        // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n        // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n        // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n        ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n        // The exponent value at and beneath which toString returns exponential notation.\n        // Number type: -7\n        TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.\n        // Number type: 21\n        TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]\n        // The minimum exponent value, beneath which underflow to zero occurs.\n        // Number type: -324  (5e-324)\n        MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.\n        // Number type:  308  (1.7976931348623157e+308)\n        // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n        MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.\n        CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.\n        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n        // The remainder (r) is calculated as: r = a - n * q.\n        //\n        // UP        0 The remainder is positive if the dividend is negative, else is negative.\n        // DOWN      1 The remainder has the same sign as the dividend.\n        //             This modulo mode is commonly known as 'truncated division' and is\n        //             equivalent to (a % n) in JavaScript.\n        // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n        // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n        // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n        //             The remainder is always positive.\n        //\n        // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n        // modes are commonly used for the modulus operation.\n        // Although the other rounding modes can also be used, they may not give useful results.\n        MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.\n        // If POW_PRECISION is 0, there will be unlimited significant digits.\n        POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.\n        FORMAT = {\n            prefix: \"\",\n            groupSize: 3,\n            secondaryGroupSize: 0,\n            groupSeparator: \",\",\n            decimalSeparator: \".\",\n            fractionGroupSize: 0,\n            fractionGroupSeparator: \"\\xa0\",\n            suffix: \"\"\n        }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\n        // '-', '.', whitespace, or repeated character.\n        // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n        ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\", alphabetHasNormalDecimalDigits = true;\n        //------------------------------------------------------------------------------------------\n        // CONSTRUCTOR\n        /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */ function BigNumber(v, b) {\n            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;\n            // Enable constructor call without `new`.\n            if (!(x instanceof BigNumber)) return new BigNumber(v, b);\n            if (b == null) {\n                if (v && v._isBigNumber === true) {\n                    x.s = v.s;\n                    if (!v.c || v.e > MAX_EXP) {\n                        x.c = x.e = null;\n                    } else if (v.e < MIN_EXP) {\n                        x.c = [\n                            x.e = 0\n                        ];\n                    } else {\n                        x.e = v.e;\n                        x.c = v.c.slice();\n                    }\n                    return;\n                }\n                if ((isNum = typeof v == \"number\") && v * 0 == 0) {\n                    // Use `1 / n` to handle minus zero also.\n                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;\n                    // Fast path for integers, where n < 2147483648 (2**31).\n                    if (v === ~~v) {\n                        for(e = 0, i = v; i >= 10; i /= 10, e++);\n                        if (e > MAX_EXP) {\n                            x.c = x.e = null;\n                        } else {\n                            x.e = e;\n                            x.c = [\n                                v\n                            ];\n                        }\n                        return;\n                    }\n                    str = String(v);\n                } else {\n                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\n                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n                }\n                // Decimal point?\n                if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n                // Exponential form?\n                if ((i = str.search(/e/i)) > 0) {\n                    // Determine exponent.\n                    if (e < 0) e = i;\n                    e += +str.slice(i + 1);\n                    str = str.substring(0, i);\n                } else if (e < 0) {\n                    // Integer.\n                    e = str.length;\n                }\n            } else {\n                // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n                intCheck(b, 2, ALPHABET.length, \"Base\");\n                // Allow exponential notation to be used with base 10 argument, while\n                // also rounding to DECIMAL_PLACES as with other bases.\n                if (b == 10 && alphabetHasNormalDecimalDigits) {\n                    x = new BigNumber(v);\n                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n                }\n                str = String(v);\n                if (isNum = typeof v == \"number\") {\n                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\n                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\n                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                    if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, \"\").length > 15) {\n                        throw Error(tooManyDigits + v);\n                    }\n                } else {\n                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n                }\n                alphabet = ALPHABET.slice(0, b);\n                e = i = 0;\n                // Check that str is a valid base b number.\n                // Don't use RegExp, so alphabet can contain special characters.\n                for(len = str.length; i < len; i++){\n                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                        if (c == \".\") {\n                            // If '.' is not the first character and it has not be found before.\n                            if (i > e) {\n                                e = len;\n                                continue;\n                            }\n                        } else if (!caseChanged) {\n                            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {\n                                caseChanged = true;\n                                i = -1;\n                                e = 0;\n                                continue;\n                            }\n                        }\n                        return parseNumeric(x, String(v), isNum, b);\n                    }\n                }\n                // Prevent later check for length on converted number.\n                isNum = false;\n                str = convertBase(str, b, 10, x.s);\n                // Decimal point?\n                if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n                else e = str.length;\n            }\n            // Determine leading zeros.\n            for(i = 0; str.charCodeAt(i) === 48; i++);\n            // Determine trailing zeros.\n            for(len = str.length; str.charCodeAt(--len) === 48;);\n            if (str = str.slice(i, ++len)) {\n                len -= i;\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\n                    throw Error(tooManyDigits + x.s * v);\n                }\n                // Overflow?\n                if ((e = e - i - 1) > MAX_EXP) {\n                    // Infinity.\n                    x.c = x.e = null;\n                // Underflow?\n                } else if (e < MIN_EXP) {\n                    // Zero.\n                    x.c = [\n                        x.e = 0\n                    ];\n                } else {\n                    x.e = e;\n                    x.c = [];\n                    // Transform base\n                    // e is the base 10 exponent.\n                    // i is where to slice str to get the first element of the coefficient array.\n                    i = (e + 1) % LOG_BASE;\n                    if (e < 0) i += LOG_BASE; // i < 1\n                    if (i < len) {\n                        if (i) x.c.push(+str.slice(0, i));\n                        for(len -= LOG_BASE; i < len;){\n                            x.c.push(+str.slice(i, i += LOG_BASE));\n                        }\n                        i = LOG_BASE - (str = str.slice(i)).length;\n                    } else {\n                        i -= len;\n                    }\n                    for(; i--; str += \"0\");\n                    x.c.push(+str);\n                }\n            } else {\n                // Zero.\n                x.c = [\n                    x.e = 0\n                ];\n            }\n        }\n        // CONSTRUCTOR PROPERTIES\n        BigNumber.clone = clone;\n        BigNumber.ROUND_UP = 0;\n        BigNumber.ROUND_DOWN = 1;\n        BigNumber.ROUND_CEIL = 2;\n        BigNumber.ROUND_FLOOR = 3;\n        BigNumber.ROUND_HALF_UP = 4;\n        BigNumber.ROUND_HALF_DOWN = 5;\n        BigNumber.ROUND_HALF_EVEN = 6;\n        BigNumber.ROUND_HALF_CEIL = 7;\n        BigNumber.ROUND_HALF_FLOOR = 8;\n        BigNumber.EUCLID = 9;\n        /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */ BigNumber.config = BigNumber.set = function(obj) {\n            var p, v;\n            if (obj != null) {\n                if (typeof obj == \"object\") {\n                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"DECIMAL_PLACES\")) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        DECIMAL_PLACES = v;\n                    }\n                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"ROUNDING_MODE\")) {\n                        v = obj[p];\n                        intCheck(v, 0, 8, p);\n                        ROUNDING_MODE = v;\n                    }\n                    // EXPONENTIAL_AT {number|number[]}\n                    // Integer, -MAX to MAX inclusive or\n                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"EXPONENTIAL_AT\")) {\n                        v = obj[p];\n                        if (v && v.pop) {\n                            intCheck(v[0], -MAX, 0, p);\n                            intCheck(v[1], 0, MAX, p);\n                            TO_EXP_NEG = v[0];\n                            TO_EXP_POS = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                        }\n                    }\n                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                    if (obj.hasOwnProperty(p = \"RANGE\")) {\n                        v = obj[p];\n                        if (v && v.pop) {\n                            intCheck(v[0], -MAX, -1, p);\n                            intCheck(v[1], 1, MAX, p);\n                            MIN_EXP = v[0];\n                            MAX_EXP = v[1];\n                        } else {\n                            intCheck(v, -MAX, MAX, p);\n                            if (v) {\n                                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                            } else {\n                                throw Error(bignumberError + p + \" cannot be zero: \" + v);\n                            }\n                        }\n                    }\n                    // CRYPTO {boolean} true or false.\n                    // '[BigNumber Error] CRYPTO not true or false: {v}'\n                    // '[BigNumber Error] crypto unavailable'\n                    if (obj.hasOwnProperty(p = \"CRYPTO\")) {\n                        v = obj[p];\n                        if (v === !!v) {\n                            if (v) {\n                                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                                    CRYPTO = v;\n                                } else {\n                                    CRYPTO = !v;\n                                    throw Error(bignumberError + \"crypto unavailable\");\n                                }\n                            } else {\n                                CRYPTO = v;\n                            }\n                        } else {\n                            throw Error(bignumberError + p + \" not true or false: \" + v);\n                        }\n                    }\n                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"MODULO_MODE\")) {\n                        v = obj[p];\n                        intCheck(v, 0, 9, p);\n                        MODULO_MODE = v;\n                    }\n                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                    if (obj.hasOwnProperty(p = \"POW_PRECISION\")) {\n                        v = obj[p];\n                        intCheck(v, 0, MAX, p);\n                        POW_PRECISION = v;\n                    }\n                    // FORMAT {object}\n                    // '[BigNumber Error] FORMAT not an object: {v}'\n                    if (obj.hasOwnProperty(p = \"FORMAT\")) {\n                        v = obj[p];\n                        if (typeof v == \"object\") FORMAT = v;\n                        else throw Error(bignumberError + p + \" not an object: \" + v);\n                    }\n                    // ALPHABET {string}\n                    // '[BigNumber Error] ALPHABET invalid: {v}'\n                    if (obj.hasOwnProperty(p = \"ALPHABET\")) {\n                        v = obj[p];\n                        // Disallow if less than two characters,\n                        // or if it contains '+', '-', '.', whitespace, or a repeated character.\n                        if (typeof v == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\n                            alphabetHasNormalDecimalDigits = v.slice(0, 10) == \"0123456789\";\n                            ALPHABET = v;\n                        } else {\n                            throw Error(bignumberError + p + \" invalid: \" + v);\n                        }\n                    }\n                } else {\n                    // '[BigNumber Error] Object expected: {v}'\n                    throw Error(bignumberError + \"Object expected: \" + obj);\n                }\n            }\n            return {\n                DECIMAL_PLACES: DECIMAL_PLACES,\n                ROUNDING_MODE: ROUNDING_MODE,\n                EXPONENTIAL_AT: [\n                    TO_EXP_NEG,\n                    TO_EXP_POS\n                ],\n                RANGE: [\n                    MIN_EXP,\n                    MAX_EXP\n                ],\n                CRYPTO: CRYPTO,\n                MODULO_MODE: MODULO_MODE,\n                POW_PRECISION: POW_PRECISION,\n                FORMAT: FORMAT,\n                ALPHABET: ALPHABET\n            };\n        };\n        /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */ BigNumber.isBigNumber = function(v) {\n            if (!v || v._isBigNumber !== true) return false;\n            if (!BigNumber.DEBUG) return true;\n            var i, n, c = v.c, e = v.e, s = v.s;\n            out: if (({}).toString.call(c) == \"[object Array]\") {\n                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\n                    // If the first element is zero, the BigNumber value must be zero.\n                    if (c[0] === 0) {\n                        if (e === 0 && c.length === 1) return true;\n                        break out;\n                    }\n                    // Calculate number of digits that c[0] should have, based on the exponent.\n                    i = (e + 1) % LOG_BASE;\n                    if (i < 1) i += LOG_BASE;\n                    // Calculate number of digits of c[0].\n                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\n                    if (String(c[0]).length == i) {\n                        for(i = 0; i < c.length; i++){\n                            n = c[i];\n                            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\n                        }\n                        // Last element cannot be zero, unless it is the only element.\n                        if (n !== 0) return true;\n                    }\n                }\n            // Infinity/NaN\n            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\n                return true;\n            }\n            throw Error(bignumberError + \"Invalid BigNumber: \" + v);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.maximum = BigNumber.max = function() {\n            return maxOrMin(arguments, P.lt);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.minimum = BigNumber.min = function() {\n            return maxOrMin(arguments, P.gt);\n        };\n        /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */ BigNumber.random = function() {\n            var pow2_53 = 0x20000000000000;\n            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n            // Check if Math.random() produces more than 32 bits of randomness.\n            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n            var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {\n                return mathfloor(Math.random() * pow2_53);\n            } : function() {\n                return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);\n            };\n            return function(dp) {\n                var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);\n                if (dp == null) dp = DECIMAL_PLACES;\n                else intCheck(dp, 0, MAX);\n                k = mathceil(dp / LOG_BASE);\n                if (CRYPTO) {\n                    // Browsers supporting crypto.getRandomValues.\n                    if (crypto.getRandomValues) {\n                        a = crypto.getRandomValues(new Uint32Array(k *= 2));\n                        for(; i < k;){\n                            // 53 bits:\n                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                            //                                     11111 11111111 11111111\n                            // 0x20000 is 2^21.\n                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n                            // Rejection sampling:\n                            // 0 <= v < 9007199254740992\n                            // Probability that v >= 9e15, is\n                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                            if (v >= 9e15) {\n                                b = crypto.getRandomValues(new Uint32Array(2));\n                                a[i] = b[0];\n                                a[i + 1] = b[1];\n                            } else {\n                                // 0 <= v <= 8999999999999999\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 2;\n                            }\n                        }\n                        i = k / 2;\n                    // Node.js supporting crypto.randomBytes.\n                    } else if (crypto.randomBytes) {\n                        // buffer\n                        a = crypto.randomBytes(k *= 7);\n                        for(; i < k;){\n                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                            // 0x100000000 is 2^32, 0x1000000 is 2^24\n                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                            // 0 <= v < 9007199254740992\n                            v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n                            if (v >= 9e15) {\n                                crypto.randomBytes(7).copy(a, i);\n                            } else {\n                                // 0 <= (v % 1e14) <= 99999999999999\n                                c.push(v % 1e14);\n                                i += 7;\n                            }\n                        }\n                        i = k / 7;\n                    } else {\n                        CRYPTO = false;\n                        throw Error(bignumberError + \"crypto unavailable\");\n                    }\n                }\n                // Use Math.random.\n                if (!CRYPTO) {\n                    for(; i < k;){\n                        v = random53bitInt();\n                        if (v < 9e15) c[i++] = v % 1e14;\n                    }\n                }\n                k = c[--i];\n                dp %= LOG_BASE;\n                // Convert trailing digits to zeros according to dp.\n                if (k && dp) {\n                    v = POWS_TEN[LOG_BASE - dp];\n                    c[i] = mathfloor(k / v) * v;\n                }\n                // Remove trailing elements which are zero.\n                for(; c[i] === 0; c.pop(), i--);\n                // Zero?\n                if (i < 0) {\n                    c = [\n                        e = 0\n                    ];\n                } else {\n                    // Remove leading elements which are zero and adjust exponent accordingly.\n                    for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n                    // Count the digits of the first element of c to determine leading zeros, and...\n                    for(i = 1, v = c[0]; v >= 10; v /= 10, i++);\n                    // adjust the exponent accordingly.\n                    if (i < LOG_BASE) e -= LOG_BASE - i;\n                }\n                rand.e = e;\n                rand.c = c;\n                return rand;\n            };\n        }();\n        /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */ BigNumber.sum = function() {\n            var i = 1, args = arguments, sum = new BigNumber(args[0]);\n            for(; i < args.length;)sum = sum.plus(args[i++]);\n            return sum;\n        };\n        // PRIVATE FUNCTIONS\n        // Called by BigNumber and BigNumber.prototype.toString.\n        convertBase = function() {\n            var decimal = \"0123456789\";\n            /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */ function toBaseOut(str, baseIn, baseOut, alphabet) {\n                var j, arr = [\n                    0\n                ], arrL, i = 0, len = str.length;\n                for(; i < len;){\n                    for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n                    arr[0] += alphabet.indexOf(str.charAt(i++));\n                    for(j = 0; j < arr.length; j++){\n                        if (arr[j] > baseOut - 1) {\n                            if (arr[j + 1] == null) arr[j + 1] = 0;\n                            arr[j + 1] += arr[j] / baseOut | 0;\n                            arr[j] %= baseOut;\n                        }\n                    }\n                }\n                return arr.reverse();\n            }\n            // Convert a numeric string of baseIn to a numeric string of baseOut.\n            // If the caller is toString, we are converting from base 10 to baseOut.\n            // If the caller is BigNumber, we are converting from baseIn to base 10.\n            return function(str, baseIn, baseOut, sign, callerIsToString) {\n                var alphabet, d, e, k, r, x, xc, y, i = str.indexOf(\".\"), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;\n                // Non-integer.\n                if (i >= 0) {\n                    k = POW_PRECISION;\n                    // Unlimited precision.\n                    POW_PRECISION = 0;\n                    str = str.replace(\".\", \"\");\n                    y = new BigNumber(baseIn);\n                    x = y.pow(str.length - i);\n                    POW_PRECISION = k;\n                    // Convert str as if an integer, then restore the fraction part by dividing the\n                    // result by its base raised to a power.\n                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, \"0\"), 10, baseOut, decimal);\n                    y.e = y.c.length;\n                }\n                // Convert the number as integer.\n                xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));\n                // xc now represents str as an integer and converted to baseOut. e is the exponent.\n                e = k = xc.length;\n                // Remove trailing zeros.\n                for(; xc[--k] == 0; xc.pop());\n                // Zero?\n                if (!xc[0]) return alphabet.charAt(0);\n                // Does str represent an integer? If so, no need for the division.\n                if (i < 0) {\n                    --e;\n                } else {\n                    x.c = xc;\n                    x.e = e;\n                    // The sign is needed for correct rounding.\n                    x.s = sign;\n                    x = div(x, y, dp, rm, baseOut);\n                    xc = x.c;\n                    r = x.r;\n                    e = x.e;\n                }\n                // xc now represents str converted to baseOut.\n                // THe index of the rounding digit.\n                d = e + dp + 1;\n                // The rounding digit: the digit to the right of the digit that may be rounded up.\n                i = xc[d];\n                // Look at the rounding digits and mode to determine whether to round up.\n                k = baseOut / 2;\n                r = r || d < 0 || xc[d + 1] != null;\n                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));\n                // If the index of the rounding digit is not greater than zero, or xc represents\n                // zero, then the result of the base conversion is zero or, if rounding up, a value\n                // such as 0.00001.\n                if (d < 1 || !xc[0]) {\n                    // 1^-dp or 0\n                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\n                } else {\n                    // Truncate xc to the required number of decimal places.\n                    xc.length = d;\n                    // Round up?\n                    if (r) {\n                        // Rounding up may mean the previous digit has to be rounded up and so on.\n                        for(--baseOut; ++xc[--d] > baseOut;){\n                            xc[d] = 0;\n                            if (!d) {\n                                ++e;\n                                xc = [\n                                    1\n                                ].concat(xc);\n                            }\n                        }\n                    }\n                    // Determine trailing zeros.\n                    for(k = xc.length; !xc[--k];);\n                    // E.g. [4, 11, 15] becomes 4bf.\n                    for(i = 0, str = \"\"; i <= k; str += alphabet.charAt(xc[i++]));\n                    // Add leading zeros, decimal point and trailing zeros as required.\n                    str = toFixedPoint(str, e, alphabet.charAt(0));\n                }\n                // The caller will add the sign.\n                return str;\n            };\n        }();\n        // Perform division in the specified base. Called by div and convertBase.\n        div = function() {\n            // Assume non-zero x and k.\n            function multiply(x, k, base) {\n                var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;\n                for(x = x.slice(); i--;){\n                    xlo = x[i] % SQRT_BASE;\n                    xhi = x[i] / SQRT_BASE | 0;\n                    m = khi * xlo + xhi * klo;\n                    temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;\n                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                    x[i] = temp % base;\n                }\n                if (carry) x = [\n                    carry\n                ].concat(x);\n                return x;\n            }\n            function compare(a, b, aL, bL) {\n                var i, cmp;\n                if (aL != bL) {\n                    cmp = aL > bL ? 1 : -1;\n                } else {\n                    for(i = cmp = 0; i < aL; i++){\n                        if (a[i] != b[i]) {\n                            cmp = a[i] > b[i] ? 1 : -1;\n                            break;\n                        }\n                    }\n                }\n                return cmp;\n            }\n            function subtract(a, b, aL, base) {\n                var i = 0;\n                // Subtract b from a.\n                for(; aL--;){\n                    a[aL] -= i;\n                    i = a[aL] < b[aL] ? 1 : 0;\n                    a[aL] = i * base + a[aL] - b[aL];\n                }\n                // Remove leading zeros.\n                for(; !a[0] && a.length > 1; a.splice(0, 1));\n            }\n            // x: dividend, y: divisor.\n            return function(x, y, dp, rm, base) {\n                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;\n                // Either NaN, Infinity or 0?\n                if (!xc || !xc[0] || !yc || !yc[0]) {\n                    return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.\n                    !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                    xc && xc[0] == 0 || !yc ? s * 0 : s / 0);\n                }\n                q = new BigNumber(s);\n                qc = q.c = [];\n                e = x.e - y.e;\n                s = dp + e + 1;\n                if (!base) {\n                    base = BASE;\n                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                    s = s / LOG_BASE | 0;\n                }\n                // Result exponent may be one less then the current value of e.\n                // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n                for(i = 0; yc[i] == (xc[i] || 0); i++);\n                if (yc[i] > (xc[i] || 0)) e--;\n                if (s < 0) {\n                    qc.push(1);\n                    more = true;\n                } else {\n                    xL = xc.length;\n                    yL = yc.length;\n                    i = 0;\n                    s += 2;\n                    // Normalise xc and yc so highest order digit of yc is >= base / 2.\n                    n = mathfloor(base / (yc[0] + 1));\n                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                    if (n > 1) {\n                        yc = multiply(yc, n, base);\n                        xc = multiply(xc, n, base);\n                        yL = yc.length;\n                        xL = xc.length;\n                    }\n                    xi = yL;\n                    rem = xc.slice(0, yL);\n                    remL = rem.length;\n                    // Add zeros to make remainder as long as divisor.\n                    for(; remL < yL; rem[remL++] = 0);\n                    yz = yc.slice();\n                    yz = [\n                        0\n                    ].concat(yz);\n                    yc0 = yc[0];\n                    if (yc[1] >= base / 2) yc0++;\n                    // Not necessary, but to prevent trial digit n > base, when using base 3.\n                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n                    do {\n                        n = 0;\n                        // Compare divisor and remainder.\n                        cmp = compare(yc, rem, yL, remL);\n                        // If divisor < remainder.\n                        if (cmp < 0) {\n                            // Calculate trial digit, n.\n                            rem0 = rem[0];\n                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                            // n is how many times the divisor goes into the current remainder.\n                            n = mathfloor(rem0 / yc0);\n                            //  Algorithm:\n                            //  product = divisor multiplied by trial digit (n).\n                            //  Compare product and remainder.\n                            //  If product is greater than remainder:\n                            //    Subtract divisor from product, decrement trial digit.\n                            //  Subtract product from remainder.\n                            //  If product was less than remainder at the last compare:\n                            //    Compare new remainder and divisor.\n                            //    If remainder is greater than divisor:\n                            //      Subtract divisor from remainder, increment trial digit.\n                            if (n > 1) {\n                                // n may be > base only when base is 3.\n                                if (n >= base) n = base - 1;\n                                // product = divisor * trial digit.\n                                prod = multiply(yc, n, base);\n                                prodL = prod.length;\n                                remL = rem.length;\n                                // Compare product and remainder.\n                                // If product > remainder then trial digit n too high.\n                                // n is 1 too high about 5% of the time, and is not known to have\n                                // ever been more than 1 too high.\n                                while(compare(prod, rem, prodL, remL) == 1){\n                                    n--;\n                                    // Subtract divisor from product.\n                                    subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                    prodL = prod.length;\n                                    cmp = 1;\n                                }\n                            } else {\n                                // n is 0 or 1, cmp is -1.\n                                // If n is 0, there is no need to compare yc and rem again below,\n                                // so change cmp to 1 to avoid it.\n                                // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                                if (n == 0) {\n                                    // divisor < remainder, so n must be at least 1.\n                                    cmp = n = 1;\n                                }\n                                // product = divisor\n                                prod = yc.slice();\n                                prodL = prod.length;\n                            }\n                            if (prodL < remL) prod = [\n                                0\n                            ].concat(prod);\n                            // Subtract product from remainder.\n                            subtract(rem, prod, remL, base);\n                            remL = rem.length;\n                            // If product was < remainder.\n                            if (cmp == -1) {\n                                // Compare divisor and new remainder.\n                                // If divisor < new remainder, subtract divisor from remainder.\n                                // Trial digit n too low.\n                                // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                                while(compare(yc, rem, yL, remL) < 1){\n                                    n++;\n                                    // Subtract divisor from remainder.\n                                    subtract(rem, yL < remL ? yz : yc, remL, base);\n                                    remL = rem.length;\n                                }\n                            }\n                        } else if (cmp === 0) {\n                            n++;\n                            rem = [\n                                0\n                            ];\n                        } // else cmp === 1 and n will be 0\n                        // Add the next digit, n, to the result array.\n                        qc[i++] = n;\n                        // Update the remainder.\n                        if (rem[0]) {\n                            rem[remL++] = xc[xi] || 0;\n                        } else {\n                            rem = [\n                                xc[xi]\n                            ];\n                            remL = 1;\n                        }\n                    }while ((xi++ < xL || rem[0] != null) && s--);\n                    more = rem[0] != null;\n                    // Leading zero?\n                    if (!qc[0]) qc.splice(0, 1);\n                }\n                if (base == BASE) {\n                    // To calculate q.e, first get the number of digits of qc[0].\n                    for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n                // Caller is convertBase.\n                } else {\n                    q.e = e;\n                    q.r = +more;\n                }\n                return q;\n            };\n        }();\n        /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */ function format(n, i, rm, id) {\n            var c0, e, ne, len, str;\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            if (!n.c) return n.toString();\n            c0 = n.c[0];\n            ne = n.e;\n            if (i == null) {\n                str = coeffToString(n.c);\n                str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, \"0\");\n            } else {\n                n = round(new BigNumber(n), i, rm);\n                // n.e may have changed if the value was rounded up.\n                e = n.e;\n                str = coeffToString(n.c);\n                len = str.length;\n                // toPrecision returns exponential notation if the number of significant digits\n                // specified is less than the number of digits necessary to represent the integer\n                // part of the value in fixed-point notation.\n                // Exponential notation.\n                if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n                    // Append zeros?\n                    for(; len < i; str += \"0\", len++);\n                    str = toExponential(str, e);\n                // Fixed-point notation.\n                } else {\n                    i -= ne;\n                    str = toFixedPoint(str, e, \"0\");\n                    // Append zeros?\n                    if (e + 1 > len) {\n                        if (--i > 0) for(str += \".\"; i--; str += \"0\");\n                    } else {\n                        i += e - len;\n                        if (i > 0) {\n                            if (e + 1 == len) str += \".\";\n                            for(; i--; str += \"0\");\n                        }\n                    }\n                }\n            }\n            return n.s < 0 && c0 ? \"-\" + str : str;\n        }\n        // Handle BigNumber.max and BigNumber.min.\n        function maxOrMin(args, method) {\n            var n, i = 1, m = new BigNumber(args[0]);\n            for(; i < args.length; i++){\n                n = new BigNumber(args[i]);\n                // If any number is NaN, return NaN.\n                if (!n.s) {\n                    m = n;\n                    break;\n                } else if (method.call(m, n)) {\n                    m = n;\n                }\n            }\n            return m;\n        }\n        /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */ function normalise(n, c, e) {\n            var i = 1, j = c.length;\n            // Remove trailing zeros.\n            for(; !c[--j]; c.pop());\n            // Calculate the base 10 exponent. First get the number of digits of c[0].\n            for(j = c[0]; j >= 10; j /= 10, i++);\n            // Overflow?\n            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n                // Infinity.\n                n.c = n.e = null;\n            // Underflow?\n            } else if (e < MIN_EXP) {\n                // Zero.\n                n.c = [\n                    n.e = 0\n                ];\n            } else {\n                n.e = e;\n                n.c = c;\n            }\n            return n;\n        }\n        // Handle values that fail the validity test in BigNumber.\n        parseNumeric = function() {\n            var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, dotAfter = /^([^.]+)\\.$/, dotBefore = /^\\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n            return function(x, str, isNum, b) {\n                var base, s = isNum ? str : str.replace(whitespaceOrPlus, \"\");\n                // No exception on ±Infinity or NaN.\n                if (isInfinityOrNaN.test(s)) {\n                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n                } else {\n                    if (!isNum) {\n                        // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                        s = s.replace(basePrefix, function(m, p1, p2) {\n                            base = (p2 = p2.toLowerCase()) == \"x\" ? 16 : p2 == \"b\" ? 2 : 8;\n                            return !b || b == base ? p1 : m;\n                        });\n                        if (b) {\n                            base = b;\n                            // E.g. '1.' to '1', '.1' to '0.1'\n                            s = s.replace(dotAfter, \"$1\").replace(dotBefore, \"0.$1\");\n                        }\n                        if (str != s) return new BigNumber(s, base);\n                    }\n                    // '[BigNumber Error] Not a number: {n}'\n                    // '[BigNumber Error] Not a base {b} number: {n}'\n                    if (BigNumber.DEBUG) {\n                        throw Error(bignumberError + \"Not a\" + (b ? \" base \" + b : \"\") + \" number: \" + str);\n                    }\n                    // NaN\n                    x.s = null;\n                }\n                x.c = x.e = null;\n            };\n        }();\n        /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */ function round(x, sd, rm, r) {\n            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;\n            // if x is not Infinity or NaN...\n            if (xc) {\n                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n                // n is a base 1e14 number, the value of the element of array x.c containing rd.\n                // ni is the index of n within x.c.\n                // d is the number of digits of n.\n                // i is the index of rd within n including leading zeros.\n                // j is the actual index of rd within n (if < 0, rd is a leading zero).\n                out: {\n                    // Get the number of digits of the first element of xc.\n                    for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                    i = sd - d;\n                    // If the rounding digit is in the first element of xc...\n                    if (i < 0) {\n                        i += LOG_BASE;\n                        j = sd;\n                        n = xc[ni = 0];\n                        // Get the rounding digit at index j of n.\n                        rd = n / pows10[d - j - 1] % 10 | 0;\n                    } else {\n                        ni = mathceil((i + 1) / LOG_BASE);\n                        if (ni >= xc.length) {\n                            if (r) {\n                                // Needed by sqrt.\n                                for(; xc.length <= ni; xc.push(0));\n                                n = rd = 0;\n                                d = 1;\n                                i %= LOG_BASE;\n                                j = i - LOG_BASE + 1;\n                            } else {\n                                break out;\n                            }\n                        } else {\n                            n = k = xc[ni];\n                            // Get the number of digits of n.\n                            for(d = 1; k >= 10; k /= 10, d++);\n                            // Get the index of rd within n.\n                            i %= LOG_BASE;\n                            // Get the index of rd within n, adjusted for leading zeros.\n                            // The number of leading zeros of n is given by LOG_BASE - d.\n                            j = i - LOG_BASE + d;\n                            // Get the rounding digit at index j of n.\n                            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\n                        }\n                    }\n                    r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?\n                    // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                    xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n                    r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n                    if (sd < 1 || !xc[0]) {\n                        xc.length = 0;\n                        if (r) {\n                            // Convert sd to decimal places.\n                            sd -= x.e + 1;\n                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                            x.e = -sd || 0;\n                        } else {\n                            // Zero.\n                            xc[0] = x.e = 0;\n                        }\n                        return x;\n                    }\n                    // Remove excess digits.\n                    if (i == 0) {\n                        xc.length = ni;\n                        k = 1;\n                        ni--;\n                    } else {\n                        xc.length = ni + 1;\n                        k = pows10[LOG_BASE - i];\n                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                        // j > 0 means i > number of leading zeros of n.\n                        xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                    }\n                    // Round up?\n                    if (r) {\n                        for(;;){\n                            // If the digit to be rounded up is in the first element of xc...\n                            if (ni == 0) {\n                                // i will be the length of xc[0] before k is added.\n                                for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                                j = xc[0] += k;\n                                for(k = 1; j >= 10; j /= 10, k++);\n                                // if i != k the length has increased.\n                                if (i != k) {\n                                    x.e++;\n                                    if (xc[0] == BASE) xc[0] = 1;\n                                }\n                                break;\n                            } else {\n                                xc[ni] += k;\n                                if (xc[ni] != BASE) break;\n                                xc[ni--] = 0;\n                                k = 1;\n                            }\n                        }\n                    }\n                    // Remove trailing zeros.\n                    for(i = xc.length; xc[--i] === 0; xc.pop());\n                }\n                // Overflow? Infinity.\n                if (x.e > MAX_EXP) {\n                    x.c = x.e = null;\n                // Underflow? Zero.\n                } else if (x.e < MIN_EXP) {\n                    x.c = [\n                        x.e = 0\n                    ];\n                }\n            }\n            return x;\n        }\n        function valueOf(n) {\n            var str, e = n.e;\n            if (e === null) return n.toString();\n            str = coeffToString(n.c);\n            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, \"0\");\n            return n.s < 0 ? \"-\" + str : str;\n        }\n        // PROTOTYPE/INSTANCE METHODS\n        /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */ P.absoluteValue = P.abs = function() {\n            var x = new BigNumber(this);\n            if (x.s < 0) x.s = 1;\n            return x;\n        };\n        /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */ P.comparedTo = function(y, b) {\n            return compare(this, new BigNumber(y, b));\n        };\n        /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.decimalPlaces = P.dp = function(dp, rm) {\n            var c, n, v, x = this;\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n                return round(new BigNumber(x), dp + x.e + 1, rm);\n            }\n            if (!(c = x.c)) return null;\n            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n            // Subtract the number of trailing zeros of the last number.\n            if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);\n            if (n < 0) n = 0;\n            return n;\n        };\n        /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */ P.dividedBy = P.div = function(y, b) {\n            return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */ P.dividedToIntegerBy = P.idiv = function(y, b) {\n            return div(this, new BigNumber(y, b), 0, 1);\n        };\n        /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */ P.exponentiatedBy = P.pow = function(n, m) {\n            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;\n            n = new BigNumber(n);\n            // Allow NaN and ±Infinity, but not other non-integers.\n            if (n.c && !n.isInteger()) {\n                throw Error(bignumberError + \"Exponent not an integer: \" + valueOf(n));\n            }\n            if (m != null) m = new BigNumber(m);\n            // Exponent of MAX_SAFE_INTEGER is 15.\n            nIsBig = n.e > 14;\n            // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\n            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n                // The sign of the result of pow when x is negative depends on the evenness of n.\n                // If +n overflows to ±Infinity, the evenness of n would be not be known.\n                y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\n                return m ? y.mod(m) : y;\n            }\n            nIsNeg = n.s < 0;\n            if (m) {\n                // x % m returns NaN if abs(m) is zero, or m is NaN.\n                if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n                isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n                if (isModExp) x = x.mod(m);\n            // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\n            // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\n            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n                // If x is negative and n is odd, k = -0, else k = 0.\n                k = x.s < 0 && isOdd(n) ? -0 : 0;\n                // If x >= 1, k = ±Infinity.\n                if (x.e > -1) k = 1 / k;\n                // If n is negative return ±0, else return ±Infinity.\n                return new BigNumber(nIsNeg ? 1 / k : k);\n            } else if (POW_PRECISION) {\n                // Truncating each coefficient array to a length of k after each multiplication\n                // equates to truncating significant digits to POW_PRECISION + [28, 41],\n                // i.e. there will be a minimum of 28 guard digits retained.\n                k = mathceil(POW_PRECISION / LOG_BASE + 2);\n            }\n            if (nIsBig) {\n                half = new BigNumber(0.5);\n                if (nIsNeg) n.s = 1;\n                nIsOdd = isOdd(n);\n            } else {\n                i = Math.abs(+valueOf(n));\n                nIsOdd = i % 2;\n            }\n            y = new BigNumber(ONE);\n            // Performs 54 loop iterations for n of 9007199254740991.\n            for(;;){\n                if (nIsOdd) {\n                    y = y.times(x);\n                    if (!y.c) break;\n                    if (k) {\n                        if (y.c.length > k) y.c.length = k;\n                    } else if (isModExp) {\n                        y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                    }\n                }\n                if (i) {\n                    i = mathfloor(i / 2);\n                    if (i === 0) break;\n                    nIsOdd = i % 2;\n                } else {\n                    n = n.times(half);\n                    round(n, n.e + 1, 1);\n                    if (n.e > 14) {\n                        nIsOdd = isOdd(n);\n                    } else {\n                        i = +valueOf(n);\n                        if (i === 0) break;\n                        nIsOdd = i % 2;\n                    }\n                }\n                x = x.times(x);\n                if (k) {\n                    if (x.c && x.c.length > k) x.c.length = k;\n                } else if (isModExp) {\n                    x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n                }\n            }\n            if (isModExp) return y;\n            if (nIsNeg) y = ONE.div(y);\n            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */ P.integerValue = function(rm) {\n            var n = new BigNumber(this);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(n, n.e + 1, rm);\n        };\n        /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isEqualTo = P.eq = function(y, b) {\n            return compare(this, new BigNumber(y, b)) === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */ P.isFinite = function() {\n            return !!this.c;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isGreaterThan = P.gt = function(y, b) {\n            return compare(this, new BigNumber(y, b)) > 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */ P.isInteger = function() {\n            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */ P.isLessThan = P.lt = function(y, b) {\n            return compare(this, new BigNumber(y, b)) < 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */ P.isLessThanOrEqualTo = P.lte = function(y, b) {\n            return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */ P.isNaN = function() {\n            return !this.s;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */ P.isNegative = function() {\n            return this.s < 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */ P.isPositive = function() {\n            return this.s > 0;\n        };\n        /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */ P.isZero = function() {\n            return !!this.c && this.c[0] == 0;\n        };\n        /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */ P.minus = function(y, b) {\n            var i, j, t, xLTy, x = this, a = x.s;\n            y = new BigNumber(y, b);\n            b = y.s;\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.plus(y);\n            }\n            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n            if (!xe || !ye) {\n                // Either Infinity?\n                if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n                // Either zero?\n                if (!xc[0] || !yc[0]) {\n                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                    ROUNDING_MODE == 3 ? -0 : 0);\n                }\n            }\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n            // Determine which is the bigger number.\n            if (a = xe - ye) {\n                if (xLTy = a < 0) {\n                    a = -a;\n                    t = xc;\n                } else {\n                    ye = xe;\n                    t = yc;\n                }\n                t.reverse();\n                // Prepend zeros to equalise exponents.\n                for(b = a; b--; t.push(0));\n                t.reverse();\n            } else {\n                // Exponents equal. Check digit by digit.\n                j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n                for(a = b = 0; b < j; b++){\n                    if (xc[b] != yc[b]) {\n                        xLTy = xc[b] < yc[b];\n                        break;\n                    }\n                }\n            }\n            // x < y? Point xc to the array of the bigger number.\n            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\n            b = (j = yc.length) - (i = xc.length);\n            // Append zeros to xc if shorter.\n            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n            if (b > 0) for(; b--; xc[i++] = 0);\n            b = BASE - 1;\n            // Subtract yc from xc.\n            for(; j > a;){\n                if (xc[--j] < yc[j]) {\n                    for(i = j; i && !xc[--i]; xc[i] = b);\n                    --xc[i];\n                    xc[j] += BASE;\n                }\n                xc[j] -= yc[j];\n            }\n            // Remove leading zeros and adjust exponent accordingly.\n            for(; xc[0] == 0; xc.splice(0, 1), --ye);\n            // Zero?\n            if (!xc[0]) {\n                // Following IEEE 754 (2008) 6.3,\n                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n                y.s = ROUNDING_MODE == 3 ? -1 : 1;\n                y.c = [\n                    y.e = 0\n                ];\n                return y;\n            }\n            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n            // for finite x and y.\n            return normalise(y, xc, ye);\n        };\n        /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */ P.modulo = P.mod = function(y, b) {\n            var q, s, x = this;\n            y = new BigNumber(y, b);\n            // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n            if (!x.c || !y.s || y.c && !y.c[0]) {\n                return new BigNumber(NaN);\n            // Return x if y is Infinity or x is zero.\n            } else if (!y.c || x.c && !x.c[0]) {\n                return new BigNumber(x);\n            }\n            if (MODULO_MODE == 9) {\n                // Euclidian division: q = sign(y) * floor(x / abs(y))\n                // r = x - qy    where  0 <= r < abs(y)\n                s = y.s;\n                y.s = 1;\n                q = div(x, y, 0, 3);\n                y.s = s;\n                q.s *= s;\n            } else {\n                q = div(x, y, 0, MODULO_MODE);\n            }\n            y = x.minus(q.times(y));\n            // To match JavaScript %, ensure sign of zero is sign of dividend.\n            if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n            return y;\n        };\n        /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */ P.multipliedBy = P.times = function(y, b) {\n            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;\n            // Either NaN, ±Infinity or ±0?\n            if (!xc || !yc || !xc[0] || !yc[0]) {\n                // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n                if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                    y.c = y.e = y.s = null;\n                } else {\n                    y.s *= x.s;\n                    // Return ±Infinity if either is ±Infinity.\n                    if (!xc || !yc) {\n                        y.c = y.e = null;\n                    // Return ±0 if either is ±0.\n                    } else {\n                        y.c = [\n                            0\n                        ];\n                        y.e = 0;\n                    }\n                }\n                return y;\n            }\n            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n            y.s *= x.s;\n            xcL = xc.length;\n            ycL = yc.length;\n            // Ensure xc points to longer array and xcL to its length.\n            if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\n            // Initialise the result array with zeros.\n            for(i = xcL + ycL, zc = []; i--; zc.push(0));\n            base = BASE;\n            sqrtBase = SQRT_BASE;\n            for(i = ycL; --i >= 0;){\n                c = 0;\n                ylo = yc[i] % sqrtBase;\n                yhi = yc[i] / sqrtBase | 0;\n                for(k = xcL, j = i + k; j > i;){\n                    xlo = xc[--k] % sqrtBase;\n                    xhi = xc[k] / sqrtBase | 0;\n                    m = yhi * xlo + xhi * ylo;\n                    xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;\n                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                    zc[j--] = xlo % base;\n                }\n                zc[j] = c;\n            }\n            if (c) {\n                ++e;\n            } else {\n                zc.splice(0, 1);\n            }\n            return normalise(y, zc, e);\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */ P.negated = function() {\n            var x = new BigNumber(this);\n            x.s = -x.s || null;\n            return x;\n        };\n        /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */ P.plus = function(y, b) {\n            var t, x = this, a = x.s;\n            y = new BigNumber(y, b);\n            b = y.s;\n            // Either NaN?\n            if (!a || !b) return new BigNumber(NaN);\n            // Signs differ?\n            if (a != b) {\n                y.s = -b;\n                return x.minus(y);\n            }\n            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n            if (!xe || !ye) {\n                // Return ±Infinity if either ±Infinity.\n                if (!xc || !yc) return new BigNumber(a / 0);\n                // Either zero?\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n            }\n            xe = bitFloor(xe);\n            ye = bitFloor(ye);\n            xc = xc.slice();\n            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n            if (a = xe - ye) {\n                if (a > 0) {\n                    ye = xe;\n                    t = yc;\n                } else {\n                    a = -a;\n                    t = xc;\n                }\n                t.reverse();\n                for(; a--; t.push(0));\n                t.reverse();\n            }\n            a = xc.length;\n            b = yc.length;\n            // Point xc to the longer array, and b to the shorter length.\n            if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\n            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n            for(a = 0; b;){\n                a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n                xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n            }\n            if (a) {\n                xc = [\n                    a\n                ].concat(xc);\n                ++ye;\n            }\n            // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n            // ye = MAX_EXP + 1 possible\n            return normalise(y, xc, ye);\n        };\n        /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */ P.precision = P.sd = function(sd, rm) {\n            var c, n, v, x = this;\n            if (sd != null && sd !== !!sd) {\n                intCheck(sd, 1, MAX);\n                if (rm == null) rm = ROUNDING_MODE;\n                else intCheck(rm, 0, 8);\n                return round(new BigNumber(x), sd, rm);\n            }\n            if (!(c = x.c)) return null;\n            v = c.length - 1;\n            n = v * LOG_BASE + 1;\n            if (v = c[v]) {\n                // Subtract the number of trailing zeros of the last element.\n                for(; v % 10 == 0; v /= 10, n--);\n                // Add the number of digits of the first element.\n                for(v = c[0]; v >= 10; v /= 10, n++);\n            }\n            if (sd && x.e + 1 > n) n = x.e + 1;\n            return n;\n        };\n        /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */ P.shiftedBy = function(k) {\n            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n            return this.times(\"1e\" + k);\n        };\n        /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */ P.squareRoot = P.sqrt = function() {\n            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber(\"0.5\");\n            // Negative/NaN/Infinity/zero?\n            if (s !== 1 || !c || !c[0]) {\n                return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n            }\n            // Initial estimate.\n            s = Math.sqrt(+valueOf(x));\n            // Math.sqrt underflow/overflow?\n            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n            if (s == 0 || s == 1 / 0) {\n                n = coeffToString(c);\n                if ((n.length + e) % 2 == 0) n += \"0\";\n                s = Math.sqrt(+n);\n                e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n                if (s == 1 / 0) {\n                    n = \"5e\" + e;\n                } else {\n                    n = s.toExponential();\n                    n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n                }\n                r = new BigNumber(n);\n            } else {\n                r = new BigNumber(s + \"\");\n            }\n            // Check for zero.\n            // r could be zero if MIN_EXP is changed after the this value was created.\n            // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n            // coeffToString to throw.\n            if (r.c[0]) {\n                e = r.e;\n                s = e + dp;\n                if (s < 3) s = 0;\n                // Newton-Raphson iteration.\n                for(;;){\n                    t = r;\n                    r = half.times(t.plus(div(x, t, dp, 1)));\n                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\n                        // The exponent of r may here be one less than the final result exponent,\n                        // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                        // are indexed correctly.\n                        if (r.e < e) --s;\n                        n = n.slice(s - 3, s + 1);\n                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                        // iteration.\n                        if (n == \"9999\" || !rep && n == \"4999\") {\n                            // On the first iteration only, check to see if rounding up gives the\n                            // exact result as the nines may infinitely repeat.\n                            if (!rep) {\n                                round(t, t.e + DECIMAL_PLACES + 2, 0);\n                                if (t.times(t).eq(x)) {\n                                    r = t;\n                                    break;\n                                }\n                            }\n                            dp += 4;\n                            s += 4;\n                            rep = 1;\n                        } else {\n                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                            // result. If not, then there are further digits and m will be truthy.\n                            if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                                // Truncate to the first rounding digit.\n                                round(r, r.e + DECIMAL_PLACES + 2, 1);\n                                m = !r.times(r).eq(x);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.toExponential = function(dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp++;\n            }\n            return format(this, dp, rm, 1);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */ P.toFixed = function(dp, rm) {\n            if (dp != null) {\n                intCheck(dp, 0, MAX);\n                dp = dp + this.e + 1;\n            }\n            return format(this, dp, rm);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */ P.toFormat = function(dp, rm, format) {\n            var str, x = this;\n            if (format == null) {\n                if (dp != null && rm && typeof rm == \"object\") {\n                    format = rm;\n                    rm = null;\n                } else if (dp && typeof dp == \"object\") {\n                    format = dp;\n                    dp = rm = null;\n                } else {\n                    format = FORMAT;\n                }\n            } else if (typeof format != \"object\") {\n                throw Error(bignumberError + \"Argument not an object: \" + format);\n            }\n            str = x.toFixed(dp, rm);\n            if (x.c) {\n                var i, arr = str.split(\".\"), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || \"\", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;\n                if (g2) i = g1, g1 = g2, g2 = i, len -= i;\n                if (g1 > 0 && len > 0) {\n                    i = len % g1 || g1;\n                    intPart = intDigits.substr(0, i);\n                    for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);\n                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                    if (isNeg) intPart = \"-\" + intPart;\n                }\n                str = fractionPart ? intPart + (format.decimalSeparator || \"\") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp(\"\\\\d{\" + g2 + \"}\\\\B\", \"g\"), \"$&\" + (format.fractionGroupSeparator || \"\")) : fractionPart) : intPart;\n            }\n            return (format.prefix || \"\") + str + (format.suffix || \"\");\n        };\n        /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */ P.toFraction = function(md) {\n            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;\n            if (md != null) {\n                n = new BigNumber(md);\n                // Throw if md is less than one or is not an integer, unless it is Infinity.\n                if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                    throw Error(bignumberError + \"Argument \" + (n.isInteger() ? \"out of range: \" : \"not an integer: \") + valueOf(n));\n                }\n            }\n            if (!xc) return new BigNumber(x);\n            d = new BigNumber(ONE);\n            n1 = d0 = new BigNumber(ONE);\n            d1 = n0 = new BigNumber(ONE);\n            s = coeffToString(xc);\n            // Determine initial denominator.\n            // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n            e = d.e = s.length - x.e - 1;\n            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;\n            exp = MAX_EXP;\n            MAX_EXP = 1 / 0;\n            n = new BigNumber(s);\n            // n0 = d1 = 0\n            n0.c[0] = 0;\n            for(;;){\n                q = div(n, d, 0, 1);\n                d2 = d0.plus(q.times(d1));\n                if (d2.comparedTo(md) == 1) break;\n                d0 = d1;\n                d1 = d2;\n                n1 = n0.plus(q.times(d2 = n1));\n                n0 = d2;\n                d = n.minus(q.times(d2 = d));\n                n = d2;\n            }\n            d2 = div(md.minus(d0), d1, 0, 1);\n            n0 = n0.plus(d2.times(n1));\n            d0 = d0.plus(d2.times(d1));\n            n0.s = n1.s = x.s;\n            e = e * 2;\n            // Determine which fraction is closer to x, n0/d0 or n1/d1\n            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [\n                n1,\n                d1\n            ] : [\n                n0,\n                d0\n            ];\n            MAX_EXP = exp;\n            return r;\n        };\n        /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */ P.toNumber = function() {\n            return +valueOf(this);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */ P.toPrecision = function(sd, rm) {\n            if (sd != null) intCheck(sd, 1, MAX);\n            return format(this, sd, rm, 2);\n        };\n        /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */ P.toString = function(b) {\n            var str, n = this, s = n.s, e = n.e;\n            // Infinity or NaN?\n            if (e === null) {\n                if (s) {\n                    str = \"Infinity\";\n                    if (s < 0) str = \"-\" + str;\n                } else {\n                    str = \"NaN\";\n                }\n            } else {\n                if (b == null) {\n                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, \"0\");\n                } else if (b === 10 && alphabetHasNormalDecimalDigits) {\n                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\n                    str = toFixedPoint(coeffToString(n.c), n.e, \"0\");\n                } else {\n                    intCheck(b, 2, ALPHABET.length, \"Base\");\n                    str = convertBase(toFixedPoint(coeffToString(n.c), e, \"0\"), 10, b, s, true);\n                }\n                if (s < 0 && n.c[0]) str = \"-\" + str;\n            }\n            return str;\n        };\n        /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */ P.valueOf = P.toJSON = function() {\n            return valueOf(this);\n        };\n        P._isBigNumber = true;\n        if (configObject != null) BigNumber.set(configObject);\n        return BigNumber;\n    }\n    // PRIVATE HELPER FUNCTIONS\n    // These functions don't need access to variables,\n    // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\n    function bitFloor(n) {\n        var i = n | 0;\n        return n > 0 || n === i ? i : i - 1;\n    }\n    // Return a coefficient array as a string of base 10 digits.\n    function coeffToString(a) {\n        var s, z, i = 1, j = a.length, r = a[0] + \"\";\n        for(; i < j;){\n            s = a[i++] + \"\";\n            z = LOG_BASE - s.length;\n            for(; z--; s = \"0\" + s);\n            r += s;\n        }\n        // Determine trailing zeros.\n        for(j = r.length; r.charCodeAt(--j) === 48;);\n        return r.slice(0, j + 1 || 1);\n    }\n    // Compare the value of BigNumbers x and y.\n    function compare(x, y) {\n        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n        // Either NaN?\n        if (!i || !j) return null;\n        a = xc && !xc[0];\n        b = yc && !yc[0];\n        // Either zero?\n        if (a || b) return a ? b ? 0 : -j : i;\n        // Signs differ?\n        if (i != j) return i;\n        a = i < 0;\n        b = k == l;\n        // Either Infinity?\n        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n        // Compare exponents.\n        if (!b) return k > l ^ a ? 1 : -1;\n        j = (k = xc.length) < (l = yc.length) ? k : l;\n        // Compare digit by digit.\n        for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n        // Compare lengths.\n        return k == l ? 0 : k > l ^ a ? 1 : -1;\n    }\n    /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */ function intCheck(n, min, max, name) {\n        if (n < min || n > max || n !== mathfloor(n)) {\n            throw Error(bignumberError + (name || \"Argument\") + (typeof n == \"number\" ? n < min || n > max ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(n));\n        }\n    }\n    // Assumes finite n.\n    function isOdd(n) {\n        var k = n.c.length - 1;\n        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n    }\n    function toExponential(str, e) {\n        return (str.length > 1 ? str.charAt(0) + \".\" + str.slice(1) : str) + (e < 0 ? \"e\" : \"e+\") + e;\n    }\n    function toFixedPoint(str, e, z) {\n        var len, zs;\n        // Negative exponent?\n        if (e < 0) {\n            // Prepend zeros.\n            for(zs = z + \".\"; ++e; zs += z);\n            str = zs + str;\n        // Positive exponent\n        } else {\n            len = str.length;\n            // Append zeros.\n            if (++e > len) {\n                for(zs = z, e -= len; --e; zs += z);\n                str += zs;\n            } else if (e < len) {\n                str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        return str;\n    }\n    // EXPORT\n    BigNumber = clone();\n    BigNumber[\"default\"] = BigNumber.BigNumber = BigNumber;\n    // AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return BigNumber;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // Node.js and other environments that support module.exports.\n    } else {}\n})(void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcyIsIm1hcHBpbmdzIjoiOztBQUFFLFVBQVVBLFlBQVk7SUFDdEI7SUFFRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNkNDLEdBR0MsSUFBSUMsV0FDRkMsWUFBWSw4Q0FDWkMsV0FBV0MsS0FBS0MsSUFBSSxFQUNwQkMsWUFBWUYsS0FBS0csS0FBSyxFQUV0QkMsaUJBQWlCLHNCQUNqQkMsZ0JBQWdCRCxpQkFBaUIsMERBRWpDRSxPQUFPLE1BQ1BDLFdBQVcsSUFDWEMsbUJBQW1CLGtCQUNuQix3REFBd0Q7SUFDeERDLFdBQVc7UUFBQztRQUFHO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFLO1FBQU07UUFBTTtRQUFNO0tBQUssRUFDbEZDLFlBQVksS0FFWixXQUFXO0lBQ1gsMEZBQTBGO0lBQzFGLHNFQUFzRTtJQUN0RUMsTUFBTSxLQUF1QyxpQkFBaUI7SUFHaEU7O0dBRUMsR0FDRCxTQUFTQyxNQUFNQyxZQUFZO1FBQ3pCLElBQUlDLEtBQUtDLGFBQWFDLGNBQ3BCQyxJQUFJcEIsVUFBVXFCLFNBQVMsR0FBRztZQUFFQyxhQUFhdEI7WUFBV3VCLFVBQVU7WUFBTUMsU0FBUztRQUFLLEdBQ2xGQyxNQUFNLElBQUl6QixVQUFVLElBR3BCLHdGQUF3RjtRQUd4RixnRkFBZ0Y7UUFDaEYsa0VBQWtFO1FBRWxFLDBFQUEwRTtRQUMxRTBCLGlCQUFpQixJQUVqQixtRkFBbUY7UUFDbkYsK0VBQStFO1FBQy9FLCtCQUErQjtRQUMvQiw2QkFBNkI7UUFDN0Isa0NBQWtDO1FBQ2xDLGtDQUFrQztRQUNsQyw4REFBOEQ7UUFDOUQsZ0VBQWdFO1FBQ2hFLGtGQUFrRjtRQUNsRiw2RUFBNkU7UUFDN0UsNkVBQTZFO1FBQzdFQyxnQkFBZ0IsR0FFaEIsNkNBQTZDO1FBRTdDLGlGQUFpRjtRQUNqRixrQkFBa0I7UUFDbEJD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WWU7SUFDWmYsU0FBUyxDQUFDLFVBQVUsR0FBR0EsVUFBVUEsU0FBUyxHQUFHQTtJQUU3QyxPQUFPO0lBQ1AsSUFBSSxJQUF5QyxFQUFFO1FBQzdDeVEsbUNBQU87WUFBYyxPQUFPelE7UUFBVyxDQUFDO0FBQUEsa0dBQUM7SUFFM0MsOERBQThEO0lBQzlELE9BQU8sRUFVTjtBQUNILEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vc3AvLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcz9lNDdjIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMlxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIxIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB0ID0geWMsIHljID0geGMsIHhjID0gdCwgYiA9IGE7XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgaWYgKHIuZSA8IGUpIC0tcztcclxuICAgICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE9uIHRoZSBmaXJzdCBpdGVyYXRpb24gb25seSwgY2hlY2sgdG8gc2VlIGlmIHJvdW5kaW5nIHVwIGdpdmVzIHRoZVxyXG4gICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCh0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwKys7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICAgKiB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICAgKiBidXQgZS5nLiAoLTAuMDAwMDEpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRlZFxyXG4gICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBGT1JNQVQgPSB7XHJcbiAgICAgKiAgIHByZWZpeDogJycsXHJcbiAgICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAqICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICogICBzdWZmaXg6ICcnXHJcbiAgICAgKiB9O1xyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICAgKi9cclxuICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZHAsIHJtLCBmb3JtYXQpIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgICBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgICAgZHAgPSBybSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgbm90IGFuIG9iamVjdDogJyArIGZvcm1hdCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgICAgaWYgKHguYykge1xyXG4gICAgICAgIHZhciBpLFxyXG4gICAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgICBnMSA9ICtmb3JtYXQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iXSwibmFtZXMiOlsiZ2xvYmFsT2JqZWN0IiwiQmlnTnVtYmVyIiwiaXNOdW1lcmljIiwibWF0aGNlaWwiLCJNYXRoIiwiY2VpbCIsIm1hdGhmbG9vciIsImZsb29yIiwiYmlnbnVtYmVyRXJyb3IiLCJ0b29NYW55RGlnaXRzIiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX1NBRkVfSU5URUdFUiIsIlBPV1NfVEVOIiwiU1FSVF9CQVNFIiwiTUFYIiwiY2xvbmUiLCJjb25maWdPYmplY3QiLCJkaXYiLCJjb252ZXJ0QmFzZSIsInBhcnNlTnVtZXJpYyIsIlAiLCJwcm90b3R5cGUiLCJjb25zdHJ1Y3RvciIsInRvU3RyaW5nIiwidmFsdWVPZiIsIk9ORSIsIkRFQ0lNQUxfUExBQ0VTIiwiUk9VTkRJTkdfTU9ERSIsIlRPX0VYUF9ORUciLCJUT19FWFBfUE9TIiwiTUlOX0VYUCIsIk1BWF9FWFAiLCJDUllQVE8iLCJNT0RVTE9fTU9ERSIsIlBPV19QUkVDSVNJT04iLCJGT1JNQVQiLCJwcmVmaXgiLCJncm91cFNpemUiLCJzZWNvbmRhcnlHcm91cFNpemUiLCJncm91cFNlcGFyYXRvciIsImRlY2ltYWxTZXBhcmF0b3IiLCJmcmFjdGlvbkdyb3VwU2l6ZSIsImZyYWN0aW9uR3JvdXBTZXBhcmF0b3IiLCJzdWZmaXgiLCJBTFBIQUJFVCIsImFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyIsInYiLCJiIiwiYWxwaGFiZXQiLCJjIiwiY2FzZUNoYW5nZWQiLCJlIiwiaSIsImlzTnVtIiwibGVuIiwic3RyIiwieCIsIl9pc0JpZ051bWJlciIsInMiLCJzbGljZSIsIlN0cmluZyIsInRlc3QiLCJjaGFyQ29kZUF0IiwiaW5kZXhPZiIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJpbnRDaGVjayIsInJvdW5kIiwiREVCVUciLCJFcnJvciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJwdXNoIiwiUk9VTkRfVVAiLCJST1VORF9ET1dOIiwiUk9VTkRfQ0VJTCIsIlJPVU5EX0ZMT09SIiwiUk9VTkRfSEFMRl9VUCIsIlJPVU5EX0hBTEZfRE9XTiIsIlJPVU5EX0hBTEZfRVZFTiIsIlJPVU5EX0hBTEZfQ0VJTCIsIlJPVU5EX0hBTEZfRkxPT1IiLCJFVUNMSUQiLCJjb25maWciLCJzZXQiLCJvYmoiLCJwIiwiaGFzT3duUHJvcGVydHkiLCJwb3AiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CeXRlcyIsIkVYUE9ORU5USUFMX0FUIiwiUkFOR0UiLCJpc0JpZ051bWJlciIsIm4iLCJvdXQiLCJjYWxsIiwibWF4aW11bSIsIm1heCIsIm1heE9yTWluIiwiYXJndW1lbnRzIiwibHQiLCJtaW5pbXVtIiwibWluIiwiZ3QiLCJyYW5kb20iLCJwb3cyXzUzIiwicmFuZG9tNTNiaXRJbnQiLCJkcCIsImEiLCJrIiwicmFuZCIsIlVpbnQzMkFycmF5IiwiY29weSIsInNwbGljZSIsInN1bSIsImFyZ3MiLCJwbHVzIiwiZGVjaW1hbCIsInRvQmFzZU91dCIsImJhc2VJbiIsImJhc2VPdXQiLCJqIiwiYXJyIiwiYXJyTCIsInJldmVyc2UiLCJzaWduIiwiY2FsbGVySXNUb1N0cmluZyIsImQiLCJyIiwieGMiLCJ5Iiwicm0iLCJwb3ciLCJ0b0ZpeGVkUG9pbnQiLCJjb2VmZlRvU3RyaW5nIiwiY29uY2F0IiwibXVsdGlwbHkiLCJiYXNlIiwibSIsInRlbXAiLCJ4bG8iLCJ4aGkiLCJjYXJyeSIsImtsbyIsImtoaSIsImNvbXBhcmUiLCJhTCIsImJMIiwiY21wIiwic3VidHJhY3QiLCJtb3JlIiwicHJvZCIsInByb2RMIiwicSIsInFjIiwicmVtIiwicmVtTCIsInJlbTAiLCJ4aSIsInhMIiwieWMwIiwieUwiLCJ5eiIsInljIiwiTmFOIiwiYml0Rmxvb3IiLCJmb3JtYXQiLCJpZCIsImMwIiwibmUiLCJ0b0V4cG9uZW50aWFsIiwibWV0aG9kIiwibm9ybWFsaXNlIiwiYmFzZVByZWZpeCIsImRvdEFmdGVyIiwiZG90QmVmb3JlIiwiaXNJbmZpbml0eU9yTmFOIiwid2hpdGVzcGFjZU9yUGx1cyIsImlzTmFOIiwicDEiLCJwMiIsInNkIiwibmkiLCJyZCIsInBvd3MxMCIsImFic29sdXRlVmFsdWUiLCJhYnMiLCJjb21wYXJlZFRvIiwiZGVjaW1hbFBsYWNlcyIsImRpdmlkZWRCeSIsImRpdmlkZWRUb0ludGVnZXJCeSIsImlkaXYiLCJleHBvbmVudGlhdGVkQnkiLCJoYWxmIiwiaXNNb2RFeHAiLCJuSXNCaWciLCJuSXNOZWciLCJuSXNPZGQiLCJpc0ludGVnZXIiLCJpc09kZCIsIm1vZCIsInRpbWVzIiwiaW50ZWdlclZhbHVlIiwiaXNFcXVhbFRvIiwiZXEiLCJpc0Zpbml0ZSIsImlzR3JlYXRlclRoYW4iLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaXNMZXNzVGhhbiIsImlzTGVzc1RoYW5PckVxdWFsVG8iLCJsdGUiLCJpc05lZ2F0aXZlIiwiaXNQb3NpdGl2ZSIsImlzWmVybyIsIm1pbnVzIiwidCIsInhMVHkiLCJ4ZSIsInllIiwibW9kdWxvIiwibXVsdGlwbGllZEJ5IiwieGNMIiwieWNMIiwieWxvIiwieWhpIiwiemMiLCJzcXJ0QmFzZSIsIm5lZ2F0ZWQiLCJwcmVjaXNpb24iLCJzaGlmdGVkQnkiLCJzcXVhcmVSb290Iiwic3FydCIsInJlcCIsInRvRml4ZWQiLCJ0b0Zvcm1hdCIsInNwbGl0IiwiZzEiLCJnMiIsImludFBhcnQiLCJmcmFjdGlvblBhcnQiLCJpc05lZyIsImludERpZ2l0cyIsInN1YnN0ciIsIlJlZ0V4cCIsInRvRnJhY3Rpb24iLCJtZCIsImQwIiwiZDEiLCJkMiIsImV4cCIsIm4wIiwibjEiLCJ0b051bWJlciIsInRvUHJlY2lzaW9uIiwidG9KU09OIiwieiIsImwiLCJuYW1lIiwienMiLCJkZWZpbmUiLCJhbWQiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VsZiIsIndpbmRvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bignumber.js/bignumber.js\n");

/***/ })

};
;